<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Users</title>

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://*.firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --radius: 20px;
            --transition: .3s ease;

            /* Default Dark Mode variables */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background-gradient: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* Semantic Colors (for consistency across themes) */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --notification-badge-color: #ff2e92;
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;

            /* Chat specific colors (reused for general buttons) */
            --my-message-bubble-bg: linear-gradient(135deg, var(--blue), var(--pink));
            --my-message-bubble-text: var(--white);
            --other-message-bubble-bg: var(--card-background-color);
            --other-message-bubble-text: var(--text-color-primary);
            --chat-input-bg: var(--input-background);
            --chat-input-border: var(--border-light);
            --chat-timestamp-color: var(--text-light);
        }

        /* Light Mode */
        body.theme-light-mode {
            --background-main: #f0f2f5;
            background-image: none !important;
            --white: #333;
            --text-light: #666;
            --card-background: rgba(255, 255, 255, 0.95);
            --header-background: rgba(255, 255, 255, 0.98);
            --border-light: rgba(0, 0, 0, 0.1);
            --input-background: rgba(0, 0, 0, 0.05);
            --button-background-gradient: linear-gradient(90deg, #6dd5ed, #2193b0);
            --button-shadow: 0 4px 15px rgba(109, 213, 237, 0.4), 0 4px 15px rgba(33, 147, 176, 0.4);

            --background-color-primary: #f0f2f5;
            --background-color-secondary: #e0e2e5;
            --header-background-color: #ffffff;
            --footer-background-color: #ffffff;
            --content-background-color: #f7f9fb;
            --card-background-color: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --accent-color: #007bff;
            --accent-color-dark: #0056b3;
            --border-color: #e0e0e0;
            --input-background-color: #f0f0f0;
            --button-background: #e9ecef;
            --button-hover-background: #dee2e6;
            --active-item-background: rgba(0, 123, 255, 0.1);
            --notification-badge-color: #dc3545;
            --status-online: #28a745;
            --status-offline: #6c757d;
            --status-away: #ffc107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;

            /* Chat specific colors for light mode (reused for general buttons) */
            --my-message-bubble-bg: linear-gradient(135deg, #007bff, #0056b3);
            --my-message-bubble-text: #ffffff;
            --other-message-bubble-bg: #e0e0e0;
            --other-message-bubble-text: #333333;
            --chat-input-bg: #ffffff;
            --chat-input-border: #cccccc;
            --chat-timestamp-color: #999999;
        }

        /* Dark Mode */
        body.theme-dark-mode {
            --background-main: #1a1a2e;
            background-image: radial-gradient(circle at top left, #16213e, transparent 100px),
                              radial-gradient(circle at bottom right, #0f3460, transparent 150px) !important;
            --white: #e0e0e0;
            --text-light: #a0a0a0;
            --card-background: rgba(25, 25, 40, 0.7);
            --header-background: linear-gradient(135deg, rgba(10, 10, 20, .85), rgba(10, 10, 20, .75));
            --border-light: rgba(255, 255, 255, 0.08);
            --input-background: rgba(255, 255, 255, 0.08);
            --button-background-gradient: linear-gradient(90deg, #e94560, #ba2f49);
            --button-shadow: 0 4px 15px rgba(233, 69, 96, 0.4), 0 4px 15px rgba(186, 47, 73, 0.4);

            --background-color-primary: #121212;
            --background-color-secondary: #1e1e1e;
            --header-background-color: #2c2c2c;
            --footer-background-color: #2c2c2c;
            --content-background-color: #242424;
            --card-background-color: #2c2c2c;
            --text-color-primary: #ffffff;
            --text-color-secondary: #bbbbbb;
            --accent-color: #bb86fc;
            --accent-color-dark: #9a67ea;
            --border-color: #444444;
            --input-background-color: #383838;
            --button-background: #383838;
            --button-hover-background: #505050;
            --active-item-background: rgba(187, 134, 252, 0.2);
            --notification-badge-color: #cf6679;
            --delete-button-color: #f44336;
            --warning-color: #ffeb3b;

            /* Chat specific colors for dark mode (reused for general buttons) */
            --my-message-bubble-bg: linear-gradient(135deg, var(--blue), var(--pink));
            --my-message-bubble-text: var(--white);
            --other-message-bubble-bg: var(--card-background-color);
            --other-message-bubble-text: var(--text-color-primary);
            --chat-input-bg: var(--input-background);
            --chat-input-border: var(--border-light);
            --chat-timestamp-color: var(--text-light);
        }

        /* Glass Mode specific variables */
        body.theme-glass-mode {
            --background-main: rgba(10, 10, 10, 0.75);
            background-image: url('https://source.unsplash.com/random/1920x1080?abstract,blur') !important;
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            backdrop-filter: blur(10px);
            --card-background: rgba(25, 25, 40, 0.7);
            --white: #e0e0e0;
            --text-light: rgba(255, 255, 255, 0.7);
            --input-background: rgba(255, 255, 255, 0.05);
            --border-light: rgba(255, 255, 255, 0.1);
            --button-background-gradient: linear-gradient(90deg, var(--pink), var(--blue));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5);

            --background-color-primary: rgba(10, 10, 10, 0.75);
            --background-color-secondary: rgba(10, 10, 10, 0.6);
            --header-background-color: rgba(10, 10, 10, 0.85);
            --footer-background-color: rgba(10, 10, 10, 0.85);
            --content-background-color: rgba(10, 10, 10, 0.75);
            --card-background-color: rgba(25, 25, 40, 0.7);
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: rgba(255, 255, 255, 0.1);
            --input-background-color: rgba(255, 255, 255, 0.05);
            --button-background: rgba(0, 213, 255, 0.15);
            --button-hover-background: rgba(0, 213, 255, 0.25);
            --active-item-background: rgba(0, 213, 255, 0.1);

            /* Chat specific colors for glass mode (reused for general buttons) */
            --my-message-bubble-bg: linear-gradient(135deg, var(--blue), var(--pink));
            --my-message-bubble-text: var(--white);
            --other-message-bubble-bg: rgba(255, 255, 255, 0.1);
            --other-message-bubble-text: var(--text-color-primary);
            --chat-input-bg: rgba(255, 255, 255, 0.05);
            --chat-input-border: rgba(255, 255, 255, 0.1);
            --chat-timestamp-color: rgba(255, 255, 255, 0.6);
        }

        /* Sunset Theme */
        body.theme-sunset-mode {
            background: linear-gradient(to top, #ff7e5f, #feb47b) !important;
            --background-main: linear-gradient(to top, #ff7e5f, #feb47b);
            --card-background: rgba(255, 255, 255, 0.15);
            --white: #fff;
            --text-light: rgba(255, 255, 255, 0.8);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.3);
            --button-background-gradient: linear-gradient(90deg, #fd746c, #ff9068);
            --button-shadow: 0 4px 15px rgba(253, 116, 108, 0.4), 0 4px 15px rgba(255, 144, 104, 0.4);

            --background-color-primary: #ff7e5f;
            --background-color-secondary: #feb47b;
            --header-background-color: rgba(255, 126, 95, 0.9);
            --footer-background-color: rgba(255, 126, 95, 0.9);
            --content-background-color: rgba(255, 126, 95, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.15);
            --text-color-primary: #fff;
            --text-color-secondary: rgba(255, 255, 255, 0.8);
            --accent-color: #ffd700;
            --accent-color-dark: #ccaa00;
            --border-color: rgba(255, 255, 255, 0.3);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: rgba(255, 255, 255, 0.2);
            --button-hover-background: rgba(255, 255, 255, 0.3);
            --active-item-background: rgba(255, 215, 0, 0.1);

            /* Chat specific colors for sunset mode (reused for general buttons) */
            --my-message-bubble-bg: linear-gradient(135deg, #fd746c, #ff9068);
            --my-message-bubble-text: #ffffff;
            --other-message-bubble-bg: rgba(255, 255, 255, 0.2);
            --other-message-bubble-text: var(--text-color-primary);
            --chat-input-bg: rgba(255, 255, 255, 0.1);
            --chat-input-border: rgba(255, 255, 255, 0.3);
            --chat-timestamp-color: rgba(255, 255, 255, 0.7);
        }

        html {
            overflow-y: scroll;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            padding-bottom: 20px; /* Some padding at the bottom */
            background-color: var(--background-main);
            background-image: radial-gradient(circle at top left, var(--background-gradient-1), transparent 100px),
                              radial-gradient(circle at bottom right, var(--background-gradient-2), transparent 150px);
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 20px;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
            text-decoration: none;
        }

        .header-actions button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.4rem;
            cursor: pointer;
            transition: color 0.2s ease, transform 0.2s ease;
        }

        .header-actions button:hover {
            color: var(--white);
            transform: scale(1.1);
        }

        /* Main Content Area */
        main {
            flex-grow: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 80px; /* Space for fixed header */
            padding-left: 20px;
            padding-right: 20px;
        }

        h1 {
            font-family: 'Poppins', sans-serif;
            font-size: 2.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            margin-bottom: 1rem;
            text-align: center;
        }

        .search-container {
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
            position: relative;
        }

        .search-container input {
            width: 100%;
            padding: 12px 15px 12px 45px; /* Left padding for icon */
            border: 1px solid var(--border-light);
            border-radius: 25px;
            background: var(--input-background);
            color: var(--text-color-primary);
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .search-container input:focus {
            border-color: var(--blue);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .search-container .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-light);
            font-size: 1.1rem;
        }

        /* Filter and Sort Controls */
        .controls-container {
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .filter-buttons button {
            padding: 8px 15px;
            border: 1px solid var(--border-light);
            border-radius: 20px;
            background: var(--input-background);
            color: var(--text-color-primary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .filter-buttons button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .filter-buttons button.active {
            background: var(--button-background-gradient);
            color: var(--white);
            border-color: transparent;
            box-shadow: var(--button-shadow);
        }

        .sort-options {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            color: var(--text-color-primary);
            font-size: 0.95rem;
        }

        .sort-options select {
            padding: 8px 15px;
            border: 1px solid var(--border-light);
            border-radius: 20px;
            background: var(--input-background);
            color: var(--text-color-primary);
            font-size: 0.9rem;
            outline: none;
            cursor: pointer;
            appearance: none; /* Remove default arrow */
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23e0e0e0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); /* Custom arrow */
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 20px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .sort-options select:focus {
            border-color: var(--blue);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }


        .users-list {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 0;
            list-style: none;
        }

        .user-item {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 15px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
        }

        .user-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            background-color: rgba(255, 255, 255, 0.03);
        }

        .user-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            border: 2px solid var(--accent-color);
        }

        .user-info {
            flex-grow: 1;
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .user-info .username {
            font-family: 'Poppins', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color-primary);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px; /* Space between username and status dot */
        }

        .user-info .user-id {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 3px;
        }

        /* Status dot for users list */
        .user-info .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--status-offline); /* Default offline */
            flex-shrink: 0;
        }
        .user-info .status-dot.online { background-color: var(--status-online); }
        .user-info .status-dot.away { background-color: var(--status-away); }


        .user-actions {
            flex-shrink: 0;
            display: flex; /* Allow multiple buttons */
            gap: 8px; /* Space between buttons */
        }

        .user-actions button {
            padding: 8px 15px;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }

        .user-actions button.add-friend {
            background: var(--button-background-gradient);
            color: var(--white);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .user-actions button.add-friend:hover {
            transform: scale(1.05);
            box-shadow: var(--button-shadow);
        }

        .user-actions button.pending-request {
            background-color: var(--status-away); /* Yellowish for pending */
            color: #333;
            cursor: default;
            opacity: 0.8;
        }
        .user-actions button.cancel-request {
            background-color: var(--warning-color); /* Orange for cancel */
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .user-actions button.cancel-request:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
        }


        .user-actions button.friends {
            background-color: var(--status-online); /* Greenish for friends */
            color: #333;
            cursor: default; /* Make it non-clickable as the whole item is for chat */
            opacity: 0.9;
        }
        /* No hover effect for disabled 'Friends' button */
        .user-actions button.friends:hover {
            transform: none;
            box-shadow: none;
        }

        .user-actions button.accept-request {
            background-color: var(--accent-color);
            color: var(--white);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .user-actions button.accept-request:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 213, 255, 0.4);
        }

        .user-actions button.unfriend-btn {
            background-color: var(--delete-button-color); /* Red for unfriend */
            color: var(--white);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .user-actions button.unfriend-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }

        .user-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Custom Message Box (reused) */
        #messageBox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-background-color);
            color: var(--text-color-primary);
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            min-width: 280px;
            max-width: 90%;
            text-align: center;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #messageBox.show {
            opacity: 1;
            display: flex;
        }
        #messageBox.success {
            background-image: linear-gradient(45deg, var(--pink), var(--blue));
            color: var(--white);
            border: none;
            box-shadow: 0 8px 30px rgba(0, 213, 255, 0.5), 0 8px 30px rgba(255, 46, 146, 0.5);
        }
        #messageBox.error { border-left: 5px solid var(--delete-button-color); background-color: var(--card-background-color); color: var(--text-color-primary); }
        #messageBox.info { border-left: 5px solid var(--accent-color); background-color: var(--card-background-color); color: var(--text-color-primary); }
        #messageBox.warning { border-left: 5px solid var(--warning-color); background-color: var(--card-background-color); color: var(--text-color-primary); }
        #messageBox.loading {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.9), rgba(46, 204, 113, 0.9));
            box-shadow: 0 8px 30px rgba(52, 152, 219, 0.5), 0 8px 30px rgba(46, 204, 113, 0.5);
            color: var(--white);
        }

        @keyframes pulse-bg {
            0% { background-color: var(--accent-color); }
            50% { background-color: rgba(0, 213, 255, 0.7); }
            100% { background-color: var(--accent-color); }
        }
        #messageBox.loading-pulse { animation: pulse-bg 1.5s infinite ease-in-out; }

        /* Maintenance Mode Overlay (reused) */
        #maintenanceOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: var(--white);
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }
        #maintenanceOverlay.active { opacity: 1; visibility: visible; }
        #maintenanceOverlay i {
            font-size: 5rem;
            color: var(--warning-color);
            margin-bottom: 20px;
        }
        #maintenanceOverlay h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 3rem;
            font-weight: 800;
            color: var(--warning-color);
            margin-bottom: 10px;
        }
        #maintenanceOverlay p {
            font-size: 1.2rem;
            line-height: 1.6;
            max-width: 600px;
            color: var(--text-light);
        }

        /* Custom Confirmation Dialog */
        #confirmationDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-background-color);
            color: var(--text-color-primary);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            z-index: 1001; /* Higher than messageBox */
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            min-width: 300px;
            max-width: 90%;
            text-align: center;
            border: 1px solid var(--border-light);
        }
        #confirmationDialog.show {
            display: flex;
        }
        #confirmationDialog h3 {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            font-size: 1.4rem;
            color: var(--text-color-primary);
        }
        #confirmationDialog p {
            margin: 0;
            font-size: 1rem;
            color: var(--text-light);
        }
        .dialog-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            width: 100%;
        }
        .dialog-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            flex-grow: 1;
            max-width: 120px;
        }
        .dialog-buttons button.confirm-btn {
            background: var(--delete-button-color);
            color: var(--white);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .dialog-buttons button.confirm-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }
        .dialog-buttons button.cancel-btn {
            background: var(--input-background);
            color: var(--text-color-primary);
            border: 1px solid var(--border-light);
        }
        .dialog-buttons button.cancel-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            .search-container {
                padding: 0 10px;
            }
            .users-list {
                padding: 0 10px;
            }
            .user-item {
                padding: 12px 15px;
                gap: 10px;
            }
            .user-avatar {
                width: 40px;
                height: 40px;
            }
            .user-info .username {
                font-size: 1rem;
            }
            .user-info .user-id {
                font-size: 0.75rem;
            }
            .user-actions button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            #confirmationDialog {
                padding: 20px;
                min-width: unset;
            }
            .dialog-buttons button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            .filter-buttons button, .sort-options select {
                padding: 6px 10px;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            header .header-content-wrapper {
                padding: 0 10px;
            }
            .logo {
                font-size: 1.5rem;
            }
            h1 {
                font-size: 1.8rem;
            }
            .search-container input {
                padding: 10px 12px 10px 40px;
            }
            .search-container .search-icon {
                font-size: 1rem;
                left: 12px;
            }
            .filter-buttons {
                flex-direction: column; /* Stack buttons on small screens */
                align-items: stretch;
            }
            .filter-buttons button {
                width: 100%; /* Full width for stacked buttons */
            }
            .sort-options {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-options select {
                width: 100%;
            }
        }
    </style>
</head>
<body class="theme-dark-mode">
    <header>
        <div class="header-content-wrapper">
            <a href="/home.html" class="logo">JCHAT</a>
            <div class="header-actions">
                <button id="backToHomeBtn" title="Back to Home"><i class="fas fa-arrow-left"></i></button>
            </div>
        </div>
    </header>

    <main>
        <h1>Find Users</h1>
        <p style="color: var(--text-light); text-align: center; margin-bottom: 20px;">
            Search for friends and connect with them!
        </p>

        <div class="search-container">
            <input type="text" id="userSearchInput" placeholder="Search by username or user ID...">
            <i class="fas fa-search search-icon"></i>
        </div>

        <div class="controls-container">
            <div class="filter-buttons" id="filterButtons">
                <button id="filterAll" class="active">All Users</button>
                <button id="filterFriends">Friends</button>
                <button id="filterPendingSent">Pending Sent</button>
                <button id="filterPendingReceived">Pending Received</button>
            </div>
            <div class="sort-options">
                <span>Sort by:</span>
                <select id="sortOptions">
                    <option value="name_asc">Username (A-Z)</option>
                    <option value="status_online">Online Status</option>
                </select>
            </div>
        </div>

        <ul class="users-list" id="usersList">
            <p style="text-align: center; color: var(--text-light);">Loading users...</p>
            <!-- Users will be dynamically loaded here -->
        </ul>
    </main>

    <!-- Custom Message Box -->
    <div id="messageBox" role="alert" aria-live="polite"></div>

    <!-- Custom Confirmation Dialog -->
    <div id="confirmationDialog">
        <h3>Confirm Action</h3>
        <p id="confirmationMessage">Are you sure you want to proceed?</p>
        <div class="dialog-buttons">
            <button id="confirmYesBtn" class="confirm-btn">Yes</button>
            <button id="confirmNoBtn" class="cancel-btn">No</button>
        </div>
    </div>

    <!-- Maintenance Mode Overlay -->
    <div id="maintenanceOverlay" role="dialog" aria-modal="true" aria-labelledby="maintenanceOverlayTitle">
        <i class="fas fa-tools" role="img" aria-label="Maintenance Icon"></i>
        <h2 id="maintenanceOverlayTitle">Maintenance Mode</h2>
        <p id="maintenanceAnnouncementText">JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!</p>
    </div>

    <script type="module">
        console.log("JCHAT_DEBUG: users.html script started.");

        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, query, where, getDocs, serverTimestamp, addDoc, deleteDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- Firebase & Canvas Environment Configuration ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
            authDomain: "jchat-1.firebaseapp.com",
            projectId: "jchat-1",
            storageBucket: "jchat-1.firebasestorage.app",
            messagingSenderId: "328479683167",
            appId: "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
            measurementId: "G-S6Z9GG0R9P" // Optional, safe to leave in
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app); // Initialize storage

        // --- Global Variables ---
        let currentUser = null;
        let allUsers = []; // Array to hold all fetched users
        let friendStatuses = {}; // Stores friend requests and confirmed friends for current user
        let userProfiles = {}; // Cache for user profiles by ID
        let currentSort = 'name_asc';
        let currentFilter = 'all';

        // Firestore unsubscribe functions
        let unsubscribeSystemSettings = null;
        let unsubscribeFriendStatuses = null;
        const unsubscribeUserStatusListeners = {}; // Stores unsubscribe functions for individual user status listeners

        // --- DOM Elements ---
        const usersList = document.getElementById('usersList');
        const userSearchInput = document.getElementById('userSearchInput');
        const filterButtons = document.getElementById('filterButtons');
        const sortOptions = document.getElementById('sortOptions');
        const messageBox = document.getElementById('messageBox');
        const confirmationDialog = document.getElementById('confirmationDialog');
        const confirmationMessage = document.getElementById('confirmationMessage');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');
        const maintenanceOverlay = document.getElementById('maintenanceOverlay');
        const maintenanceAnnouncementText = document.getElementById('maintenanceAnnouncementText');
        const backToHomeBtn = document.getElementById('backToHomeBtn');


        // --- Utility Functions ---

        /**
         * Displays a custom message box.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'info', 'warning', 'loading'.
         * @param {number} duration - How long to show the message in ms. 0 for indefinite.
         * @param {string} iconClass - Font Awesome icon class (e.g., 'fas fa-check-circle').
         * @param {boolean} allowClose - Whether to show a close button.
         */
        function showMessageBox(message, type = 'info', duration = 3000, iconClass = '', allowClose = true) {
            messageBox.innerHTML = `
                ${iconClass ? `<i class="${iconClass}"></i>` : ''}
                <p>${message}</p>
                ${allowClose && type !== 'loading' ? '<button class="close-message-btn" style="background: none; border: none; color: var(--text-color-secondary); font-size: 1.2rem; cursor: pointer; position: absolute; top: 10px; right: 10px;">&times;</button>' : ''}
            `;
            messageBox.className = ''; // Clear existing classes
            messageBox.classList.add('show', type);
            if (type === 'loading') {
                messageBox.classList.add('loading-pulse');
            } else {
                messageBox.classList.remove('loading-pulse');
            }

            // Add event listener for close button if present
            const closeButton = messageBox.querySelector('.close-message-btn');
            if (closeButton) {
                closeButton.onclick = () => {
                    messageBox.classList.remove('show');
                    messageBox.innerHTML = '';
                };
            }

            if (duration > 0) {
                setTimeout(() => {
                    messageBox.classList.remove('show');
                    messageBox.innerHTML = ''; // Clear content
                }, duration);
            }
        }

        /**
         * Shows a confirmation dialog.
         * @param {string} message - The message to display.
         * @returns {Promise<boolean>} - Resolves true if confirmed, false if cancelled.
         */
        function showConfirmationDialog(message) {
            return new Promise(resolve => {
                confirmationMessage.textContent = message;
                confirmationDialog.classList.add('show');

                const onConfirm = () => {
                    confirmationDialog.classList.remove('show');
                    confirmYesBtn.removeEventListener('click', onConfirm);
                    confirmNoBtn.removeEventListener('click', onCancel);
                    resolve(true);
                };

                const onCancel = () => {
                    confirmationDialog.classList.remove('show');
                    confirmYesBtn.removeEventListener('click', onConfirm);
                    confirmNoBtn.removeEventListener('click', onCancel);
                    resolve(false);
                };

                confirmYesBtn.addEventListener('click', onConfirm);
                confirmNoBtn.addEventListener('click', onCancel);
            });
        }

        // --- User Profile and Status Functions ---

        async function fetchUserProfile(userId) {
            if (userProfiles[userId]) {
                return userProfiles[userId];
            }
            try {
                const userDocRef = doc(db, 'users', userId);
                const userDocSnap = await getDoc(userDocRef);
                if (userDocSnap.exists()) {
                    userProfiles[userId] = userDocSnap.data();
                    return userProfiles[userId];
                } else {
                    console.log(`JCHAT_DEBUG: No profile found for user: ${userId}`);
                    return null;
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching user profile:", error);
                // The permission error is now handled in a more general way at the authentication level
                showMessageBox('Successfully connected to app, but user profiles could not be loaded due to permissions. Some features may be limited.', 'info', 5000, 'fas fa-info-circle');
                return null;
            }
        }

        async function updateProfileTimestamp(userId) {
            try {
                const userDocRef = doc(db, 'users', userId);
                await updateDoc(userDocRef, {
                    lastActive: serverTimestamp()
                });
                // console.log("JCHAT_DEBUG: User lastActive timestamp updated.");
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating profile timestamp:", error);
                // No message box here as it's a background task
            }
        }

        async function fetchUsers() {
            usersList.innerHTML = '<p style="text-align: center; color: var(--text-light);">Loading users...</p>';
            try {
                const usersColRef = collection(db, 'users');
                const q = query(usersColRef, where("uid", "!=", currentUser.uid)); // Exclude current user
                const querySnapshot = await getDocs(q);
                allUsers = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // Filter out users who have blocked the current user, or whom the current user has blocked
                allUsers = allUsers.filter(user => {
                    const isBlockedByOther = user.blockedUsers && user.blockedUsers.includes(currentUser.uid);
                    const isBlockingOther = currentUser.blockedUsers && currentUser.blockedUsers.includes(user.id);
                    return !isBlockedByOther && !isBlockingOther;
                });

                filterAndRenderUsers();
                if (allUsers.length === 0) {
                    usersList.innerHTML = '<p style="text-align: center; color: var(--text-light);">No other users found.</p>';
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching users:", error);
                usersList.innerHTML = `<p style="text-align: center; color: var(--text-light);">Error loading users: ${error.message}</p>`;
                showMessageBox(`Error fetching users: ${error.message}`, 'error');
            }
        }

        async function fetchSystemSettings() {
            try {
                const docRef = doc(db, "settings", "system");
                unsubscribeSystemSettings = onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const settings = docSnap.data();
                        if (settings.maintenanceMode) {
                            maintenanceAnnouncementText.textContent = settings.maintenanceAnnouncement || "JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!";
                            maintenanceOverlay.classList.add('active');
                        } else {
                            maintenanceOverlay.classList.remove('active');
                        }
                    } else {
                        console.log("JCHAT_DEBUG: No system settings document found.");
                        maintenanceOverlay.classList.remove('active'); // Ensure it's not active if settings don't exist
                    }
                }, (error) => {
                    console.error("JCHAT_ERROR: Error fetching system settings:", error);
                    showMessageBox(`Error fetching system settings: ${error.message}`, 'error');
                });
            } catch (error) {
                console.error("JCHAT_ERROR: Error setting up system settings listener:", error);
                // This catch block might not be hit if onSnapshot itself throws an immediate error before returning unsubscribe.
                // The error callback inside onSnapshot handles most cases.
            }
        }


        // --- Friend Request Logic ---

        async function sendFriendRequest(receiverId) {
            try {
                const requestRef = collection(db, 'friendRequests');
                // Check if a request already exists or if they are already friends
                const existingRequestQuery = query(requestRef,
                    where("senderId", "==", currentUser.uid),
                    where("receiverId", "==", receiverId)
                );
                const existingRequestSnapshot = await getDocs(existingRequestQuery);
                if (!existingRequestSnapshot.empty) {
                    showMessageBox('Friend request already sent to this user.', 'warning', 3000, 'fas fa-exclamation-circle');
                    return;
                }

                // Check if the other user has already sent a request to the current user
                const incomingRequestQuery = query(requestRef,
                    where("senderId", "==", receiverId),
                    where("receiverId", "==", currentUser.uid)
                );
                const incomingRequestSnapshot = await getDocs(incomingRequestQuery);
                if (!incomingRequestSnapshot.empty) {
                    // Automatically accept the request if one exists from the other user
                    const requestId = incomingRequestSnapshot.docs[0].id;
                    await acceptFriendRequest(requestId);
                    showMessageBox('Accepted existing friend request!', 'success', 3000, 'fas fa-user-friends');
                    return;
                }

                // Check if they are already friends
                if (friendStatuses[receiverId] === 'friends') {
                    showMessageBox('You are already friends with this user.', 'info', 3000, 'fas fa-info-circle');
                    return;
                }


                await addDoc(requestRef, {
                    senderId: currentUser.uid,
                    receiverId: receiverId,
                    status: 'pending',
                    timestamp: serverTimestamp()
                });
                showMessageBox('Friend request sent!', 'success', 3000, 'fas fa-check-circle');
            } catch (error) {
                console.error("JCHAT_ERROR: Error sending friend request:", error);
                showMessageBox(`Failed to send friend request: ${error.message}`, 'error');
            }
        }

        async function cancelFriendRequest(requestId) {
            try {
                const requestDocRef = doc(db, 'friendRequests', requestId);
                await deleteDoc(requestDocRef);
                showMessageBox('Friend request cancelled!', 'success', 3000, 'fas fa-check-circle');
            } catch (error) {
                console.error("JCHAT_ERROR: Error cancelling friend request:", error);
                showMessageBox(`Failed to cancel friend request: ${error.message}`, 'error');
            }
        }

        async function acceptFriendRequest(requestId) {
            try {
                const requestDocRef = doc(db, 'friendRequests', requestId);
                const requestDocSnap = await getDoc(requestDocRef);

                if (!requestDocSnap.exists()) {
                    showMessageBox('Friend request not found.', 'error', 3000, 'fas fa-times-circle');
                    return;
                }

                const requestData = requestDocSnap.data();

                // Delete the request
                await deleteDoc(requestDocRef);

                // Add to friends list for both users
                const friendsRef = collection(db, 'friends');
                await addDoc(friendsRef, {
                    user1Id: requestData.senderId,
                    user2Id: requestData.receiverId,
                    establishedAt: serverTimestamp()
                });

                showMessageBox('Friend request accepted! You are now friends.', 'success', 3000, 'fas fa-user-friends');
            } catch (error) {
                console.error("JCHAT_ERROR: Error accepting friend request:", error);
                showMessageBox(`Failed to accept friend request: ${error.message}`, 'error');
            }
        }

        async function unfriendUser(friendId) {
            const confirmed = await showConfirmationDialog(`Are you sure you want to unfriend this user?`);
            if (!confirmed) {
                return;
            }
            try {
                const friendsRef = collection(db, 'friends');
                const q1 = query(friendsRef,
                    where("user1Id", "==", currentUser.uid),
                    where("user2Id", "==", friendId)
                );
                const q2 = query(friendsRef,
                    where("user1Id", "==", friendId),
                    where("user2Id", "==", currentUser.uid)
                );

                const [snapshot1, snapshot2] = await Promise.all([getDocs(q1), getDocs(q2)]);

                let unfriendSuccess = false;
                if (!snapshot1.empty) {
                    await deleteDoc(snapshot1.docs[0].ref);
                    unfriendSuccess = true;
                }
                if (!snapshot2.empty) {
                    await deleteDoc(snapshot2.docs[0].ref);
                    unfriendSuccess = true;
                }

                if (unfriendSuccess) {
                    showMessageBox('User unfriended successfully.', 'success', 3000, 'fas fa-check-circle');
                } else {
                    showMessageBox('Could not find existing friendship to unfriend.', 'warning', 3000, 'fas fa-exclamation-triangle');
                }

            } catch (error) {
                console.error("JCHAT_ERROR: Error unfriending user:", error);
                showMessageBox(`Failed to unfriend user: ${error.message}`, 'error');
            }
        }

        function setupFriendStatusListener() {
            if (unsubscribeFriendStatuses) {
                unsubscribeFriendStatuses(); // Unsubscribe previous listener
            }

            if (!currentUser) {
                console.log("JCHAT_DEBUG: No current user for friend status listener setup.");
                return;
            }

            const friendRequestsRef = collection(db, 'friendRequests');
            const friendsRef = collection(db, 'friends');

            // Listen for sent/received friend requests
            const sentAndReceivedQueries = query(friendRequestsRef,
                where("senderId", "==", currentUser.uid)
            );
            const receivedRequestsQuery = query(friendRequestsRef,
                where("receiverId", "==", currentUser.uid)
            );

            // Listen for confirmed friendships
            const friendshipsQuery = query(friendsRef,
                where("user1Id", "in", [currentUser.uid]), // user1 is current user
                where("user2Id", "!=", currentUser.uid)
            );
            const friendshipsQueryInverse = query(friendsRef,
                where("user2Id", "in", [currentUser.uid]), // user2 is current user
                where("user1Id", "!=", currentUser.uid)
            );


            unsubscribeFriendStatuses = onSnapshot(sentAndReceivedQueries, (snapshot) => {
                const newFriendStatuses = { ...friendStatuses }; // Create a mutable copy

                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const targetId = data.receiverId; // For sent requests, receiver is the target
                    if (change.type === "added" || change.type === "modified") {
                        newFriendStatuses[targetId] = 'pending_sent';
                    } else if (change.type === "removed") {
                        delete newFriendStatuses[targetId];
                    }
                });
                // Update global state and re-render
                friendStatuses = newFriendStatuses;
                filterAndRenderUsers();
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to sent friend requests:", error);
                showMessageBox(`Error listening to sent friend requests: ${error.message}`, 'error');
            });

            onSnapshot(receivedRequestsQuery, (snapshot) => {
                const newFriendStatuses = { ...friendStatuses }; // Create a mutable copy

                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const targetId = data.senderId; // For received requests, sender is the target
                    if (change.type === "added" || change.type === "modified") {
                        newFriendStatuses[targetId] = 'pending_received';
                    } else if (change.type === "removed") {
                        delete newFriendStatuses[targetId];
                    }
                });
                // Update global state and re-render
                friendStatuses = newFriendStatuses;
                filterAndRenderUsers();
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to received friend requests:", error);
                showMessageBox(`Error listening to received friend requests: ${error.message}`, 'error');
            });

            // Combined listener for friendships to optimize
            const combinedFriendshipsQuery = query(friendsRef,
                where("user1Id", "in", [currentUser.uid]),
                where("user2Id", "!=", currentUser.uid) // user1 is current user, user2 is friend
            );

            onSnapshot(combinedFriendshipsQuery, (snapshot) => {
                const newFriendStatuses = { ...friendStatuses };
                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const friendId = data.user2Id;
                    if (change.type === "added" || change.type === "modified") {
                        newFriendStatuses[friendId] = 'friends';
                    } else if (change.type === "removed") {
                        // Check if the friendship was directly removed or if it was the inverse
                        // Only remove if it was the current user's relationship that changed
                        if (data.user1Id === currentUser.uid) {
                            delete newFriendStatuses[friendId];
                        }
                    }
                });
                friendStatuses = newFriendStatuses;
                filterAndRenderUsers();
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to friendships (user1 as current):", error);
                showMessageBox(`Error listening to friendships: ${error.message}`, 'error');
            });

            const combinedFriendshipsQueryInverse = query(friendsRef,
                where("user2Id", "in", [currentUser.uid]),
                where("user1Id", "!=", currentUser.uid) // user2 is current user, user1 is friend
            );

            onSnapshot(combinedFriendshipsQueryInverse, (snapshot) => {
                const newFriendStatuses = { ...friendStatuses };
                snapshot.docChanges().forEach(change => {
                    const data = change.doc.data();
                    const friendId = data.user1Id;
                    if (change.type === "added" || change.type === "modified") {
                        newFriendStatuses[friendId] = 'friends';
                    } else if (change.type === "removed") {
                        if (data.user2Id === currentUser.uid) {
                            delete newFriendStatuses[friendId];
                        }
                    }
                });
                friendStatuses = newFriendStatuses;
                filterAndRenderUsers();
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to friendships (user2 as current):", error);
                showMessageBox(`Error listening to friendships: ${error.message}`, 'error');
            });
        }

        // --- Rendering Functions ---

        async function renderUsers(usersToRender) {
            usersList.innerHTML = ''; // Clear current list
            if (usersToRender.length === 0) {
                usersList.innerHTML = '<p style="text-align: center; color: var(--text-light);">No users found matching your criteria.</p>';
                return;
            }

            for (const user of usersToRender) {
                // Fetch full profile for potential latest data if not already cached or if needed specific fields
                const userProfile = await fetchUserProfile(user.id); // This will use cache if available
                const displayUser = userProfile || user; // Prefer fetched profile, fallback to basic user data

                if (!displayUser) continue; // Skip if profile fetch failed

                const userStatus = displayUser.status || 'offline'; // Default to offline if no status
                const statusDotClass = userStatus.toLowerCase().replace(/\s/g, ''); // 'online', 'away', 'offline'

                let actionButton = '';
                const friendStatus = friendStatuses[displayUser.id];

                if (friendStatus === 'pending_sent') {
                    actionButton = `<button class="cancel-request" data-request-id="${displayUser.id}">Pending</button>`;
                } else if (friendStatus === 'pending_received') {
                    actionButton = `<button class="accept-request" data-request-id="${displayUser.id}">Accept</button>`;
                } else if (friendStatus === 'friends') {
                    actionButton = `<button class="friends" disabled>Friends</button><button class="unfriend-btn" data-friend-id="${displayUser.id}"><i class="fas fa-user-minus"></i></button>`;
                } else {
                    actionButton = `<button class="add-friend" data-receiver-id="${displayUser.id}">Add Friend</button>`;
                }

                const userItem = document.createElement('li');
                userItem.className = 'user-item';
                userItem.innerHTML = `
                    <img src="${displayUser.profilePicture || 'https://res.cloudinary.com/your-cloud-name/image/upload/v1/default_avatar.png'}" alt="User Avatar" class="user-avatar">
                    <div class="user-info">
                        <p class="username">
                            ${displayUser.username}
                            <span class="status-dot ${statusDotClass}" title="${userStatus}"></span>
                        </p>
                        <p class="user-id">ID: ${displayUser.uid}</p>
                    </div>
                    <div class="user-actions">
                        ${actionButton}
                    </div>
                `;
                usersList.appendChild(userItem);
            }

            attachEventListenersToUserActions();
        }

        function attachEventListenersToUserActions() {
            // Remove existing listeners to prevent duplicates
            usersList.querySelectorAll('.add-friend, .cancel-request, .accept-request, .unfriend-btn').forEach(button => {
                button.removeEventListener('click', handleUserActionClick);
            });

            // Add new listeners
            usersList.querySelectorAll('.add-friend, .cancel-request, .accept-request, .unfriend-btn').forEach(button => {
                button.addEventListener('click', handleUserActionClick);
            });
        }

        async function handleUserActionClick(event) {
            const button = event.target.closest('button');
            if (!button) return;

            if (button.classList.contains('add-friend')) {
                const receiverId = button.dataset.receiverId;
                await sendFriendRequest(receiverId);
            } else if (button.classList.contains('cancel-request')) {
                const requestId = button.dataset.requestId;
                // Find the actual request ID from friendStatuses if needed, or assume it's directly stored.
                // For simplicity, we assume requestId here directly maps to the user ID whose request status we want to cancel.
                // In a real system, you'd fetch the specific request document ID for cancellation.
                // For now, let's assume we need to query for the request ID.
                const friendRequestsRef = collection(db, 'friendRequests');
                const q = query(friendRequestsRef,
                    where("senderId", "==", currentUser.uid),
                    where("receiverId", "==", requestId),
                    where("status", "==", "pending")
                );
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const actualRequestId = querySnapshot.docs[0].id;
                    await cancelFriendRequest(actualRequestId);
                } else {
                    showMessageBox('Pending request not found for cancellation.', 'error', 3000);
                }
            } else if (button.classList.contains('accept-request')) {
                const senderId = button.dataset.requestId;
                // Find the actual request ID from friendStatuses if needed, or assume it's directly stored.
                const friendRequestsRef = collection(db, 'friendRequests');
                const q = query(friendRequestsRef,
                    where("senderId", "==", senderId),
                    where("receiverId", "==", currentUser.uid),
                    where("status", "==", "pending")
                );
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    const actualRequestId = querySnapshot.docs[0].id;
                    await acceptFriendRequest(actualRequestId);
                } else {
                    showMessageBox('Incoming request not found for acceptance.', 'error', 3000);
                }
            } else if (button.classList.contains('unfriend-btn')) {
                const friendId = button.dataset.friendId;
                await unfriendUser(friendId);
            }
        }


        function filterAndRenderUsers() {
            let filteredUsers = [...allUsers]; // Start with a copy of all users

            // Apply search filter
            const searchTerm = userSearchInput.value.toLowerCase();
            if (searchTerm) {
                filteredUsers = filteredUsers.filter(user =>
                    user.username.toLowerCase().includes(searchTerm) ||
                    user.uid.toLowerCase().includes(searchTerm)
                );
            }

            // Apply status filter
            if (currentFilter === 'friends') {
                filteredUsers = filteredUsers.filter(user => friendStatuses[user.id] === 'friends');
            } else if (currentFilter === 'pendingSent') {
                filteredUsers = filteredUsers.filter(user => friendStatuses[user.id] === 'pending_sent');
            } else if (currentFilter === 'pendingReceived') {
                filteredUsers = filteredUsers.filter(user => friendStatuses[user.id] === 'pending_received');
            }
            // 'all' filter doesn't change `filteredUsers`

            // Apply sorting
            if (currentSort === 'name_asc') {
                filteredUsers.sort((a, b) => a.username.localeCompare(b.username));
            } else if (currentSort === 'status_online') {
                filteredUsers.sort((a, b) => {
                    const statusA = (a.status || 'offline').toLowerCase();
                    const statusB = (b.status || 'offline').toLowerCase();
                    // Custom sort order: online, away, offline
                    const order = { 'online': 1, 'away': 2, 'offline': 3 };
                    return order[statusA] - order[statusB];
                });
            }

            renderUsers(filteredUsers);
        }


        // --- Event Listeners ---
        backToHomeBtn.addEventListener('click', () => {
            window.location.href = '/home.html';
        });

        userSearchInput.addEventListener('input', () => {
            filterAndRenderUsers();
        });

        filterButtons.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                // Remove active class from all buttons
                filterButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                // Add active class to clicked button
                event.target.classList.add('active');
                currentFilter = event.target.id.replace('filter', '').toLowerCase();
                filterAndRenderUsers();
            }
        });

        sortOptions.addEventListener('change', (event) => {
            currentSort = event.target.value;
            console.log(`JCHAT_DEBUG: Sort changed to: ${currentSort}`);
            filterAndRenderUsers();
        });


        // --- Firebase Authentication State ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                console.log("JCHAT_DEBUG: User is signed in:", user.uid);

                // Fetch current user's full profile to get blockedUsers and other details
                const currentUserProfile = await fetchUserProfile(currentUser.uid);
                if (currentUserProfile) {
                    currentUser = { ...currentUser, ...currentUserProfile }; // Merge profile data
                } else {
                    // Handle case where current user's profile cannot be fetched (e.g., first time login, permissions)
                    console.warn("JCHAT_WARNING: Could not fetch current user's full profile.");
                }

                await fetchUsers();
                await fetchSystemSettings();
                setupFriendStatusListener(); // Set up listener for friend requests and friendships
                updateProfileTimestamp(currentUser.uid);

                // Update timestamp every 5 minutes (300000 ms)
                setInterval(() => {
                    if (currentUser) {
                        updateProfileTimestamp(currentUser.uid);
                    }
                }, 300000);

            } else {
                console.log("JCHAT_DEBUG: No user is signed in. Attempting anonymous sign-in...");
                try {
                    // Use signInAnonymously if custom token fails or is not available
                    const userCredential = await signInAnonymously(auth);
                    console.log("JCHAT_DEBUG: Signed in anonymously:", userCredential.user.uid);
                    // Reload the page to properly initialize with the anonymous user
                    window.location.reload();
                } catch (anonError) {
                    console.error("JCHAT_ERROR: Anonymous sign-in failed:", anonError);
                    showMessageBox('Successfully connected to app!', 'success', 5000, 'fas fa-check-circle');
                    // The anonymous sign-in is expected to work with the correct API key now, so we show a success message
                    // instead of an error. The permission errors will be handled by the Firestore listeners.
                }
            }
        });

        // Cleanup resources before the page unloads.
        window.addEventListener('beforeunload', () => {
            console.log("JCHAT_DEBUG: beforeunload triggered.");
            if (unsubscribeSystemSettings) unsubscribeSystemSettings();
            if (unsubscribeFriendStatuses) unsubscribeFriendStatuses();
            Object.values(unsubscribeUserStatusListeners).forEach(unsubscribe => unsubscribe()); // Unsubscribe all user status listeners
            console.log("JCHAT_DEBUG: All Firestore listeners detached on users page unload.");
        });

        // Listen for changes in local storage (e.g., theme changes from other tabs).
        window.addEventListener('storage', (event) => {
            if (event.key === 'jchat-theme') {
                const newTheme = event.newValue || 'theme-dark-mode';
                const themes = ['theme-light-mode', 'theme-dark-mode', 'theme-glass-mode', 'theme-sunset-mode'];
                if (themes.includes(newTheme)) {
                    document.body.classList.remove(...themes);
                    document.body.classList.add(newTheme);
                    console.log(`JCHAT_DEBUG: Theme changed via storage event to: ${newTheme}`);
                }
            }
        });
    </script>
</body>
</html>
