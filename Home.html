<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Home</title>

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://*.firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>


    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --glass-black: rgba(10, 10, 10, .75);
            --glass-blue: rgba(0, 213, 255, .15);
            --radius: 20px;
            --transition: .3s ease;

            /* These variables will be overridden by theme classes */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* New variables for consistent theming (Added for consistency with Profile/Levels) */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --notification-badge-color: #ff2e92;
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff; /* A bright cyan */
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;
        }

        /* --- Theme Definitions (Light and Dark Mode) --- */
        /* Light Mode */
        body.theme-light-mode {
            --background-main: #f0f2f5; /* Light gray background */
            --background-gradient-1: #e0e2e5; /* Subtle lighter gradient */
            --background-gradient-2: #d0d2d5; /* Subtle darker gradient */
            --white: #333; /* Dark text for readability */
            --text-light: #666; /* Lighter dark text */
            --card-background: rgba(255, 255, 255, 0.95); /* Near white cards */
            --header-background: rgba(255, 255, 255, 0.98); /* Near white header */
            --border-light: rgba(0, 0, 0, 0.1); /* Light borders */
            --input-background: rgba(0, 0, 0, 0.05); /* Light input background */
            --button-background: linear-gradient(90deg, #6dd5ed, #2193b0); /* Blue gradient */
            --button-shadow: 0 4px 15px rgba(109, 213, 237, 0.4), 0 4px 15px rgba(33, 147, 176, 0.4);

            /* New variables override for light mode */
            --background-color-primary: #f0f2f5;
            --background-color-secondary: #e0e2e5;
            --header-background-color: #ffffff;
            --footer-background-color: #ffffff;
            --content-background-color: #f7f9fb;
            --card-background-color: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --text-color-light: #999999;
            --accent-color: #007bff;
            --accent-color-dark: #0056b3;
            --border-color: #e0e0e0;
            --input-background-color: #f0f0f0;
            --button-background: #e9ecef;
            --button-hover-background: #dee2e6;
            --active-item-background: rgba(0, 123, 255, 0.1);
            --notification-badge-color: #dc3545;
            --status-online: #28a745;
            --status-offline: #6c757d;
            --status-away: #ffc107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
        }

        /* Dark Mode */
        body.theme-dark-mode {
            --background-main: #1a1a2e; /* Deep purple-dark blue */
            --background-gradient-1: #16213e; /* Slightly lighter deep blue */
            --background-gradient-2: #0f3460; /* Darker blue */
            --white: #e0e0e0; /* Off-white text */
            --text-light: #a0a0a0; /* Grayish text */
            --card-background: rgba(25, 25, 40, 0.7); /* Darker, less transparent cards */
            --header-background: linear-gradient(135deg, rgba(10, 10, 20, .85), rgba(10, 10, 20, .75)); /* Original dark header */
            --border-light: rgba(255, 255, 255, 0.08); /* Subtle white borders */
            --input-background: rgba(255, 255, 255, 0.08); /* Dark input background */
            --button-background: linear-gradient(90deg, #e94560, #ba2f49); /* Reddish gradient */
            --button-shadow: 0 4px 15px rgba(233, 69, 96, 0.4), 0 4px 15px rgba(186, 47, 73, 0.4);

            /* New variables override for dark mode */
            --background-color-primary: #121212;
            --background-color-secondary: #1e1e1e;
            --header-background-color: #2c2c2c;
            --footer-background-color: #2c2c2c;
            --content-background-color: #242424;
            --card-background-color: #2c2c2c;
            --text-color-primary: #ffffff;
            --text-color-secondary: #bbbbbb;
            --accent-color: #bb86fc;
            --accent-color-dark: #9a67ea;
            --border-color: #444444;
            --input-background-color: #383838;
            --button-background: #383838;
            --button-hover-background: #505050;
            --active-item-background: rgba(187, 134, 252, 0.2);
            --notification-badge-color: #cf6679;
            --delete-button-color: #f44336;
            --warning-color: #ffeb3b;
        }

        /* Glass Mode specific variables */
        body.theme-glass-mode {
            --background-main: rgba(10, 10, 10, 0.75);
            background-image: url('https://source.unsplash.com/random/1920x1080?abstract,blur') !important; /* Added !important */
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            backdrop-filter: blur(10px);
            --card-background: rgba(25, 25, 40, 0.7);
            --white: #e0e0e0; /* text-color */
            --text-light: rgba(255, 255, 255, 0.7);
            --input-background: rgba(255, 255, 255, 0.05);
            --border-light: rgba(255, 255, 255, 0.1); /* glass-border-color */
            --button-background: linear-gradient(90deg, var(--pink), var(--blue));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5); /* Inner shadow for glass effect */

            /* New variables override for glass mode */
            --background-color-primary: rgba(10, 10, 10, 0.75);
            --background-color-secondary: rgba(10, 10, 10, 0.6);
            --header-background-color: rgba(10, 10, 10, 0.85);
            --footer-background-color: rgba(10, 10, 10, 0.85);
            --content-background-color: rgba(10, 10, 10, 0.75);
            --card-background-color: rgba(25, 25, 40, 0.7);
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: rgba(255, 255, 255, 0.1);
            --input-background-color: rgba(255, 255, 255, 0.05);
            --button-background: rgba(0, 213, 255, 0.15); /* Glassy button */
            --button-hover-background: rgba(0, 213, 255, 0.25);
            --active-item-background: rgba(0, 213, 255, 0.1);
        }

        /* Sunset Theme */
        body.theme-sunset-mode {
            background: linear-gradient(to top, #ff7e5f, #feb47b) !important; /* Added !important */
            --background-main: linear-gradient(to top, #ff7e5f, #feb47b);
            --card-background: rgba(255, 255, 255, 0.15); /* Slightly transparent white for contrast */
            --white: #fff; /* White text for readability */
            --text-light: rgba(255, 255, 255, 0.8);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.3);
            --button-background: linear-gradient(90deg, #fd746c, #ff9068); /* Sunset gradient */
            --button-shadow: 0 4px 15px rgba(253, 116, 108, 0.4), 0 44px 15px rgba(255, 144, 104, 0.4);

            /* New variables override for sunset mode */
            --background-color-primary: #ff7e5f;
            --background-color-secondary: #feb47b;
            --header-background-color: rgba(255, 126, 95, 0.9);
            --footer-background-color: rgba(255, 126, 95, 0.9);
            --content-background-color: rgba(255, 126, 95, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.15);
            --text-color-primary: #fff;
            --text-color-secondary: rgba(255, 255, 255, 0.8);
            --accent-color: #ffd700;
            --accent-color-dark: #ccaa00;
            --border-color: rgba(255, 255, 255, 0.3);
            --input-background: rgba(255, 255, 255, 0.1);
            --button-background: rgba(255, 255, 255, 0.2);
            --button-hover-background: rgba(255, 255, 255, 0.3);
            --active-item-background: rgba(255, 215, 0, 0.1);
        }

        /* Always show scrollbar to prevent layout shifts */
        html {
            overflow-y: scroll;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden; /* Prevent horizontal scroll */
            /* Removed padding-bottom as bottom nav is gone */
            background-color: var(--background-main);
            background-image: radial-gradient(circle at top left, var(--background-gradient-1), transparent 100px),
                              radial-gradient(circle at bottom right, var(--background-gradient-2), transparent 150px);
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease; /* Smooth theme transition */
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 55px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 30px;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
            text-decoration: none;
        }

        /* Removed Header Navigation (Home, Profile) */
        header nav {
            display: none; /* Hide the nav element entirely */
        }

        /* User Profile Header Styling */
        .user-profile-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Notification Icon Styling */
        .notification-icon-wrapper {
            position: relative;
            margin-right: 15px; /* Space between notification and profile */
        }

        .notification-icon-wrapper a {
            text-decoration: none; /* Remove underline from link */
            color: inherit; /* Inherit color from parent */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-icon-wrapper i {
    font-size: 1.5rem; /* Adjust size as needed */
    color: var(--white) !important; /* Force icon color to white */
    /* Remove gradient to ensure color is visible */
    background-image: none !important;
    background-clip: initial !important;
    -webkit-background-clip: initial !important;
    -webkit-text-fill-color: initial !important;
    cursor: pointer;
    transition: transform 0.2s ease;
}

        .notification-icon-wrapper i:hover {
            transform: scale(1.1);
        }

        .notification-badge {
    position: absolute;
    top: -5px;
    right: -5px;
    background-color: red !important; /* Force count background to red */
    background-image: none !important; /* Remove any overriding gradient */
    color: var(--white);
    border-radius: 50%;
    padding: 3px 7px;
    font-size: 0.7rem;
    font-weight: 700;
    min-width: 20px;
    text-align: center;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    /* Hide if no notifications */
    display: none;
}

        .user-profile-header #profileLink {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--white);
            transition: opacity 0.3s ease, background-color 0.3s ease;
            padding: 5px 10px;
            border-radius: var(--radius);
        }

        .user-profile-header #profileLink:hover {
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .user-profile-header img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color); /* Used accent-color for consistency */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .user-profile-header i {
            font-size: 30px;
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        .user-profile-header span {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
            /* Apply gradient to names */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        /* Admin Icon Styling */
        #adminIconLink {
            display: none; /* Hidden by default */
            margin-right: 15px; /* Space it out from other icons */
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        #adminIconLink:hover {
            transform: scale(1.1);
        }

        /* Main Content Area */
        main {
            flex-grow: 1;
            padding: 40px 0;
            padding-top: 55px; /* Adjust for fixed header */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top */
            text-align: center;
        }

        .content-wrapper {
            width: 100%;
            max-width: 1000px; /* Adjust as needed */
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        /* Daily Inspiration Section */
        .daily-inspiration-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 2rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            text-align: center;
        }

        .daily-inspiration-section h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 2rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            margin: 0;
        }

        .daily-inspiration-section .quote-text {
            font-size: 1.2rem;
            color: var(--white);
            line-height: 1.6;
            font-style: italic;
            margin: 0;
        }

        .daily-inspiration-section .quote-author {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-top: 0.5rem;
            font-weight: 600;
        }

        .daily-inspiration-section .inspiration-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .inspiration-action-button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 0.8rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .inspiration-action-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--blue), 0 6px 20px var(--pink);
        }
        .inspiration-action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Post Creation Section */
        .post-creation-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 100%;
            max-width: 600px; /* Max width for post creation */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 20px; /* Space from inspiration section */
        }

        .post-creation-section h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            margin-bottom: 0.5rem;
        }

        .post-creation-section textarea {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 1rem;
            outline: none;
            transition: border-color var(--transition), box-shadow var(--transition);
            resize: vertical;
            min-height: 80px;
        }

        .post-creation-section textarea:focus {
            border-color: var(--blue);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .post-creation-section .media-upload-area {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .post-creation-section .file-input-label {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: none; /* Changed from border to none */
            border-radius: 12px;
            padding: 8px 15px;
            cursor: pointer;
            font-weight: 700;
            transition: all var(--transition);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        .post-creation-section .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--blue), 0 44px 15px var(--pink);
        }

        .post-creation-section input[type="file"] {
            display: none;
        }

        .post-creation-section .media-preview {
            max-width: 100px;
            max-height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            display: none;
            margin-left: 10px;
        }

        .post-creation-section .media-preview {
            max-width: 100px;
            max-height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            display: none;
            margin-left: 10px;
        }

        .post-creation-section .post-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
        }

        .post-creation-section .post-button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-creation-section .post-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--blue), 0 6px 20px var(--pink);
        }
        .post-creation-section .post-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Posts Feed Section */
        .posts-feed-section {
            width: 100%;
            max-width: 600px; /* Max width for posts feed */
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px; /* Space from post creation section */
        }

        .post-card {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 4px 15px rgba(0, 0, 0, .2);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative; /* For dropdown menu positioning */
        }

        .post-header .author-pic-wrapper {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid var(--blue);
            flex-shrink: 0;
        }

        .post-header .author-pic {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .post-header .author-pic-placeholder {
            font-size: 40px;
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .post-header .author-info {
            flex-grow: 1;
        }

        .post-header .author-name {
            font-weight: 600;
            color: var(--white);
            font-size: 1rem;
            text-decoration: none; /* Make author name clickable */
        }

        .post-header .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .post-options-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .post-options-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .post-options-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .post-options-dropdown {
            position: absolute;
            top: 40px; /* Position below the button */
            right: 0;
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            min-width: 150px;
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow: hidden; /* For rounded corners on children */
        }

        .post-options-dropdown.active {
            display: flex;
        }

        .post-options-dropdown button {
            background: none;
            border: none;
            color: var(--white);
            padding: 10px 15px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .post-options-dropdown button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .post-options-dropdown button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .post-options-dropdown button i {
            width: 20px; /* Align icons */
        }

        /* Themed buttons in dropdown */
        .post-options-dropdown .edit-post-button {
            background: linear-gradient(90deg, var(--blue), #00d5ff80); /* Blue gradient */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(0, 213, 255, 0.3);
            border-radius: 0; /* Override default button border-radius */
        }
        .post-options-dropdown .edit-post-button:hover {
            background: linear-gradient(90deg, #00b5e0, var(--blue));
            box-shadow: 0 4px 10px rgba(0, 213, 255, 0.5);
        }

        .post-options-dropdown .delete-post-button {
            background: linear-gradient(90deg, var(--pink), #ff2e9280); /* Pink gradient */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(255, 46, 146, 0.3);
            border-radius: 0;
        }
        .post-options-dropdown .delete-post-button:hover {
            background: linear-gradient(90deg, #e02a82, var(--pink));
            box-shadow: 0 4px 10px rgba(255, 46, 146, 0.5);
        }

        .post-options-dropdown .share-post-button {
            background: linear-gradient(90deg, var(--blue), var(--pink)); /* Mixed gradient for share */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border-radius: 0;
        }
        .post-options-dropdown .share-post-button:hover {
            background: linear-gradient(90deg, var(--pink), var(--blue)); /* Reverse gradient on hover */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }


        .post-content-text {
            font-size: 1rem;
            color: var(--white);
            line-height: 1.5;
            word-wrap: break-word;
        }

        .post-media {
            margin-top: 10px;
        }

        .post-media img, .post-media video {
            max-width: 100%;
            border-radius: 10px;
            display: block;
            height: auto;
        }

        .post-reactions-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-light);
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-light);
        }

        .post-reactions-summary span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .post-reactions-summary i {
            font-size: 1rem;
        }

        .post-actions-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding-top: 1rem;
        }

        .post-action-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.2s ease, transform 0.1s ease-out; /* Added transform for animation */
            padding: 8px 12px;
            border-radius: 10px;
        }

        .post-action-button:hover:not(:disabled) {
            color: var(--blue);
            background-color: rgba(0, 213, 255, 0.05);
            transform: translateY(-2px); /* Slight lift on hover */
        }
        .post-action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Reaction button animations */
        .post-action-button.reacted-like {
            color: var(--blue);
            background-color: rgba(0, 213, 255, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }
        .post-action-button.reacted-love {
            color: var(--pink);
            background-color: rgba(255, 46, 146, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }
        .post-action-button.reacted-haha {
            color: #ffd700; /* Gold */
            background-color: rgba(255, 215, 0, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }

        @keyframes pop-reaction {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Comments Section */
        .comments-section {
            margin-top: 1rem;
            border-top: 1px solid var(--border-light);
            padding-top: 1rem;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 1rem;
        }

        .comment-item {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            background-color: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 10px;
        }

        .comment-item .comment-author-pic {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            border: 1px solid var(--blue);
        }

        .comment-item .comment-author-pic-placeholder {
            font-size: 30px;
            color: var(--text-light);
            flex-shrink: 0;
        }

        .comment-item .comment-content-wrapper {
            flex-grow: 1;
            text-align: left;
        }

        .comment-item .comment-author-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--white);
            margin-right: 5px;
            text-decoration: none;
        }

        .comment-item .comment-text {
            font-size: 0.9rem;
            color: var(--text-light);
            word-wrap: break-word;
            display: inline; /* Keep on same line as author for short comments */
        }

        .comment-item .comment-timestamp {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            margin-left: 10px;
        }

        .comment-item .delete-comment-button {
            background: none;
            border: none;
            color: var(--pink);
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.9rem;
            padding: 0; /* Remove padding */
        }
        .comment-item .delete-comment-button:hover:not(:disabled) {
            opacity: 0.8;
        }
        .comment-item .delete-comment-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }


        .comment-input-area {
            display: flex;
            gap: 10px;
            margin-top: 1rem;
            align-items: center;
        }

        .comment-input-area textarea {
            flex-grow: 1;
            padding: 8px 12px;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 0.9rem;
            outline: none;
            resize: vertical;
            min-height: 40px;
            max-height: 80px; /* Limit comment input height */
        }

        .comment-input-area textarea:focus {
            border-color: var(--blue);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .comment-input-area button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 8px 15px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex-shrink: 0;
        }

        .comment-input-area button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
        }
        .comment-input-area button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Customization/Edit Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 2rem;
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            margin-bottom: 0.5rem;
        }

        .modal-content .radio-group,
        .modal-content .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            text-align: left;
        }

        .modal-content label {
            color: var(--text-light);
            font-size: 0.95rem;
            font-weight: 600;
        }

        .modal-content input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--blue);
            border-radius: 50%;
            background-color: var(--input-background);
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .modal-content input[type="radio"]:checked {
            background-color: var(--blue);
            border-color: var(--blue);
        }

        .modal-content input[type="radio"]:checked::after {
            content: '';
            width: 8px;
            height: 8px;
            background-color: var(--white);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .modal-content textarea {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 1rem;
            outline: none;
            transition: border-color var(--transition), box-shadow var(--transition);
            resize: vertical;
            min-height: 80px;
        }
        .modal-content textarea:focus {
            border-color: var(--blue);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .modal-content .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        .modal-content .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .modal-content .cancel-button {
            background: rgba(255, 255, 255, 0.1);
            color: var(--white);
            border: 1px solid var(--border-light);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .modal-content .cancel-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .modal-content .save-button {
            background: var(--button-background);
            color: var(--white);
            box-shadow: var(--button-shadow);
        }

        .modal-content .save-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
        }

        /* Loader styles for buttons */
        .button-loader {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--white);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
        }

        .button-loader.active {
            display: block;
        }

        .button-text {
            display: block;
        }

        .loading .button-text {
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Message Box Styles */
        #messageBox {
            position: fixed;
            top: 50%; /* Centered vertically */
            left: 50%;
            transform: translate(-50%, -50%); /* Centered horizontally and vertically */
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px; /* Increased padding for a 'squarer' feel */
            border-radius: 15px; /* Slightly less rounded */
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5); /* More pronounced shadow */
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; /* Add transform transition */
            min-width: 280px; /* Slightly wider */
            max-width: 90%; /* Responsive max-width */
            text-align: center;
            font-size: 1.1rem; /* Slightly larger font */
            font-weight: 600;
            backdrop-filter: blur(5px); /* Subtle blur for glass effect */
        }
        /* Specific styling for success messages */
        #messageBox.success {
            background: linear-gradient(135deg, var(--blue), var(--pink)); /* Pink and blue gradient */
            border: 2px solid rgba(255, 255, 255, 0.3); /* White border for definition */
            color: var(--white); /* Ensure text is white */
            box-shadow: 0 5px 25px rgba(0, 213, 255, 0.5), 0 5px 25px rgba(255, 46, 146, 0.5); /* Dual color shadow */
        }
        #messageBox.error { border-left: 5px solid var(--delete-button-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Corrected from original */
        #messageBox.info { border-left: 5px solid var(--accent-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Corrected from original */
        #messageBox.warning { border-left: 5px solid var(--warning-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Added for consistency */

        #messageBox i { /* Added for consistency with Profile/Levels */
            font-size: 2.5rem; /* Larger icon for prominence */
            margin-bottom: 5px; /* Space between icon and text */
            /* Apply gradient to message box icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }
        #messageBox.success i { color: var(--white); } /* White icon for success */
        #messageBox.error i { color: var(--delete-button-color); }
        #messageBox.info i { color: var(--accent-color); }
        #messageBox.warning i { color: var(--warning-color); }


        @keyframes pulse-bg {
            0% { background-color: rgba(52, 152, 219, 0.9); }
            50% { background-color: rgba(52, 152, 219, 0.7); }
            100% { background-color: rgba(52, 152, 219, 0.9); }
        }
        #messageBox.loading-pulse { animation: pulse-bg 1.5s infinite ease-in-out; }

        /* Confirmation Modal Specific Styles */
        #confirmationModal .modal-content {
            max-width: 400px;
            text-align: center;
            padding: 1.8rem;
        }
        #confirmationModal .modal-content h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.6rem;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--pink), var(--blue));
            margin-bottom: 1rem;
        }
        #confirmationModal .modal-content p {
            font-size: 1rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }
        #confirmationModal .modal-content .button-group {
            justify-content: center;
            gap: 1rem;
        }
        #confirmationModal .confirm-button {
            background: var(--pink); /* Use pink for destructive action */
            color: var(--white);
            box-shadow: 0 4px 15px var(--pink);
        }
        #confirmationModal .confirm-button:hover {
            background: #e02a82; /* Darker pink on hover */
            box-shadow: 0 6px 20px var(--pink);
        }
        #confirmationModal .cancel-button {
            background: var(--blue); /* Use blue for cancel/safe action */
            color: var(--white);
            box-shadow: 0 4px 15px var(--blue);
        }
        #confirmationModal .cancel-button:hover {
            background: #00b5e0; /* Darker blue on hover */
            box-shadow: 0 6px 20px var(--blue);
        }


        /* --- Sidebar Navigation --- */
        #sidebarNav {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 250px; /* Default sidebar width */
            background: var(--header-background); /* Use header background for consistency */
            border-right: 1px solid var(--border-light);
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
            z-index: 90; /* Higher than main content, lower than modals */
            display: flex;
            flex-direction: column;
            padding: 20px;
            transition: transform 0.3s ease-out; /* Smooth slide transition */
            transform: translateX(-100%); /* Hidden by default */
        }

        #sidebarNav.sidebar-visible {
            transform: translateX(0); /* Show sidebar */
        }

        #sidebarNav.sidebar-hidden {
            transform: translateX(-100%); /* Hide sidebar */
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-light);
        }

        .sidebar-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
        }

        #sidebarCloseBtn {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        #sidebarCloseBtn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--white);
        }

        .sidebar-links {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar-nav-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 15px;
            border-radius: 10px;
            text-decoration: none;
            color: var(--text-light);
            font-size: 1.1rem;
            font-weight: 600;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .sidebar-nav-item:hover {
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--white);
            transform: translateX(5px);
        }

        .sidebar-nav-item.active {
            background-color: rgba(0, 213, 255, 0.15); /* Light blue tint for active */
            color: var(--white);
            border-left: 4px solid var(--blue); /* Highlight active link */
            padding-left: 11px; /* Adjust padding due to border */
        }

        .sidebar-nav-item i {
            font-size: 1.4rem;
            /* Apply gradient to sidebar icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            width: 30px; /* Fixed width for icon alignment */
            text-align: center;
        }

        .sidebar-nav-item span {
            /* Apply gradient to sidebar text labels */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        /* Sidebar Toggle Button in Header */
        #sidebarToggleFab {
            position: static; /* No longer fixed, now part of header flow */
            width: 30px; /* Smaller */
            height: 30px; /* Smaller */
            border-radius: 50%;
            background: linear-gradient(45deg, var(--blue), var(--pink));
            color: var(--white);
            border: none;
            box-shadow: none; /* No shadow by default */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem; /* Smaller icon */
            cursor: pointer;
            z-index: 80;
            transition: opacity 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
            opacity: 0.3; /* Less visible when not in use */
            margin-right: 15px; /* Space from logo */
        }

        #sidebarToggleFab:hover {
            opacity: 1; /* Fully visible on hover */
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow on hover */
            background: linear-gradient(45deg, var(--pink), var(--blue)); /* Reverse gradient on hover */
        }

        /* NEW: Maintenance Mode Overlay */
        #maintenanceOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Darker overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top of everything */
            color: var(--white);
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(8px); /* Subtle blur effect */
            transition: opacity 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        #maintenanceOverlay.active {
            opacity: 1;
            visibility: visible;
        }

        #maintenanceOverlay i {
            font-size: 5rem;
            color: var(--warning-color); /* Use warning color for icon */
            margin-bottom: 20px;
        }

        #maintenanceOverlay h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 3rem;
            font-weight: 800;
            color: var(--warning-color); /* Use warning color for heading */
            margin-bottom: 10px;
        }

        #maintenanceOverlay p {
            font-size: 1.2rem;
            line-height: 1.6;
            max-width: 600px;
            color: var(--text-light);
        }

        /* Call Overlay Styles (NEW) */
        #callOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: var(--white);
            font-family: 'Poppins', sans-serif;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }
        #callOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        #callOverlay .call-status-icon {
            font-size: 5rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            /* Animation for calling/ringing state */
            animation: pulse-color 2s infinite alternate;
        }
        /* New animation for call icon when active */
        @keyframes pulse-color {
            0% { color: var(--accent-color); }
            100% { color: var(--pink); }
        }
        #callOverlay .call-status-text {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 10px;
        }
        #callOverlay .call-timer {
            font-size: 1.5rem;
            color: var(--text-light);
            margin-bottom: 30px;
        }
        #callOverlay .call-actions {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #callOverlay .call-actions button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--white);
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #callOverlay .call-actions button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        #callOverlay .call-actions button.accept-call-btn {
            background: #28a745;
        }
        #callOverlay .call-actions button.decline-call-btn,
        #callOverlay .call-actions button.end-call-btn {
            background: var(--delete-button-color);
        }
        #callOverlay .call-actions button.toggle-mute-btn {
            background: rgba(255, 255, 255, 0.2);
        }
        #callOverlay .call-actions button.toggle-mute-btn.active {
            background: #ccc; /* Grey when muted */
            color: #333;
        }
        #callOverlay .call-actions button.toggle-video-btn {
            background: rgba(255, 255, 255, 0.2);
        }
        #callOverlay .call-actions button.toggle-video-btn.active {
            background: #ccc; /* Grey when video off */
            color: #333;
        }

        /* Video elements within call overlay */
        #callOverlay .video-streams {
            position: relative;
            width: 90%;
            max-width: 800px;
            height: 50%;
            max-height: 450px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: #000;
            display: none; /* Hidden by default until stream is active */
        }
        #localVideo {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 120px;
            height: 90px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            background-color: #333;
            z-index: 1;
            transform: scaleX(-1); /* Mirror local video */
            display: none; /* Hidden by default until stream is active */
        }
        #callOverlay.voice-call .video-streams {
            display: none; /* Hide video streams for voice calls */
        }


        /* Responsive Adjustments */
        @media (max-width: 600px) {
            header .header-content-wrapper {
                padding: 0 20px;
            }
            .logo {
                font-size: 1.6rem;
            }
            #sidebarToggleFab {
                width: 25px;
                height: 25px;
                font-size: 1rem;
                margin-right: 10px;
            }
            .notification-icon-wrapper i, #adminIconLink {
                font-size: 1.3rem;
            }
            .notification-badge {
                padding: 2px 5px;
                font-size: 0.6rem;
            }
            .daily-inspiration-section {
                padding: 1.5rem;
            }
            .daily-inspiration-section h2 {
                font-size: 1.8rem;
            }
            .daily-inspiration-section .quote-text {
                font-size: 1rem;
            }
            .daily-inspiration-section .quote-author {
                font-size: 0.8rem;
            }
            .inspiration-action-button {
                padding: 0.7rem 1.2rem;
                font-size: 0.8rem;
            }
            .post-creation-section {
                padding: 1rem;
            }
            .post-creation-section h3 {
                font-size: 1.3rem;
            }
            .post-creation-section textarea {
                padding: 0.7rem 0.9rem;
                font-size: 0.9rem;
            }
            .post-creation-section .post-button {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
            }
            .post-card {
                padding: 1rem;
            }
            .post-header .author-pic-wrapper {
                width: 35px;
                height: 35px;
            }
            .post-header .author-pic-placeholder {
                font-size: 35px;
            }
            .post-header .author-name {
                font-size: 0.9rem;
            }
            .post-header .post-timestamp {
                font-size: 0.7rem;
            }
            .post-action-button {
                font-size: 0.8rem;
            }
            .post-action-button i {
                font-size: 1rem;
            }
            .comment-item .comment-author-pic {
                width: 25px;
                height: 25px;
            }
            .comment-item .comment-author-pic-placeholder {
                font-size: 25px;
            }
            .comment-item .comment-author-name, .comment-item .comment-text {
                font-size: 0.8rem;
            }
            .comment-item .comment-timestamp {
                font-size: 0.75rem;
            }
            .comment-input-area textarea {
                padding: 6px 10px;
                font-size: 0.85rem;
            }
            .comment-input-area button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .modal-content h3 {
                font-size: 1.3rem;
            }
            .modal-content .radio-option {
                font-size: 0.9rem;
            }
            .modal-content .modal-button {
                padding: 8px 15px;
                font-size: 0.8rem;
            }
            #confirmationModal .modal-content h3 {
                font-size: 1.4rem;
            }
            #confirmationModal .modal-content p {
                font-size: 0.9rem;
            }
            /* Sidebar on mobile: make it full width */
            #sidebarNav {
                width: 100%;
                padding: 20px 10px; /* Adjust padding */
            }

            /* Maintenance Overlay on Mobile */
            #maintenanceOverlay h2 {
                font-size: 2rem;
            }
            #maintenanceOverlay p {
                font-size: 1rem;
            }
            #maintenanceOverlay i {
                font-size: 4rem;
            }
            /* Call Overlay on Mobile */
            #callOverlay .call-status-icon {
                font-size: 4rem;
            }
            #callOverlay .call-status-text {
                font-size: 1.5rem;
            }
            #callOverlay .call-timer {
                font-size: 1.2rem;
            }
            #callOverlay .call-actions button {
                width: 50px;
                height: 50px;
                font-size: 1.8rem;
            }
            #localVideo {
                width: 90px;
                height: 70px;
                bottom: 10px;
                right: 10px;
            }
        }

        /* Posts Controls */
        .post-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-controls select,
        .post-controls input[type="text"],
        .post-controls input[type="date"] {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            background: var(--input-background);
            color: var(--white);
        }
        .post-control-button {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            background: var(--button-background);
            color: var(--white);
            cursor: pointer;
        }
        .post-control-button:hover { opacity: .95; }

        /* Stories Bar */
        .stories-bar { display:flex; gap:10px; padding:8px 0; overflow-x:auto; }
        .story-item { display:flex; flex-direction:column; align-items:center; gap:6px; }
        .story-avatar { width:56px; height:56px; border-radius:50%; border:2px solid var(--blue); background:#333; display:flex; align-items:center; justify-content:center; overflow:hidden; }
        .story-avatar img { width:100%; height:100%; object-fit:cover; }
        .add-story-button { background: var(--button-background); color: var(--white); border: none; padding: 6px 10px; border-radius: 8px; cursor: pointer; }

        /* Engagement Panel */
        .engagement-panel { display:grid; grid-template-columns: 1fr; gap: 12px; margin: 10px 0; }
        .engage-card { background: var(--card-background); border:1px solid var(--glass-blue); border-radius: 15px; padding: 12px; }
        .engage-title { font-weight:600; margin-bottom:6px; }
        .quests-list { display:flex; flex-direction:column; gap:8px; }
        .quest-item { display:flex; align-items:center; justify-content:space-between; gap:10px; }
        .quest-progress { flex:1; height:8px; background:rgba(255,255,255,0.1); border-radius:6px; overflow:hidden; margin:0 8px; }
        .quest-progress > div { height:100%; background: var(--blue); }
        .spin-button { background: linear-gradient(90deg, var(--blue), var(--pink)); color:#fff; border:none; border-radius:10px; padding:8px 12px; cursor:pointer; }

        /* Theme Switcher */
        .theme-switcher { display:flex; gap:8px; align-items:center; }
        .theme-switcher select { padding:6px 10px; border-radius:8px; border:1px solid var(--border-light); background:var(--input-background); color:var(--white); }

        /* Story Viewer (compact) */
        #storyViewer { position: fixed; right: 16px; bottom: 16px; z-index: 1200; display: none; }
        #storyViewer.active { display: block; }
        #storyViewer .viewer-card {
            width: 300px; height: 520px; border-radius: 16px; overflow: hidden;
            background: var(--card-background); border: 1px solid var(--glass-blue);
            box-shadow: 0 12px 30px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;
        }
        #storyViewer .viewer-header { display:flex; align-items:center; justify-content:space-between; padding:8px 10px; }
        #storyViewer .viewer-title { color: var(--white); font-weight: 600; font-size: 0.95rem; }
        #storyViewer .viewer-close { background: transparent; border:none; color: var(--white); cursor:pointer; }
        #storyViewer .viewer-media { flex:1; display:flex; align-items:center; justify-content:center; background:#000; }
        #storyImage, #storyVideo { max-width:100%; max-height:100%; display:none; }
        #storyViewer .viewer-footer { display:flex; align-items:center; justify-content:space-between; padding:6px 10px; }
        #prevStoryBtn, #nextStoryBtn { background: rgba(255,255,255,0.1); color: var(--white); border: 1px solid var(--border-light); border-radius: 10px; padding: 6px 10px; cursor: pointer; }
    #smartScrollBtn { position: fixed; right: 16px; bottom: 90px; z-index: 1100; border: 1px solid var(--border-light); border-radius: 999px; background: var(--button-background); color: #fff; padding: 10px 14px; display: flex; align-items: center; gap: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.4); cursor: pointer; }
        #smartScrollBtn .label { font-weight: 600; }
    </style>
</head>
<body class="theme-dark-mode">

    <header>
        <div class="header-content-wrapper">
            <!-- Sidebar Toggle Button in Header -->
            <button id="sidebarToggleFab" aria-label="Toggle Navigation">
                <i class="fas fa-bars"></i>
            </button>
            <a href="/home.html" class="logo">JCHAT</a>
            <!-- Removed Header Navigation (Home, Profile) -->
            <div class="user-profile-header">
                <!-- Admin Icon Link (visible only to admin) -->
                <a href="/Admin.html" id="adminIconLink" aria-label="Admin Dashboard" style="display: none;">
                    <i class="fas fa-user-cog"></i>
                </a>
                <!-- Notification Icon with Badge -->
                <div class="notification-icon-wrapper">
                    <a href="/notifications.html" aria-label="Notifications">
                        <i class="fas fa-bell"></i>
                        <span class="notification-badge" id="notificationCount" style="display: none;">0</span> <!-- Notification count, initially hidden -->
                    </a>
                </div>
                <!-- Profile Link with Picture and Name (kept as per request) -->
                <a href="/profile.html" id="profileLink" aria-label="View Profile">
                    <img id="headerProfilePic" src="" alt="Profile Picture" style="display: none;">
                    <i id="headerAvatarIcon" class="fas fa-user-circle" role="img" aria-label="User Avatar"></i>
                    <span id="headerDisplayName">Loading...</span>
                </a>
            </div>
        </div>
    </header>

    <main>
        <div class="content-wrapper">
            <!-- Daily Inspiration Section -->
            <div class="daily-inspiration-section">
                <h2>Daily Inspiration</h2>
                <p id="inspirationQuote" class="quote-text">Loading your daily dose of inspiration...</p>
                <p id="inspirationAuthor" class="quote-author"></p>
                <div class="inspiration-actions">
                    <button id="sharePostInspirationButton" class="inspiration-action-button" disabled aria-label="Share Inspiration as Post">
                        <i class="fas fa-share-alt"></i> Share / Post
                    </button>
                    <button id="customizeInspirationButton" class="inspiration-action-button" disabled aria-label="Customize Inspiration Type">
                        <i class="fas fa-cog"></i> Customize Inspiration
                    </button>
                    <!-- NEW: Daily Bonus Button -->
                    <button id="claimDailyBonusButton" class="inspiration-action-button" disabled aria-label="Claim Daily Bonus">
                        <span class="button-text"><i class="fas fa-calendar-check"></i> Claim Daily Bonus</span>
                        <div class="button-loader" role="status" aria-label="Loading"></div>
                    </button>
                </div>
            </div>

            <!-- Post Creation Section -->
            <div class="post-creation-section" id="postCreationSection">
                <h3>Create New Post</h3>
                <textarea id="postContent" placeholder="What's on your mind?" maxlength="50000" disabled aria-label="Post Content"></textarea>
                <div class="media-upload-area">
                    <label for="postMediaUpload" class="file-input-label" aria-label="Add Media to Post">
                        <i class="fas fa-image"></i> Add Media
                    </label>
                    <input type="file" id="postMediaUpload" accept="image/*,video/*" disabled>
                    <img id="mediaImagePreview" class="media-preview" src="" alt="Image Preview" style="display: none;">
                    <video id="mediaVideoPreview" class="media-preview" src="" controls style="display: none;"></video>
                </div>
                <div style="margin:8px 0; display:flex; align-items:center; gap:10px;">
                    <label style="display:flex; align-items:center; gap:6px;">
                        <input type="checkbox" id="addPollCheckbox" disabled> Add Poll
                    </label>
                    <div id="pollComposer" style="display:none; flex-direction:column; gap:6px; width:100%;">
                        <input type="text" class="poll-option-input" placeholder="Option 1" maxlength="100">
                        <input type="text" class="poll-option-input" placeholder="Option 2" maxlength="100">
                        <button id="addPollOptionBtn" class="post-control-button" type="button" style="width:max-content;">Add Option</button>
                    </div>
                </div>
                <div class="post-actions">
                    <button id="createPostButton" class="post-button" disabled aria-label="Create Post">
                        <span class="button-text">Post</span>
                        <div class="button-loader" role="status" aria-label="Loading"></div>
                    </button>
                </div>
            </div>

            <!-- Posts Controls -->
            <div class="post-controls" id="postControls">
                <div class="theme-switcher">
                    <i class="fas fa-adjust"></i>
                    <select id="themeSelect">
                        <option value="theme-light-mode">Light</option>
                        <option value="theme-dark-mode" selected>Dark</option>
                        <option value="theme-glass-mode">Glass</option>
                        <option value="theme-sunset-mode">Sunset</option>
                    </select>
                </div>
                <select id="postTypeFilter">
                    <option value="all">All</option>
                    <option value="text">Text</option>
                    <option value="image">Images</option>
                    <option value="video">Videos</option>
                </select>
                <input type="date" id="postDateFrom" placeholder="From">
                <input type="date" id="postDateTo" placeholder="To">
                <input type="text" id="postSearchInput" placeholder="Search posts...">
                <label style="display:flex;align-items:center;gap:6px;">
                    <input type="checkbox" id="showSavedOnly"> Saved
                </label>
                <button id="exportPostsCsvButton" class="post-control-button">Export CSV</button>
                <button id="exportPostsJsonButton" class="post-control-button">Export JSON</button>
            </div>
            <div id="trendingHashtags" style="margin:8px 0;color:var(--text-light);font-size:0.9rem;"></div>

            <!-- Engagement Panel -->
            <div class="engagement-panel">
                <div class="engage-card" id="streakCard">
                    <div class="engage-title">Daily Streak</div>
                    <div id="streakInfo" style="color:var(--text-light);">Loading streak...</div>
                </div>
                <div class="engage-card" id="questsCard">
                    <div class="engage-title">Weekly Quests</div>
                    <div class="quests-list" id="questsList"></div>
                </div>
                <div class="engage-card" id="spinCard">
                    <div class="engage-title">Daily Spin</div>
                    <button class="spin-button" id="spinNowButton"><i class="fas fa-sync"></i> Spin Now</button>
                    <div id="spinStatus" style="color:var(--text-light); margin-top:6px;"></div>
                </div>
                <div class="engage-card" id="storiesCard">
                    <div style="display:flex;align-items:center;justify-content:space-between;">
                        <div class="engage-title">Stories</div>
                        <button class="add-story-button" id="addStoryButton"><i class="fas fa-plus"></i> Add Story</button>
                        <input type="file" id="storyUploadInput" accept="image/*,video/*" style="display:none;">
                    </div>
                    <div class="stories-bar" id="storiesBar"></div>
                </div>
            </div>

            <!-- Posts Feed Section -->
            <div class="posts-feed-section" id="postsFeed">
                <!-- Posts will be loaded here dynamically -->
                <p style="text-align: center; color: var(--text-light);" id="loadingPostsMessage">Loading posts...</p>
            </div>
        </div>
    </main>

    <!-- Customization Modal -->
    <div id="customizeInspirationModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="customizeInspirationModalTitle">
        <div class="modal-content">
            <h3 id="customizeInspirationModalTitle">Customize Inspiration Type</h3>
            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="motivational" checked aria-label="Motivational Inspiration">
                    Motivational
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="peaceful" aria-label="Peaceful Inspiration">
                    Peaceful
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="funny" aria-label="Funny Inspiration">
                    Funny
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="wisdom" aria-label="Wisdom Inspiration">
                    Wisdom
                </label>
            </div>
            <div class="button-group">
                <button id="cancelCustomize" class="modal-button cancel-button" aria-label="Cancel Customization">Cancel</button>
                <button id="saveCustomize" class="modal-button save-button" aria-label="Save Customization">Save</button>
            </div>
        </div>
    </div>

    <!-- Edit Post Modal -->
    <div id="editPostModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="editPostModalTitle">
        <div class="modal-content">
            <h3 id="editPostModalTitle">Edit Post</h3>
            <div class="input-group">
                <label for="editPostContent">Post Content:</label>
                <textarea id="editPostContent" maxlength="500" aria-label="Edit Post Content"></textarea>
            </div>
            <div class="media-upload-area">
                <label for="editPostMediaUpload" class="file-input-label" aria-label="Change Media for Post">
                    <i class="fas fa-image"></i> Change Media
                </label>
                <input type="file" id="editPostMediaUpload" accept="image/*,video/*">
                <img id="editMediaImagePreview" class="media-preview" src="" alt="Image Preview" style="display: none;">
                <video id="editMediaVideoPreview" class="media-preview" src="" controls style="display: none;"></video>
                <button id="removeEditMedia" class="modal-button cancel-button" style="display: none;" aria-label="Remove Media from Post">Remove Media</button>
            </div>
            <div class="button-group">
                <button id="cancelEditPost" class="modal-button cancel-button" aria-label="Cancel Editing">Cancel</button>
                <button id="saveEditedPost" class="modal-button save-button" aria-label="Save Edited Post">
                    <span class="button-text">Save Changes</span>
                    <div class="button-loader" role="status" aria-label="Loading"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="confirmationTitle">
        <div class="modal-content">
            <h3 id="confirmationTitle">Confirm Action</h3>
            <p id="confirmationMessage">Are you sure you want to proceed with this action?</p>
            <div class="button-group">
                <button id="confirmCancelButton" class="modal-button cancel-button" aria-label="Cancel">Cancel</button>
                <button id="confirmProceedButton" class="modal-button confirm-button" aria-label="Proceed">Proceed</button>
            </div>
        </div>
    </div>

    <!-- Custom Message Box -->
    <div id="messageBox" role="alert" aria-live="polite"></div>

    <!-- NEW: Maintenance Mode Overlay -->
    <div id="maintenanceOverlay" role="dialog" aria-modal="true" aria-labelledby="maintenanceOverlayTitle">
        <i class="fas fa-tools" role="img" aria-label="Maintenance Icon"></i>
        <h2 id="maintenanceOverlayTitle">Maintenance Mode</h2>
        <p id="maintenanceAnnouncementText">JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!</p>
    </div>

    <!-- Call Overlay (NEW) -->
    <div id="callOverlay" role="dialog" aria-modal="true" aria-labelledby="callStatusText">
        <div class="video-streams">
            <video id="remoteVideo" autoplay playsinline aria-label="Remote Video Stream"></video>
            <video id="localVideo" autoplay playsinline muted aria-label="Local Video Stream"></video>
        </div>
        <i id="callStatusIcon" class="fas fa-phone" role="img" aria-label="Call Status Icon"></i>
        <p id="callStatusText" class="call-status-text">Calling...</p>
        <p id="callTimer" class="call-timer" style="display: none;" aria-live="polite">00:00</p>
        <div class="call-actions" id="callActions">
            <button id="acceptCallBtn" class="accept-call-btn" style="display: none;" aria-label="Accept Call"><i class="fas fa-phone"></i></button>
            <button id="declineCallBtn" class="decline-call-btn" style="display: none;" aria-label="Decline Call"><i class="fas fa-phone-slash"></i></button>
            <button id="toggleMuteBtn" class="toggle-mute-btn" style="display: none;" title="Mute/Unmute" aria-label="Toggle Mute"><i class="fas fa-microphone"></i></button>
            <button id="toggleVideoBtn" class="toggle-video-btn" style="display: none;" title="Turn Video On/Off" aria-label="Toggle Video"><i class="fas fa-video"></i></button>
            <button id="endCallBtn" class="end-call-btn" style="display: none;" aria-label="End Call"><i class="fas fa-phone-slash"></i></button>
        </div>
    </div>

    <!-- Sidebar Navigation -->
    <aside id="sidebarNav" class="sidebar-hidden" role="navigation" aria-label="Main Navigation">
        <div class="sidebar-header">
            <span class="sidebar-title">JCHAT Menu</span>
            <button id="sidebarCloseBtn" aria-label="Close Menu">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="sidebar-links">
            <a href="/home.html" class="sidebar-nav-item active" aria-current="page">
                <i class="fas fa-home"></i>
                <span>Home</span>
            </a>
            <a href="/profile.html" class="sidebar-nav-item">
                <i class="fas fa-user"></i>
                <span>Profile</span>
            </a>
            <a href="/Private_Chat.html" class="sidebar-nav-item" id="chatLink">
                <i class="fas fa-comment-dots"></i>
                <span>Chat</span>
            </a>
            <a href="/find_friends.html" class="sidebar-nav-item" id="findFriendsLink">
                <i class="fas fa-users"></i>
                <span>Users</span>
            </a>
            <a href="/friends.html" class="sidebar-nav-item" id="friendsLink">
                <i class="fas fa-user-friends"></i>
                <span>Friends</span>
            </a>
            <a href="/groups.html" class="sidebar-nav-item" id="groupsLink">
                <i class="fas fa-layer-group"></i> <!-- New Groups icon -->
                <span>Groups</span>
            </a>
            <a href="/jcoin_shop.html" class="sidebar-nav-item" id="jcoinShopLink">
                <i class="fas fa-store"></i>
                <span>Shop</span>
            </a>
            <a href="/settings.html" class="sidebar-nav-item">
                <i class="fas fa-cog"></i>
                <span>Settings</span>
            </a>
            <a href="/About_Us.html" class="sidebar-nav-item">
                <i class="fas fa-globe"></i>
                <span>About Us</span>
            </a>
            <a href="/solution_center.html" class="sidebar-nav-item">
                <i class="fas fa-question-circle"></i>
                <span>Solution Center</span>
            </a>
            <!-- NEW: Guide Link - moved inside sidebar-links -->
            <a href="/guide.html" class="sidebar-nav-item">
                <i class="fas fa-book"></i>
                <span>Guide</span>
                </a>
            <!-- NEW: Guide Link - moved inside sidebar-links -->
            <a href="/Community_guidelines.html" class="sidebar-nav-item">
                <i class="fas fa-exclamation-triangle"></i>
                <span>Community Guidelines</span>
            </a>
            <!-- New: Logout Link in Sidebar -->
            <a href="#" id="sidebarLogoutLink" class="sidebar-nav-item">
                <i class="fas fa-sign-out-alt"></i>
                <span>Logout</span>
            </a>
        </div>
    </aside>

    <!-- Smart Scroll Button -->
    <button id="smartScrollBtn" aria-label="Smart Scroll"><i class="fas fa-arrow-down"></i><span class="label">Bottom</span></button>

    <!-- Compact Story Viewer -->
    <div id="storyViewer" aria-live="polite">
        <div class="viewer-card">
            <div class="viewer-header">
                <div class="viewer-title" id="storyViewerTitle">Story</div>
                <button class="viewer-close" id="closeStoryViewer" aria-label="Close"><i class="fas fa-times"></i></button>
            </div>
            <div class="viewer-media">
                <img id="storyImage" alt="story image" />
                <video id="storyVideo" controls playsinline></video>
            </div>
            <div class="viewer-footer">
                <button id="prevStoryBtn"><i class="fas fa-chevron-left"></i> Prev</button>
                <button id="nextStoryBtn">Next <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <script type="module">
        console.log("JCHAT_DEBUG: Home.html script started.");

        // Import Firebase modules (Updated to v11.6.1)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, orderBy, where, getDocs, addDoc, runTransaction, writeBatch, serverTimestamp, arrayUnion, arrayRemove, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase & Canvas Environment Configuration ---
        // Firebase configuration, dynamically loaded from Canvas environment variables if available.
        // Provides fallback values for local development if environment variables are not set.
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
            authDomain: "jchat-1.firebaseapp.com",
            projectId: "jchat-1",
            storageBucket: "jchat-1.firebasestorage.app",
            messagingSenderId: "328479683167",
            appId: "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
            measurementId: "G-S6Z9GG0R9P"
        };
        // Application ID, dynamically loaded from Canvas environment or defaults for local.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // Initial authentication token for Canvas environment.
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Cloudinary Configuration for media uploads.
        const cloudinaryConfig = {
            cloudName: "dxld01rcp",
            uploadPreset: "Storage_preset"
        };

        // Initialize Firebase services: App, Auth, and Firestore.
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- ADMIN UID ---
        // The specific UID for the administrator, used for feature toggling and permissions.
        const ADMIN_UID = 'cc96gdhCRPO72NFZtleRCujHvIq2';

        // --- DOM Elements ---
        // Header elements
        const headerProfilePic = document.getElementById('headerProfilePic');
        const headerAvatarIcon = document.getElementById('headerAvatarIcon');
        const headerDisplayName = document.getElementById('headerDisplayName');
        const notificationCountElement = document.getElementById('notificationCount');
        const adminIconLink = document.getElementById('adminIconLink');
        const profileLink = document.getElementById('profileLink');

        // Daily Inspiration section elements
        const inspirationQuoteElement = document.getElementById('inspirationQuote');
        const inspirationAuthorElement = document.getElementById('inspirationAuthor');
        const sharePostInspirationButton = document.getElementById('sharePostInspirationButton');
        const customizeInspirationButton = document.getElementById('customizeInspirationButton');
        const claimDailyBonusButton = document.getElementById('claimDailyBonusButton');

        // Customize Inspiration Modal elements
        const customizeInspirationModal = document.getElementById('customizeInspirationModal');
        const inspirationTypeRadios = document.querySelectorAll('input[name="inspirationType"]');
        const cancelCustomizeButton = document.getElementById('cancelCustomize');
        const saveCustomizeButton = document.getElementById('saveCustomize');

        // Post Creation section elements
        const postCreationSection = document.getElementById('postCreationSection');
        const postContentInput = document.getElementById('postContent');
        const postMediaUpload = document.getElementById('postMediaUpload');
        const mediaImagePreview = document.getElementById('mediaImagePreview');
        const mediaVideoPreview = document.getElementById('mediaVideoPreview');
        const createPostButton = document.getElementById('createPostButton');
        const postsFeed = document.getElementById('postsFeed');
        const loadingPostsMessage = document.getElementById('loadingPostsMessage');
        const postTypeFilter = document.getElementById('postTypeFilter');
        const postSearchInput = document.getElementById('postSearchInput');
        const postDateFromInput = document.getElementById('postDateFrom');
        const postDateToInput = document.getElementById('postDateTo');
        const exportPostsCsvButton = document.getElementById('exportPostsCsvButton');
        const exportPostsJsonButton = document.getElementById('exportPostsJsonButton');
        const showSavedOnlyCheckbox = document.getElementById('showSavedOnly');
        const trendingHashtagsDiv = document.getElementById('trendingHashtags');

        // Edit Post Modal elements
        const editPostModal = document.getElementById('editPostModal');
        const editPostContentInput = document.getElementById('editPostContent');
        const editPostMediaUpload = document.getElementById('editPostMediaUpload');
        const editMediaImagePreview = document.getElementById('editMediaImagePreview');
        const editMediaVideoPreview = document.getElementById('editMediaVideoPreview');
        const removeEditMediaButton = document.getElementById('removeEditMedia');
        const cancelEditPostButton = document.getElementById('cancelEditPost');
        const saveEditedPostButton = document.getElementById('saveEditedPost');

        // Confirmation Modal elements
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationTitle = document.getElementById('confirmationTitle');
        const confirmationMessage = document.getElementById('confirmationMessage');
        const confirmCancelButton = document.getElementById('confirmCancelButton');
        const confirmProceedButton = document.getElementById('confirmProceedButton');

        // Message Box element for notifications
        const messageBox = document.getElementById('messageBox');

        // Sidebar elements
        const sidebarNav = document.getElementById('sidebarNav');
        const sidebarToggleFab = document.getElementById('sidebarToggleFab');
        const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
        const sidebarNavItems = document.querySelectorAll('.sidebar-nav-item');
        const sidebarLogoutLink = document.getElementById('sidebarLogoutLink');

        // Feature toggle related sidebar links (for dynamic enabling/disabling)
        const chatLink = document.getElementById('chatLink');
        const findFriendsLink = document.getElementById('findFriendsLink');
        const friendsLink = document.getElementById('friendsLink');
        const groupsLink = document.getElementById('groupsLink');
        const jcoinShopLink = document.getElementById('jcoinShopLink');

        // Maintenance Overlay elements
        const maintenanceOverlay = document.getElementById('maintenanceOverlay');
        const maintenanceAnnouncementText = document.getElementById('maintenanceAnnouncementText');

        // Call Overlay Elements (WebRTC)
        const callOverlay = document.getElementById('callOverlay');
        const callStatusIcon = document.getElementById('callStatusIcon');
        const callStatusText = document.getElementById('callStatusText');
        const callTimerDisplay = document.getElementById('callTimer');
        const callActions = document.getElementById('callActions');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const declineCallBtn = document.getElementById('declineCallBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const toggleMuteBtn = document.getElementById('toggleMuteBtn');
        const toggleVideoBtn = document.getElementById('toggleVideoBtn');


        // --- Global State Variables ---
        let currentUser = null; // Stores the Firebase authenticated user object.
        let currentUserProfileData = null; // Stores the authenticated user's own profile data from Firestore.
        let inspirationIntervalId = null; // Interval ID for refreshing daily inspiration.
        let dailyBonusCountdownInterval = null; // Interval for daily bonus cooldown countdown.
        let currentMediaFile = null; // Stores the file object for new post media.
        let currentEditPostId = null; // Stores the ID of the post being edited.
        let currentEditMediaFile = null; // Stores the new file object for edited post media.
        let currentEditMediaUrl = null; // Stores the existing media URL for edited post.
        let currentEditMediaType = null; // Stores the existing media type for edited post.
        let isAuthReady = false; // Flag indicating if Firebase authentication state has been determined.
        let unsubscribeListeners = []; // Array to store all onSnapshot unsubscribe functions for cleanup.
        let currentSystemSettings = {}; // Stores global system settings fetched from Firestore.

        // WebRTC Call State Variables
        let localStream; // Local media stream (audio/video).
        let remoteStream; // Remote media stream from the other peer.
        let peerConnection; // RTCPeerConnection object.
        let currentCallType; // 'voice' or 'video'.
        let isMuted = false; // Mute state for local audio.
        let isVideoOff = false; // Video off state for local video.
        let callState = 'idle'; // Current call state: 'idle', 'calling', 'ringing', 'connected', 'busy', 'declined', 'ended', 'no-answer'.
        let callDuration = 0; // Duration of the current call in seconds.
        let callDurationInterval; // Interval ID for updating call timer.
        let callTimeoutId; // Timeout ID for incoming call no-answer.
        let callRef; // Firestore document reference for the current call.
        let isIncomingCall = false; // Flag to differentiate initiator from receiver.
        let recipientUserProfileData = null; // To store caller's profile for display in incoming calls.


        // --- Theme Management Variables ---
        const themes = [
            'theme-light-mode',
            'theme-dark-mode',
            'theme-glass-mode',
            'theme-sunset-mode'
        ];

        // --- Inspiration Quotes Data (Local Fallback) ---
        // These are used as the primary source of inspiration quotes.
        const inspirationalQuotes = {
            motivational: [
                { quote: "Every sunrise is an invitation to brighten your world.", author: "JCHAT" },
                { quote: "Your potential is limitless; dare to explore it.", author: "JCHAT" },
                { quote: "Small steps forward still lead to great destinations.", author: "JCHAT" },
                { quote: "Embrace challenges, for they forge your strength.", author: "JCHAT" },
                { quote: "The best time for new beginnings is now.", author: "JCHAT" },
            ],
            peaceful: [
                { quote: "Find your calm in the rhythm of your breath.", author: "JCHAT" },
                { quote: "Let go of what was, embrace the serenity of what is.", author: "JCHAT" },
                { quote: "Peace is not the absence of trouble, but the presence of calm within it.", author: "JCHAT" },
                { quote: "In stillness, discover the answers you seek.", author: "JCHAT" },
                { quote: "May your mind be clear, and your heart be light.", author: "JCHAT" },
            ],
            funny: [
                { quote: "I'm not lazy, I'm just on energy-saving mode.", author: "JCHAT" },
                { quote: "My bed is a magical place where I suddenly remember everything I forgot to do.", author: "JCHAT" },
                { quote: "I used to think I was indecisive, but now I'm not so sure.", author: "JCHAT" },
                { quote: "Life is short. Smile while you still have teeth.", author: "JCHAT" },
                { quote: "My favorite exercise is a cross between a lunge and a crunch. I call it lunch.", author: "JCHAT" },
            ],
            wisdom: [
                { quote: "True wisdom lies in knowing the depth of your own ignorance.", author: "JCHAT" },
                { quote: "The greatest teacher is experience.", author: "JCHAT" },
                { quote: "A mind stretched by new experiences never returns to its old dimensions.", author: "JCHAT" },
                { quote: "Listen more than you speak; learn more than you teach.", author: "JCHAT" },
                { quote: "The only true wisdom is in knowing you know nothing.", author: "JCHAT" },
            ]
        };

        // --- Level and XP Progression Logic ---
        /**
         * Provides information about user levels, XP requirements, and rewards.
         * @param {number} level - The current level of the user.
         * @returns {object} An object containing level details.
         */
        function getLevelInfo(level) {
            const levelData = [
                { level: 1, name: "Novice", icon: "fas fa-leaf", jCoinReward: 50, timeEstimate: "3 days" },
                { level: 2, name: "Beginner", icon: "fas fa-seedling", jCoinReward: 100, timeEstimate: "7 days" },
                { level: 3, name: "Apprentice", icon: "fas fa-user-graduate", jCoinReward: 150, timeEstimate: "10 days" },
                { level: 4, name: "Explorer", icon: "fas fa-map-marker-alt", jCoinReward: 200, timeEstimate: "2 weeks" },
                { level: 5, name: "Pioneer", icon: "fas fa-compass", jCoinReward: 250, timeEstimate: "3 weeks" },
                { level: 6, name: "Communicator", icon: "fas fa-comments", jCoinReward: 300, timeEstimate: "1 month" },
                { level: 7, name: "Socialite", icon: "fas fa-users", jCoinReward: 350, timeEstimate: "1 month" },
                { level: 8, name: "Networker", icon: "fas fa-share-alt", jCoinReward: 400, timeEstimate: "1 month" },
                { level: 9, name: "Influencer", icon: "fas fa-star", jCoinReward: 450, timeEstimate: "1.5 months" },
                { level: 10, name: "Trendsetter", icon: "fas fa-fire", jCoinReward: 500, timeEstimate: "1.5 months" },
                { level: 11, name: "Innovator", icon: "fas fa-lightbulb", jCoinReward: 550, timeEstimate: "2 months" },
                { level: 12, name: "Creator", icon: "fas fa-paint-brush", jCoinReward: 600, timeEstimate: "2 months" },
                { level: 13, name: "Visionary", icon: "fas fa-eye", jCoinReward: 650, timeEstimate: "2 months" },
                { level: 14, name: "Architect", icon: "fas fa-building", jCoinReward: 700, timeEstimate: "2.5 months" },
                { level: 15, name: "Maestro", icon: "fas fa-music", jCoinReward: 750, timeEstimate: "2.5 months" },
                { level: 16, name: "Strategist", icon: "fas fa-chess", jCoinReward: 800, timeEstimate: "3 months" },
                { level: 17, name: "Guardian", icon: "fas fa-shield-alt", jCoinReward: 850, timeEstimate: "3 months" },
                { level: 18, name: "Champion", icon: "fas fa-trophy", jCoinReward: 900, timeEstimate: "3 months" },
                { level: 19, name: "Hero", icon: "fas fa-mask", jCoinReward: 950, timeEstimate: "3.5 months" },
                { level: 20, name: "Legend", icon: "fas fa-dragon", jCoinReward: 1000, timeEstimate: "3.5 months" },
                { level: 21, name: "Mythic", icon: "fas fa-meteor", jCoinReward: 1050, timeEstimate: "4 months" },
                { level: 22, name: "Celestial", icon: "fas fa-galaxy", jCoinReward: 1100, timeEstimate: "4 months" },
                { level: 23, name: "Divine", icon: "fas fa-hand-sparkles", jCoinReward: 1150, timeEstimate: "4.5 months" },
                { level: 24, name: "Transcendent", icon: "fas fa-infinity", jCoinReward: 1200, timeEstimate: "4.5 months" },
                { level: 25, name: "Cosmic Being", icon: "fas fa-atom", jCoinReward: 1250, timeEstimate: "5 months" },
                { level: 26, name: "Universal Traveler", icon: "fas fa-globe-americas", jCoinReward: 1300, timeEstimate: "5 months" },
                { level: 27, name: "Stellar Navigator", icon: "fas fa-space-shuttle", jCoinReward: 1350, timeEstimate: "5.5 months" },
                { level: 28, name: "Galactic Conqueror", icon: "fas fa-rocket", jCoinReward: 1400, timeEstimate: "5.5 months" },
                { level: 29, name: "Dimensional Shifter", icon: "fas fa-cube", jCoinReward: 1450, timeEstimate: "6 months" },
                { level: 30, name: "Omni-Presence", icon: "fas fa-brain", jCoinReward: 1500, timeEstimate: "6 months" },
            ];

            let xpToNextLevel;
            let name;
            let icon;
            let jCoinReward;
            let timeEstimate;

            if (level < 1) level = 1;

            // XP Calculation Logic - Designed for "harder" progression
            // This defines how much XP is needed to reach the next level.
            if (level === 1) {
                xpToNextLevel = 500;
            } else if (level <= 5) {
                xpToNextLevel = 500 + (level - 1) * 250;
            } else if (level <= 10) {
                xpToNextLevel = (500 + 4 * 250) + (level - 5) * 500;
            } else if (level <= 20) {
                xpToNextLevel = ((500 + 4 * 250) + (10 - 5) * 500) + (level - 10) * 1000;
            } else if (level <= 50) {
                xpToNextLevel = (((500 + 4 * 250) + (10 - 5) * 500) + (20 - 10) * 1000) + (level - 20) * 2000;
            } else if (level <= 100) {
                xpToNextLevel = ((((500 + 4 * 250) + (10 - 5) * 500) + (20 - 10) * 2000) + (50 - 20) * 2000) + (level - 50) * 5000;
            } else if (level <= 500) {
                xpToNextLevel = (((((500 + 4 * 250) + (10 - 5) * 500) + (20 - 10) * 1000) + (50 - 20) * 5000) + (100 - 50) * 5000) + (level - 100) * 10000;
            } else {
                xpToNextLevel = 10000000; // Very high XP for levels beyond 500
            }

            // Find specific level data or generate generic tier names
            const specificLevel = levelData.find(l => l.level === level);
            if (specificLevel) {
                name = specificLevel.name;
                icon = specificLevel.icon;
                jCoinReward = specificLevel.jCoinReward;
                timeEstimate = specificLevel.timeEstimate;
            } else if (level > 30 && level <= 500) {
                // Tiered naming for higher levels
                const tierNames = [
                    "Adept", "Master", "Grandmaster", "Exalted", "Ascendant",
                    "Divine", "Apex", "Cosmic", "Ethereal", "Legendary",
                    "Mythical", "Celestial", "Transcendent", "Omnipotent", "Infinite",
                    "Starlight", "Nebula", "Galaxy", "Universe", "Multiverse",
                    "Zenith", "Pinnacle", "Sovereign", "Eternal", "Absolute"
                ];
                const tierIcons = [
                    "fas fa-magic", "fas fa-crown", "fas fa-chess-king", "fas fa-gem",
                    "fas fa-star-of-life", "fas fa-hand-sparkles", "fas fa-mountain", "fas fa-atom",
                    "fas fa-cloud-sun", "fas fa-dragon", "fas fa-meteor", "fas fa-galaxy",
                    "fas fa-infinity", "fas fa-bahai", "fas fa-globe-americas", "fas fa-star",
                    "fas fa-cloud", "fas fa-atom", "fas fa-globe", "fas fa-cubes",
                    "fas fa-mountain", "fas fa-trophy", "fas fa-shield-alt", "fas fa-infinity", "fas fa-brain"
                ];

                const baseLevelForTier = 30;
                const levelsPerTierName = 10; // How many levels share the same tier name
                const levelsPerTierIcon = 10; // How many levels share the same tier icon

                const tierNameIndex = Math.floor((level - (baseLevelForTier + 1)) / levelsPerTierName);
                const tierIconIndex = Math.floor((level - (baseLevelForTier + 1)) / levelsPerTierIcon);

                name = `${tierNames[tierNameIndex % tierNames.length]} Lv. ${level}`;
                icon = tierIcons[tierIconIndex % tierIcons.length];
                jCoinReward = 1500 + (level - 30) * 100; // JCoin reward increases with level
            } else if (level > 500) {
                name = `Master Lv. ${level}`;
                icon = "fas fa-star";
                jCoinReward = 1500 + (500 - 30) * 100 + (level - 500) * 200;
            } else {
                name = `Unknown Lv. ${level}`;
                icon = "fas fa-question-circle";
                jCoinReward = 0;
            }

            return {
                level: level,
                name: name,
                icon: icon,
                jCoinReward: jCoinReward,
                xpToNextLevel: xpToNextLevel,
                timeEstimate: timeEstimate
            };
        }

        // --- NEW: Pending Activity Reward Creation Function ---
        /**
         * Creates a pending activity reward document for admin review.
         * This system allows for manual approval of XP/JCoin rewards, preventing abuse.
         * @param {string} userId - The ID of the user who performed the activity.
         * @param {string} username - The username of the user.
         * @param {string} activityType - The type of activity (e.g., 'daily_login', 'react_like', 'post_comment', 'post_creation', 'post_deletion').
         * @param {number} suggestedXpReward - The suggested XP amount to award (can be negative for deductions).
         * @param {number} suggestedJCoinReward - The suggested JCoin amount to award (can be negative for deductions).
         * @param {string} [activityId=null] - Optional: ID of the specific activity (e.g., commentId, reactionId).
         * @param {string} [postId=null] - Optional: ID of the post related to the activity.
         */
        async function createPendingActivityReward(
            userId,
            username,
            activityType,
            suggestedXpReward,
            suggestedJCoinReward,
            activityId = null,
            postId = null
        ) {
            try {
                const pendingRewardsCollectionRef = collection(db, "artifacts", appId, "public", "data", "pending_activity_rewards");

                const newRewardDocRef = await addDoc(pendingRewardsCollectionRef, {
                    userId: userId,
                    username: username,
                    activityType: activityType,
                    suggestedXpReward: suggestedXpReward,
                    suggestedJCoinReward: suggestedJCoinReward,
                    status: 'pending', // Always pending for admin review
                    timestamp: serverTimestamp(),
                    activityId: activityId, // Store activity ID if relevant
                    postId: postId // Store postId if relevant
                });

                console.log(`JCHAT_DEBUG: Pending activity reward created with ID: ${newRewardDocRef.id}`);
            } catch (error) {
                console.error("JCHAT_ERROR: Error creating pending activity reward:", error);
            }
        }


        // --- Daily Login Bonus Logic ---
        /**
         * Updates the countdown timer and state of the daily bonus button.
         * This function is called every second by an interval.
         */
        function updateDailyBonusCountdown() {
            // If user or profile data is not available, stop the timer and disable the button.
            if (!currentUserProfileData || !claimDailyBonusButton) {
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            const now = new Date();
            // Convert Firestore Timestamp to Date object if it exists.
            const lastClaimedTimestamp = currentUserProfileData.lastLoginBonusClaimed ?
                currentUserProfileData.lastLoginBonusClaimed.toDate() : null;

            // If no previous claim, enable the button immediately.
            if (!lastClaimedTimestamp) {
                claimDailyBonusButton.disabled = false;
                claimDailyBonusButton.querySelector('.button-text').textContent = "Claim Daily Bonus";
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            // Calculate the next available claim time (24 hours after last claim).
            const nextClaimTime = new Date(lastClaimedTimestamp.getTime() + (24 * 60 * 60 * 1000));
            const timeLeft = nextClaimTime.getTime() - now.getTime();

            if (timeLeft <= 0) {
                // If cooldown is over, enable the button.
                claimDailyBonusButton.disabled = false;
                claimDailyBonusButton.querySelector('.button-text').textContent = "Claim Daily Bonus";
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
            } else {
                // If still in cooldown, display the countdown.
                claimDailyBonusButton.disabled = true;
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                claimDailyBonusButton.querySelector('.button-text').textContent = `Next in ${hours}h ${minutes}m ${seconds}s`;
            }
        }

        /**
         * Checks the daily bonus status and starts/stops the countdown timer.
         * This is called on auth state change and after claiming a bonus.
         */
        async function checkAndStartDailyBonusTimer() {
            // Disable button and clear timer if not authenticated or profile not loaded.
            if (!currentUser || !currentUserProfileData) {
                if (claimDailyBonusButton) {
                    claimDailyBonusButton.disabled = true;
                    claimDailyBonusButton.querySelector('.button-text').textContent = "Login to Claim Bonus";
                }
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            // Perform an initial update to set the correct state immediately.
            updateDailyBonusCountdown();

            // Clear any existing interval before setting a new one to prevent duplicates.
            if (dailyBonusCountdownInterval) {
                clearInterval(dailyBonusCountdownInterval);
            }

            // Start the interval only if the button is currently disabled (meaning there's an active cooldown).
            if (claimDailyBonusButton && claimDailyBonusButton.disabled) {
                dailyBonusCountdownInterval = setInterval(updateDailyBonusCountdown, 1000); // Update every second
            }
        }


        /**
         * Handles the click event for claiming the daily bonus.
         * Checks cooldown, updates Firestore, and creates a pending reward.
         */
        async function handleClaimDailyBonusClick() {
            // Pre-checks for authentication and profile data.
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("Please log in to claim daily bonus.", 'error');
                return;
            }

            const now = new Date();
            const lastClaimedTimestamp = currentUserProfileData.lastLoginBonusClaimed ?
                currentUserProfileData.lastLoginBonusClaimed.toDate() : null;

            // Check if the bonus has already been claimed within the last 24 hours.
            if (lastClaimedTimestamp) {
                const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                if (lastClaimedTimestamp > twentyFourHoursAgo) {
                    showMessageBox("Daily bonus already claimed today. Check back tomorrow!", 'info');
                    return;
                }
            }

            // Show loading state for the button and message box.
            toggleButtonLoading(claimDailyBonusButton, true);
            showMessageBox("Claiming daily bonus...", 'loading', true);

            try {
                const userProfileDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "profiles", "user_profile");

                // Update the lastLoginBonusClaimed timestamp in the user's private profile.
                await updateDoc(userProfileDocRef, {
                    lastLoginBonusClaimed: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });

                // Create a pending reward for admin review instead of directly awarding.
                await createPendingActivityReward(
                    currentUser.uid,
                    currentUserProfileData.username,
                    'daily_login',
                    10, // Suggested XP reward for daily login
                    3  // Suggested JCoin reward for daily login
                );

                showMessageBox(`Daily bonus claimed! 10 XP and 3 JCoins are pending admin review.`, 'success');
                playNotificationSound('success');

                // Update local profile data immediately for UI consistency (especially for the timer).
                currentUserProfileData.lastLoginBonusClaimed = { toDate: () => new Date() };
                checkAndStartDailyBonusTimer(); // Re-evaluate status and start/stop timer.
            } catch (error) {
                console.error("JCHAT_ERROR: Error claiming daily bonus:", error);
                showMessageBox(`Failed to claim bonus: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(claimDailyBonusButton, false); // Revert button loading state.
            }
        }

        // --- Tone.js Synths for Notification Sounds ---
        // Initialize various synths for different notification types.
        const successSynth = new Tone.Synth().toDestination();
        const errorSynth = new Tone.Synth().toDestination();
        const infoSynth = new Tone.Synth().toDestination();
        const ringingSynth = new Tone.Synth().toDestination(); // For incoming call ring

        // Configure basic sound properties for each synth.
        successSynth.oscillator.type = "sine";
        successSynth.envelope.attack = 0.01;
        successSynth.envelope.decay = 0.2;
        successSynth.envelope.sustain = 0.0;
        successSynth.envelope.release = 0.5;

        errorSynth.oscillator.type = "sawtooth";
        errorSynth.envelope.attack = 0.01;
        errorSynth.envelope.decay = 0.3;
        errorSynth.envelope.sustain = 0.0;
        errorSynth.envelope.release = 0.5;

        infoSynth.oscillator.type = "triangle";
        infoSynth.envelope.attack = 0.01;
        infoSynth.envelope.decay = 0.1;
        infoSynth.envelope.sustain = 0.0;
        infoSynth.envelope.release = 0.3;

        // Ringing sound (similar to a phone ring) pattern setup.
        ringingSynth.oscillator.type = "square";
        ringingSynth.envelope.attack = 0.01;
        ringingSynth.envelope.decay = 0.6;
        ringingSynth.envelope.sustain = 0.0;
        ringingSynth.envelope.release = 0.8;
        const ringingPattern = new Tone.Pattern(function(time, note){
            ringingSynth.triggerAttackRelease(note, "8n", time);
        }, ["C5", "C5", "C5", "C5"]).start(0);
        ringingPattern.interval = "1s"; // Adjust interval for ringing pattern.
        ringingPattern.humanize = true;
        ringingPattern.playbackRate = 1;
        ringingPattern.loop = true;
        ringingPattern.autostart = false; // Will be started manually.

        /**
         * Plays a notification sound based on type.
         * @param {string} type - 'success', 'error', or 'info'.
         */
        function playNotificationSound(type) {
            Tone.start(); // Ensure audio context is started.
            if (type === 'success') {
                successSynth.triggerAttackRelease("C5", "8n");
            } else if (type === 'error') {
                errorSynth.triggerAttackRelease("C3", "8n");
            } else if (type === 'info') {
                infoSynth.triggerAttackRelease("E4", "16n");
            }
        }

        /**
         * Starts the ringing sound for incoming calls.
         */
        function startRingingSound() {
            Tone.start();
            ringingPattern.start();
        }

        /**
         * Stops the ringing sound.
         */
        function stopRingingSound() {
            ringingPattern.stop();
        }

        // --- Utility Functions ---
        /**
         * Displays a custom message box with a given message, type, and persistence.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'info', 'warning', or 'loading'.
         * @param {boolean} isPersistent - If true, the message box will not auto-hide.
         */
        function showMessageBox(message, type, isPersistent = false) {
            if (!messageBox) {
                console.error("JCHAT_ERROR: messageBox element not found.");
                return;
            }
            // Clear any existing auto-hide timeout.
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }

            // Set inner HTML with icon and text elements.
            messageBox.innerHTML = `<i id="messageBoxIcon"></i><span id="messageBoxText"></span>`;
            const messageBoxIcon = document.getElementById('messageBoxIcon');
            const messageBoxText = document.getElementById('messageBoxText');

            messageBoxText.textContent = message;
            // Apply CSS classes for styling and visibility.
            messageBox.className = 'message-box show ' + type;

            // Set icon based on message type.
            if (messageBoxIcon) {
                messageBoxIcon.className = ''; // Clear existing classes.
                if (type === 'success') {
                    messageBoxIcon.classList.add('fas', 'fa-check-circle');
                } else if (type === 'error') {
                    messageBoxIcon.classList.add('fas', 'fa-times-circle');
                } else if (type === 'info') {
                    messageBoxIcon.classList.add('fas', 'fa-info-circle');
                } else if (type === 'warning') {
                    messageBoxIcon.classList.add('fas', 'fa-exclamation-triangle');
                } else if (type === 'loading') {
                    messageBoxIcon.classList.add('fas', 'fa-spinner', 'fa-spin'); // Spinner for loading.
                }
            }

            // Apply pulsing animation for loading messages.
            if (type === 'loading') {
                messageBox.classList.add('loading-pulse');
            } else {
                messageBox.classList.remove('loading-pulse');
            }

            // Make the message box visible.
            messageBox.style.display = 'flex';
            messageBox.style.opacity = '1';

            // Set auto-hide timeout if not persistent.
            if (!isPersistent) {
                messageBox.timeoutId = setTimeout(() => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', function handler() {
                        messageBox.style.display = 'none';
                        messageBox.removeEventListener('transitionend', handler);
                        messageBox.classList.remove('loading-pulse');
                    }, { once: true });
                }, 3000);
            }
        }

        /**
         * Displays a confirmation modal and returns a Promise that resolves to true if confirmed, false otherwise.
         * @param {string} title - The title of the confirmation modal.
         * @param {string} message - The message to display in the confirmation modal.
         * @returns {Promise<boolean>}
         */
        function showConfirmationModal(title, message) {
            return new Promise((resolve) => {
                // Check if all necessary modal elements exist.
                if (!confirmationTitle || !confirmationMessage || !confirmationModal || !confirmProceedButton || !confirmCancelButton) {
                    console.error("JCHAT_ERROR: Confirmation modal elements not found.");
                    resolve(false); // Resolve false if elements are missing.
                    return;
                }

                confirmationTitle.textContent = title;
                confirmationMessage.textContent = message;
                confirmationModal.classList.add('active'); // Show the modal.

                // Event handler for confirming the action.
                const handleConfirm = () => {
                    confirmationModal.classList.remove('active'); // Hide modal.
                    // Remove event listeners to prevent memory leaks and duplicate calls.
                    confirmProceedButton.removeEventListener('click', handleConfirm);
                    confirmCancelButton.removeEventListener('click', handleCancel);
                    resolve(true); // Resolve with true (confirmed).
                };

                // Event handler for canceling the action.
                const handleCancel = () => {
                    confirmationModal.classList.remove('active'); // Hide modal.
                    // Remove event listeners.
                    confirmProceedButton.removeEventListener('click', handleConfirm);
                    confirmCancelButton.removeEventListener('click', handleCancel);
                    resolve(false); // Resolve with false (canceled).
                };

                // Attach event listeners to buttons.
                confirmProceedButton.addEventListener('click', handleConfirm);
                confirmCancelButton.addEventListener('click', handleCancel);

                // Close modal if clicking outside the content area.
                confirmationModal.addEventListener('click', function outsideClickListener(event) {
                    if (event.target === confirmationModal) {
                        handleCancel(); // Treat outside click as a cancel.
                        confirmationModal.removeEventListener('click', outsideClickListener);
                    }
                });
            });
        }

        /**
         * Generates a Cloudinary image URL with specified transformations.
         * Handles both public IDs and existing Cloudinary URLs.
         * @param {string} urlOrPublicId - The Cloudinary public ID or an existing Cloudinary URL.
         * @param {string} transformations - Cloudinary transformation string (e.g., "w_auto,f_auto,q_auto").
         * @returns {string|null} The transformed Cloudinary URL or null if input is invalid.
         */
        function getCloudinaryImageUrl(urlOrPublicId, transformations = "w_auto,f_auto,q_auto") {
            if (!urlOrPublicId) return null;
            if (urlOrPublicId.startsWith('http://') || urlOrPublicId.startsWith('https://')) {
                // If it's already a full URL, ensure it's a Cloudinary URL before transforming.
                if (urlOrPublicId.includes('res.cloudinary.com')) {
                    // This is a basic attempt to insert transformations into an existing Cloudinary URL.
                    // More robust parsing might be needed for complex existing URLs.
                    const parts = urlOrPublicId.split('/upload/');
                    if (parts.length === 2) {
                        // Check if transformations are already present to avoid duplication.
                        const currentTransformations = parts[1].split('/')[0];
                        if (currentTransformations.includes(transformations.split(',')[0])) {
                            return urlOrPublicId; // Assume already transformed.
                        }
                        return `${parts[0]}/upload/${transformations}/${parts[1]}`;
                    }
                }
                return urlOrPublicId; // Return as is if not a recognizable Cloudinary URL or already transformed.
            }
            // Construct URL from public ID.
            return `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/image/upload/${transformations}/${urlOrPublicId}`;
        }

        /**
         * Displays a profile picture or a placeholder icon based on the provided profilePicId.
         * @param {HTMLImageElement} imgElement - The <img> element to display the picture.
         * @param {HTMLElement} iconElement - The <i> element to display the placeholder icon.
         * @param {string|null} profilePicId - The Cloudinary public ID of the profile picture, or null.
         * @param {string} usernameInitial - The first letter of the username for the placeholder.
         * @param {string} transformations - Cloudinary transformation string for the image.
         */
        function displayProfilePicture(imgElement, iconElement, profilePicId, usernameInitial, transformations) {
            if (imgElement && iconElement) {
                if (profilePicId) {
                    const imageUrl = getCloudinaryImageUrl(profilePicId, transformations);
                    imgElement.src = imageUrl;
                    imgElement.style.display = 'block'; // Show image.
                    iconElement.style.display = 'none'; // Hide icon.
                    // Fallback for image loading errors.
                    imgElement.onerror = () => {
                        console.error(`Failed to load profile picture: ${profilePicId}. Using placeholder.`);
                        imgElement.src = `https://placehold.co/120x120/CCCCCC/000000?text=${usernameInitial}`;
                        imgElement.style.display = 'block';
                        iconElement.style.display = 'none';
                    };
                } else {
                    imgElement.src = '';
                    imgElement.style.display = 'none'; // Hide image.
                    iconElement.style.display = 'block'; // Show icon.
                }
            }
        }

        /**
         * Resizes an image file using a canvas and returns it as a Blob.
         * @param {File} file - The image file to resize.
         * @param {number} maxWidth - Maximum width for the resized image.
         * @param {number} maxHeight - Maximum height for the resized image.
         * @param {number} quality - JPEG quality (0.0 to 1.0).
         * @returns {Promise<Blob>} A Promise that resolves with the resized image Blob.
         */
        function resizeImage(file, maxWidth = 800, maxHeight = 800, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        // Calculate new dimensions to fit within maxWidth/maxHeight while maintaining aspect ratio.
                        if (width > maxWidth) {
                            height = height * (maxWidth / width);
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = width * (maxHeight / height);
                            height = maxHeight;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert canvas content to a Blob.
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas to Blob conversion failed: Resulting blob was null.'));
                            }
                        }, 'image/jpeg', quality);
                    };
                    img.onerror = (error) => {
                        console.error("Image element loading error:", error);
                        reject(new Error(`Image loading failed: ${error.message || 'Unknown image loading error.'}`));
                    };
                    img.src = event.target.result;
                };
                reader.onerror = (error) => {
                    console.error("FileReader error during readAsDataURL:", error);
                    reject(new Error(`FileReader error: ${error.target.error ? error.target.error.message : 'Unknown error reading file.'}`));
                }
                try {
                    reader.readAsDataURL(file);
                } catch (e) {
                    console.error("Error calling readAsDataURL:", e);
                    reject(new Error(`Failed to read file data: ${e.message}`));
                }
            });
        }

        /**
         * Uploads a media file (image or video) to Cloudinary.
         * @param {File|Blob} file - The file to upload.
         * @returns {Promise<string|null>} The secure URL of the uploaded media, or null if upload fails.
         */
        async function uploadMediaToCloudinary(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', cloudinaryConfig.uploadPreset);

                const resourceType = file.type.startsWith('image/') ? 'image' : 'video';

                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/${resourceType}/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Cloudinary upload error:", errorData);
                    throw new Error(`Cloudinary upload failed: ${errorData.error.message || response.statusText}`);
                }

                const data = await response.json();
                return data.secure_url;
            } catch (error) {
                console.error("Error uploading to Cloudinary:", error);
                return null;
            }
        }

        /**
         * Applies the selected theme to the document body.
         * @param {string} themeName - The CSS class name for the theme (e.g., 'theme-dark-mode').
         */
        function applyTheme(themeName) {
            document.body.classList.remove(...themes); // Remove all existing theme classes.
            document.body.classList.add(themeName); // Add the new theme class.
            localStorage.setItem('jchat-theme', themeName); // Save theme preference to local storage.
        }

        /**
         * Toggles the loading state of a button, showing/hiding a spinner.
         * @param {HTMLButtonElement} buttonElement - The button element to toggle.
         * @param {boolean} isLoading - True to show loading state, false to hide.
         */
        function toggleButtonLoading(buttonElement, isLoading) {
            if (!buttonElement) return;
            const loader = buttonElement.querySelector('.button-loader');
            const text = buttonElement.querySelector('.button-text');

            if (isLoading) {
                buttonElement.disabled = true; // Disable button during loading.
                buttonElement.classList.add('loading');
                if (loader) loader.classList.add('active');
                if (text) text.style.display = 'none';
            } else {
                buttonElement.disabled = false; // Re-enable button.
                buttonElement.classList.remove('loading');
                if (loader) loader.classList.remove('active');
                if (text) text.style.display = 'block';
            }
        }

        /**
         * Enables or disables all interactive elements on the page based on a global state.
         * This is primarily used for maintenance mode or initial loading.
         * @param {boolean} enable - True to enable, false to disable.
         * @param {boolean} isCurrentUserAdmin - True if the current user is an admin (allows bypass for some features).
         */
        function toggleInteractiveElements(enable, isCurrentUserAdmin = false) {
            console.log(`JCHAT_DEBUG: toggleInteractiveElements called with enable: ${enable}, isAdmin: ${isCurrentUserAdmin}`);

            // If enabling, and it's an admin, we want to ensure everything is truly enabled.
            // Otherwise, apply the 'enable' state universally.
            const finalEnableState = enable || isCurrentUserAdmin; // If enable is true, or if it's an admin, enable.

            // Main content buttons/inputs
            if (sharePostInspirationButton) sharePostInspirationButton.disabled = !finalEnableState;
            if (customizeInspirationButton) customizeInspirationButton.disabled = !finalEnableState;
            if (claimDailyBonusButton) claimDailyBonusButton.disabled = !finalEnableState;
            if (postContentInput) postContentInput.disabled = !finalEnableState;
            if (postMediaUpload) postMediaUpload.disabled = !finalEnableState;
            if (createPostButton) createPostButton.disabled = !finalEnableState;

            // Dynamically created elements (posts, comments) - these will be refined by applySystemSettings later.
            // These are selected globally and then their disabled state is set.
            document.querySelectorAll('.comment-input').forEach(input => {
                input.disabled = !finalEnableState;
            });
            document.querySelectorAll('.submit-comment-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.react-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.comment-toggle-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.post-options-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.edit-post-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            // The delete-post-button is removed from here as per user request.
            document.querySelectorAll('.share-post-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.delete-comment-button').forEach(button => {
                button.disabled = !finalEnableState;
            });

            // Modals (buttons within modals)
            if (cancelCustomizeButton) cancelCustomizeButton.disabled = !finalEnableState;
            if (saveCustomizeButton) saveCustomizeButton.disabled = !finalEnableState;
            if (editPostContentInput) editPostContentInput.disabled = !finalEnableState;
            if (editPostMediaUpload) editPostMediaUpload.disabled = !finalEnableState;
            if (removeEditMediaButton) removeEditMediaButton.disabled = !finalEnableState;
            if (cancelEditPostButton) cancelEditPostButton.disabled = !finalEnableState;
            if (saveEditedPostButton) saveEditedPostButton.disabled = !finalEnableState;
            if (confirmCancelButton) confirmCancelButton.disabled = !finalEnableState;
            if (confirmProceedButton) confirmProceedButton.disabled = !finalEnableState;

            // Sidebar links (pointer-events and opacity, as they are not 'disabled' attributes).
            // These will be further refined by applySystemSettings for specific toggles.
            if (chatLink) {
                chatLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                chatLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (findFriendsLink) {
                findFriendsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                findFriendsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (friendsLink) {
                friendsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                friendsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (groupsLink) {
                groupsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                groupsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (jcoinShopLink) {
                jcoinShopLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                jcoinShopLink.style.opacity = finalEnableState ? '1' : '0.5';
            }

            // Guide link - also controlled by global enable state.
            const guideLink = document.querySelector('.sidebar-nav-item[href="/guide.html"]');
            if (guideLink) {
                guideLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                guideLink.style.opacity = finalEnableState ? '1' : '0.5';
            }

            console.log(`JCHAT_DEBUG: Finished toggling interactive elements. Post content input disabled state: ${postContentInput ? postContentInput.disabled : 'N/A (element not found)'}`);
        }

        /**
         * Handles user logout, signs out from Firebase, updates inCall status, and redirects.
         */
        async function handleLogout() {
            if (!isAuthReady || !currentUser) {
                showMessageBox("Not ready to log out or no user found.", 'info');
                return;
            }

            try {
                // Set user's inCall status to false in public profile on logout.
                if (currentUser && currentUserProfileData) {
                    const userPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                    await updateDoc(userPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on logout:", e));
                }

                // End any active WebRTC call before logging out.
                if (callState !== 'idle') {
                    await endCall(false); // End call without updating Firestore status to avoid conflicts during logout.
                }

                await signOut(auth); // Sign out from Firebase.
                showMessageBox("Logged out successfully! ", 'success');
                // Redirect to login page after a short delay.
                setTimeout(() => {
                    window.location.href = '/login.html';
                }, 1500);

            } catch (error) {
                console.error("JCHAT_ERROR: Error logging out:", error);
                showMessageBox(`Failed to log out: ${error.message}. Please try again.`, 'error');
            }
        }

        /**
         * Updates the profile picture URL for all posts authored by a specific user.
         * This ensures consistency across the feed when a user changes their profile picture.
         * @param {string} userId - The ID of the user whose posts need updating.
         * @param {string} newProfilePicId - The new Cloudinary public ID for the profile picture.
         */
        async function updatePostsWithNewProfilePic(userId, newProfilePicId) {
            if (!isAuthReady) return;
            try {
                const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
                const q = query(postsCollectionRef, where("authorId", "==", userId));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const batch = writeBatch(db); // Use a batch write for efficiency.
                    querySnapshot.forEach(docSnap => {
                        const postRef = doc(db, "artifacts", appId, "public", "data", "posts", docSnap.id);
                        batch.update(postRef, { profilePhoto: newProfilePicId });
                    });
                    await batch.commit(); // Commit all batched updates.
                    console.log(`JCHAT_DEBUG: Updated profile picture for ${querySnapshot.size} posts by user ${userId}.`);
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating posts with new profile picture:", error);
            }
        }

        /**
         * Fetches and displays the current user's profile information in the header.
         * Creates a new profile if one doesn't exist.
         * Also syncs public profile data and updates posts if profile pic changes.
         * @param {object} user - The Firebase user object.
         */
        async function fetchAndDisplayHeaderProfile(user) {
            console.log("JCHAT_DEBUG: Entering fetchAndDisplayHeaderProfile for user:", user.uid);
            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", user.uid, "profiles", "user_profile");
                const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);

                const privateDocSnap = await getDoc(privateProfileDocRef);
                let profileData = null;
                let oldProfilePicId = null;

                if (privateDocSnap.exists()) {
                    profileData = privateDocSnap.data();
                    oldProfilePicId = profileData.profilePicId;
                    console.log("JCHAT_DEBUG: Fetched existing private profile data:", profileData);
                } else {
                    // Create a new default profile if one doesn't exist.
                    profileData = {
                        username: user.displayName || `User_${user.uid.substring(0, 8)}`,
                        email: user.email || "",
                        profilePicId: user.photoURL || null,
                        bio: "",
                        location: "",
                        friendsCount: 0,
                        followersCount: 0,
                        followingCount: 0,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp(),
                        inspirationType: "motivational",
                        visibility: {
                            displayName: true, profilePic: true, bio: false, location: false,
                            emailPublic: false, allowFriendRequests: true, allowMessages: true,
                        },
                        totalPosts: 0,
                        jCoins: 0, // Ensure jCoins is initialized
                        gas: 0, // Ensure gas is initialized
                        level: 1, // Ensure level is initialized
                        currentXp: 0, // Ensure currentXp is initialized
                        xpToNextLevel: getLevelInfo(1).xpToNextLevel, // Ensure xpToNextLevel is initialized
                        lastLoginBonusClaimed: null, // Ensure lastLoginBonusClaimed is initialized
                        inCall: false, // Ensure inCall is initialized
                    };
                    await setDoc(privateProfileDocRef, profileData);
                    console.log("JCHAT_DEBUG: Created new private profile data:", profileData);
                }

                // Ensure new fields are present if they were added after initial profile creation (for existing users).
                const updates = {};
                if (profileData.gas === undefined) updates.gas = 0;
                if (profileData.level === undefined) updates.level = 1;
                if (profileData.currentXp === undefined) updates.currentXp = 0;
                if (profileData.xpToNextLevel === undefined || profileData.xpToNextLevel !== getLevelInfo(profileData.level || 1).xpToNextLevel) {
                     updates.xpToNextLevel = getLevelInfo(profileData.level || 1).xpToNextLevel;
                }
                if (profileData.lastLoginBonusClaimed === undefined) updates.lastLoginBonusClaimed = null;
                if (profileData.jCoins === undefined) updates.jCoins = 0; // Ensure jCoins is initialized
                if (profileData.inCall === undefined) updates.inCall = false; // Ensure inCall is initialized

                if (Object.keys(updates).length > 0) {
                    await updateDoc(privateProfileDocRef, updates);
                    const updatedSnap = await getDoc(privateProfileDocRef);
                    profileData = updatedSnap.data(); // Get the latest data after update.
                    console.log("JCHAT_DEBUG: Updated private profile with new fields:", updates);
                }

                currentUserProfileData = profileData; // Store the fetched/updated profile data globally.

                // For public profile, only include genuinely public fields and handle createdAt.
                const publicProfileUpdates = {
                    username: profileData.username,
                    profilePicId: profileData.profilePicId,
                    userId: user.uid,
                    totalPosts: profileData.totalPosts, // Ensure totalPosts is synced.
                    visibility: profileData.visibility, // Ensure visibility is synced.
                    updatedAt: serverTimestamp(),
                    inCall: profileData.inCall, // Sync inCall status to public profile.
                };
                // Only explicitly set createdAt if the public profile document does NOT exist.
                const publicDocSnap = await getDoc(publicProfileDocRef);
                if (!publicDocSnap.exists()) {
                    publicProfileUpdates.createdAt = serverTimestamp();
                }
                await setDoc(publicProfileDocRef, publicProfileUpdates, { merge: true }); // Use merge to avoid overwriting.
                console.log("JCHAT_DEBUG: Updated public profile summary:", publicProfileUpdates);


                const usernameInitial = (profileData.username || "J").charAt(0).toUpperCase();
                // Update header UI for profile picture and display name.
                if (headerProfilePic && headerAvatarIcon && headerDisplayName) {
                    displayProfilePicture(headerProfilePic, headerAvatarIcon, profileData?.profilePicId, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                    headerDisplayName.textContent = profileData.username || "JCHAT User";
                }

                // Ensure profile link is correct.
                if (profileLink) profileLink.href = `/profile.html?userId=${user.uid}`;

                // If profile picture has changed, update all posts by this user.
                if (oldProfilePicId !== profileData.profilePicId) {
                    await updatePostsWithNewProfilePic(user.uid, profileData.profilePicId);
                }

                // Start displaying daily inspiration based on user's preference.
                startInspirationDisplay(currentUserProfileData.inspirationType || "motivational");
                await fetchNotificationCount(user.uid); // Fetch unread notification count.

                // Display admin icon if the current user is the admin.
                if (adminIconLink) {
                    if (user.uid === ADMIN_UID) {
                        adminIconLink.style.display = 'block';
                        console.log("JCHAT_DEBUG: Admin icon displayed.");
                    } else {
                        adminIconLink.style.display = 'none';
                        console.log("JCHAT_DEBUG: Admin icon hidden.");
                    }
                }

                console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile completed successfully.");

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching or creating profile for header:", error);
                // Fallback UI update in case of error.
                const usernameInitial = (user.displayName || "J").charAt(0).toUpperCase();
                if (headerProfilePic && headerAvatarIcon && headerDisplayName) {
                    displayProfilePicture(headerProfilePic, headerAvatarIcon, user.photoURL, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                    headerDisplayName.textContent = user.displayName || "JCHAT User";
                }
                showMessageBox(`Error loading header profile: ${error.message}`, 'error');

                console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile failed. Interactive elements might still be enabled if auth succeeded.");
            }
        }

        /**
         * Fetches the count of unread notifications for the current user.
         * @param {string} userId - The ID of the current user.
         */
        async function fetchNotificationCount(userId) {
            if (!isAuthReady) return;
            try {
                const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                const q = query(notificationsCollectionRef, where("read", "==", false));
                const querySnapshot = await getDocs(q);
                const unreadCount = querySnapshot.size;

                if (notificationCountElement) {
                    if (unreadCount > 0) {
                        notificationCountElement.textContent = unreadCount;
                        notificationCountElement.style.display = 'flex'; // Show badge.
                    } else {
                        notificationCountElement.style.display = 'none'; // Hide badge.
                    }
                }
            }
            catch (error) {
                console.error("JCHAT_ERROR: Error fetching notification count:", error);
                if (notificationCountElement) notificationCountElement.style.display = 'none';
            }
        }

        // --- Inspiration Quotes Display (No LLM) ---
        /**
         * Retrieves a random quote from the local inspirationalQuotes data based on type.
         * @param {string} type - The category of inspiration (e.g., "motivational").
         * @returns {object} A quote object with 'quote' and 'author' properties.
         */
        function getRandomQuote(type = "motivational") {
            const quotesOfType = inspirationalQuotes[type] || inspirationalQuotes.motivational; // Fallback to motivational.
            const randomIndex = Math.floor(Math.random() * quotesOfType.length);
            return quotesOfType[randomIndex];
        }

        /**
         * Displays a randomly selected inspiration quote on the page.
         */
        async function displayInspiration() {
            const currentType = currentUserProfileData?.inspirationType || "motivational";
            const quoteData = getRandomQuote(currentType); // Directly use local quotes.
            if (inspirationQuoteElement) inspirationQuoteElement.textContent = `"${quoteData.quote}"`;
            if (inspirationAuthorElement) inspirationAuthorElement.textContent = `- ${quoteData.author}`;
        }

        /**
         * Starts the interval for displaying new inspiration quotes periodically.
         * @param {string} type - The inspiration type to display.
         */
        function startInspirationDisplay(type) {
            if (inspirationIntervalId) {
                clearInterval(inspirationIntervalId); // Clear any existing interval.
            }
            if (currentUserProfileData) {
                currentUserProfileData.inspirationType = type; // Update local profile data.
            }
            displayInspiration(); // Display initial quote immediately.
            inspirationIntervalId = setInterval(displayInspiration, 3 * 60 * 1000); // Refresh every 3 minutes.
        }

        /**
         * Opens the customization modal for daily inspiration.
         */
        function openCustomizeModal() {
            if (!isAuthReady) {
                showMessageBox("Please log in to customize inspiration.", 'error');
                return;
            }
            const currentType = currentUserProfileData?.inspirationType || "motivational";
            // Set the radio button corresponding to the current inspiration type.
            inspirationTypeRadios.forEach(radio => {
                radio.checked = (radio.value === currentType);
            });
            if (customizeInspirationModal) customizeInspirationModal.classList.add('active'); // Show modal.
        }

        /**
         * Closes the customization modal.
         */
        function closeCustomizeModal() {
            if (customizeInspirationModal) customizeInspirationModal.classList.remove('active');
        }

        /**
         * Saves the selected inspiration type to Firestore.
         */
        async function saveInspirationType() {
            if (!isAuthReady || !currentUser) {
                showMessageBox("You must be logged in to save settings.", 'error');
                return;
            }

            const selectedRadio = document.querySelector('input[name="inspirationType"]:checked');
            if (!selectedRadio) {
                showMessageBox("Please select an inspiration type.", 'info');
                return;
            }
            const newType = selectedRadio.value;

            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "profiles", "user_profile");
                await updateDoc(privateProfileDocRef, {
                    inspirationType: newType,
                    updatedAt: serverTimestamp()
                });
                if (currentUserProfileData) {
                    currentUserProfileData.inspirationType = newType; // Update local state.
                }
                startInspirationDisplay(newType); // Restart inspiration display with new type.
                showMessageBox("Inspiration type saved!", 'success');
                closeCustomizeModal();
            } catch (error) {
                console.error("JCHAT_ERROR: Error saving inspiration type:", error);
                showMessageBox(`Failed to save inspiration type: ${error.message}`, 'error');
            }
        }

        // Event listener for post media upload input.
        if (postMediaUpload) {
            postMediaUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                currentMediaFile = file; // Store the selected file.
                // Reset previews.
                if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                if (mediaImagePreview) mediaImagePreview.src = '';
                if (mediaVideoPreview) mediaVideoPreview.src = '';

                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (file.type.startsWith('image/')) {
                            if (mediaImagePreview) {
                                mediaImagePreview.src = e.target.result;
                                mediaImagePreview.style.display = 'block';
                            }
                        } else if (file.type.startsWith('video/')) {
                            if (mediaVideoPreview) {
                                mediaVideoPreview.src = e.target.result;
                                mediaVideoPreview.style.display = 'block';
                            }
                        }
                    };
                    reader.readAsDataURL(file); // Read file as Data URL for preview.
                }
            });
        }

        /**
         * Creates a new post with content and optional media.
         * Handles media upload, Firestore transaction, and pending reward creation.
         */
        async function createNewPost() {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("Please log in to create a post.", 'error');
                return;
            }

            // Check if post creation is enabled by system settings (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post creation is currently disabled by administrators.", 'warning');
                return;
            }

            const content = postContentInput.value.trim();
            if (!content && !currentMediaFile) {
                showMessageBox("Post content or media cannot be empty.", 'info');
                return;
            }

            toggleButtonLoading(createPostButton, true); // Show loading spinner.
            showMessageBox("Creating post...", 'loading', true); // Show persistent loading message.

            let mediaUrl = null;
            let mediaType = 'text';

            try {
                if (currentMediaFile) {
                    showMessageBox('Uploading media...', 'loading', true);
                    let fileToUpload = currentMediaFile;
                    // Resize image files before upload for optimization.
                    if (currentMediaFile.type.startsWith('image/')) {
                        fileToUpload = await resizeImage(currentMediaFile);
                    }
                    mediaUrl = await uploadMediaToCloudinary(fileToUpload);
                    if (mediaUrl) {
                        mediaType = currentMediaFile.type.startsWith('image/') ? 'image' : 'video';
                        showMessageBox('Media uploaded!', 'success');
                    } else {
                        throw new Error("Failed to upload media."); // Throw error if Cloudinary upload fails.
                    }
                }

                // Poll handling
                const pollEnabled = !!document.getElementById('addPollCheckbox')?.checked;
                let poll = null;
                if (pollEnabled) {
                    const optionEls = [...document.querySelectorAll('#pollComposer .poll-option-input')];
                    const options = optionEls.map(o => o.value.trim()).filter(Boolean).slice(0,6);
                    if (options.length >= 2) {
                        poll = { options: options.map(o => ({ text:o, votes:0 })), allowMultiple:false };
                    }
                }

                const postData = {
                    authorId: currentUser.uid,
                    username: currentUserProfileData.username || "JCHAT User",
                    profilePhoto: currentUserProfileData.profilePicId || null,
                    content: content,
                    timestamp: serverTimestamp(),
                    likesCount: 0,
                    commentsCount: 0,
                    isEdited: false,
                    status: 'active',
                    reactions: { like: 0, love: 0, haha: 0 },
                    mediaUrl: mediaUrl,
                    mediaType: mediaType,
                    visibility: 'public',
                    tags: [],
                    location: {},
                    poll: poll
                };

                let postId = null; // To store the ID of the newly created post.

                // Use a Firestore transaction to ensure atomicity for post creation.
                await runTransaction(db, async (transaction) => {
                    // Note: totalPosts update is removed here as it's now handled by admin approval of pending reward.
                    const newPostRef = doc(collection(db, "artifacts", appId, "public", "data", "posts"));
                    transaction.set(newPostRef, postData);
                    postId = newPostRef.id; // Get the ID of the new post.
                });

                // Create a pending reward for post creation for admin review.
                if (postId) {
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        'post_creation',
                        20, // Suggested XP for post creation.
                        5,  // Suggested JCoins for post creation.
                        null, // No specific activityId for post creation itself.
                        postId // Link to the created post.
                    );
                }

                showMessageBox("Post created successfully! 20 XP and 5 JCoins are pending admin review.", 'success', true);
                playNotificationSound('success');
                // Clear input fields and previews after successful post creation.
                postContentInput.value = '';
                if (postMediaUpload) postMediaUpload.value = '';
                if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                if (mediaImagePreview) mediaImagePreview.src = '';
                if (mediaVideoPreview) mediaVideoPreview.src = '';
                currentMediaFile = null;

            } catch (error) {
                console.error("JCHAT_ERROR: Error creating post:", error);
                showMessageBox(`Failed to create post: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(createPostButton, false); // Hide loading spinner.
            }
        }

        /**
         * Handles user reactions (like, love, haha) to a post.
         * Uses a transaction to update reaction counts and user's reaction status.
         * Creates a pending reward for the reaction.
         * @param {string} postId - The ID of the post being reacted to.
         * @param {string} reactionType - The type of reaction ('like', 'love', 'haha').
         */
        async function handleReaction(postId, reactionType) {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("You must be logged in to react.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled by system settings (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Reactions are currently disabled by administrators.", 'warning');
                return;
            }

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
            const userReactionRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "userReactions", currentUser.uid);

            try {
                let xpReward = 0;
                let jCoinReward = 0;
                let activityType = '';

                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    const userReactionDoc = await transaction.get(userReactionRef);

                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    const postData = postDoc.data();
                    let serverReactions = postData.reactions || { like: 0, love: 0, haha: 0 };
                    let serverLikesCount = postData.likesCount || 0;
                    let serverUserPreviousReaction = userReactionDoc.exists() ? userReactionDoc.data().type : null;

                    if (serverUserPreviousReaction === reactionType) {
                        // User is un-reacting: decrement count, delete user reaction document.
                        serverReactions[reactionType] = Math.max(0, serverReactions[reactionType] - 1);
                        if (reactionType === 'like') serverLikesCount = Math.max(0, serverLikesCount - 1);
                        transaction.delete(userReactionRef);
                        activityType = `unreact_${reactionType}`;
                        xpReward = -3; // Suggested XP deduction for un-reacting.
                        jCoinReward = -2; // Suggested JCoin deduction for un-reacting.
                    } else {
                        // User is reacting or changing reaction:
                        // If there was a previous reaction, decrement its count.
                        if (serverUserPreviousReaction) {
                            serverReactions[serverUserPreviousReaction] = Math.max(0, serverReactions[serverUserPreviousReaction] - 1);
                            if (serverUserPreviousReaction === 'like') serverLikesCount = Math.max(0, serverLikesCount - 1);
                        }
                        // Increment the new reaction type's count.
                        serverReactions[reactionType] = (serverReactions[reactionType] || 0) + 1;
                        if (reactionType === 'like') serverLikesCount = (serverLikesCount || 0) + 1;

                        // Set/update the user's reaction document.
                        transaction.set(userReactionRef, { type: reactionType, userId: currentUser.uid, timestamp: serverTimestamp() });
                        activityType = `react_${reactionType}`;
                        xpReward = 3; // Suggested XP for reacting.
                        jCoinReward = 2; // Suggested JCoins for reacting.
                    }

                    // Update the post document with new reaction counts.
                    transaction.update(postRef, {
                        reactions: serverReactions,
                        likesCount: serverLikesCount,
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for the reaction (or deduction for un-reaction).
                if (xpReward !== 0 || jCoinReward !== 0) {
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        activityType,
                        xpReward,
                        jCoinReward,
                        null, // No specific activityId for reaction itself.
                        postId
                    );
                }

                showMessageBox(`Reaction recorded! ${xpReward} XP and ${jCoinReward} JCoins are pending admin review.`, 'success');
                playNotificationSound('info');
            } catch (error) {
                console.error("JCHAT_ERROR: Error handling reaction (Firestore update failed):", error);
                showMessageBox(`Failed to update reaction: ${error.message}. Please refresh.`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Adds a new comment to a post.
         * Uses a transaction to update comment count on the post.
         * Creates a pending reward for the comment.
         * @param {string} postId - The ID of the post to comment on.
         * @param {string} commentText - The content of the comment.
         */
        async function addComment(postId, commentText) {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("You must be logged in to comment.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Commenting is currently disabled by administrators.", 'warning');
                return;
            }

            if (!commentText.trim()) {
                showMessageBox("Comment cannot be empty.", 'info');
                return;
            }

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
            const commentsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts", postId, "comments");

            try {
                let commentId = null;
                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    const newCommentRef = doc(commentsCollectionRef); // Create a new document reference for the comment.
                    const newComment = {
                        userId: currentUser.uid,
                        username: currentUserProfileData.username || "JCHAT User",
                        profilePhoto: currentUserProfileData.profilePicId || null,
                        content: commentText.trim(),
                        timestamp: serverTimestamp()
                    };
                    transaction.set(newCommentRef, newComment); // Set the new comment data.
                    commentId = newCommentRef.id; // Get the ID of the new comment.

                    const currentCommentsCount = postDoc.data().commentsCount || 0;
                    transaction.update(postRef, {
                        commentsCount: currentCommentsCount + 1, // Increment comments count on the post.
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for the comment for admin review.
                if (commentId) {
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        'post_comment',
                        2, // Suggested XP for commenting.
                        4,  // Suggested JCoins for commenting.
                        commentId, // Pass commentId as activityId.
                        postId
                    );
                }

                showMessageBox("Comment added! 2 XP and 4 JCoins are pending admin review.", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error adding comment:", error);
                showMessageBox(`Failed to add comment: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Deletes a comment from a post.
         * Only the comment author or an admin can delete a comment.
         * Uses a transaction to decrement comment count on the post.
         * Creates a pending reward for the deletion (negative XP/JCoins).
         * @param {string} postId - The ID of the post the comment belongs to.
         * @param {string} commentId - The ID of the comment to delete.
         * @param {string} commentAuthorId - The ID of the user who authored the comment.
         */
        async function deleteComment(postId, commentId, commentAuthorId) {
            // Check permissions: current user must be the comment author or an admin.
            if (!isAuthReady || !currentUser || (currentUser.uid !== commentAuthorId && currentUser.uid !== ADMIN_UID)) {
                showMessageBox("You can only delete your own comments unless you are an admin.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Commenting is currently disabled by administrators, so deletion is also restricted.", 'warning');
                return;
            }

            // Show confirmation modal before proceeding with deletion.
            const confirmed = await showConfirmationModal(
                "Delete Comment",
                "Are you sure you want to delete this comment? This action cannot be undone."
            );
            if (!confirmed) {
                return;
            }

            showMessageBox("Deleting comment...", 'loading', true);

            const commentRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "comments", commentId);
            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);

            try {
                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    transaction.delete(commentRef); // Delete the comment document.

                    const currentCommentsCount = postDoc.data().commentsCount || 0;
                    transaction.update(postRef, {
                        commentsCount: Math.max(0, currentCommentsCount - 1), // Decrement comments count.
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for comment deletion (negative XP/JCoins).
                await createPendingActivityReward(
                    commentAuthorId, // The user who originally posted the comment.
                    currentUserProfileData.username, // Using current user's username for logging purposes.
                    'comment_deletion',
                    -2, // Suggested XP deduction for deleting a comment.
                    -4,  // Suggested JCoin deduction for deleting a comment.
                    commentId, // Pass commentId as activityId.
                    postId
                );

                showMessageBox("Comment deleted successfully!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting comment:", error);
                showMessageBox(`Failed to delete comment: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Opens the edit post modal and populates it with existing post data.
         * @param {string} postId - The ID of the post to edit.
         * @param {string} currentContent - The current text content of the post.
         * @param {string|null} currentMediaUrl - The current media URL of the post.
         * @param {string} currentMediaType - The current media type of the post ('image', 'video', 'text').
         */
        function openEditPostModal(postId, currentContent, currentMediaUrl, currentMediaType) {
            if (!isAuthReady || !currentUser) {
                showMessageBox("You must be logged in to edit posts.", 'error');
                return;
            }
            // Check if post creation (and thus editing) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post editing is currently disabled by administrators.", 'warning');
                return;
            }

            currentEditPostId = postId;
            if (editPostContentInput) editPostContentInput.value = currentContent;
            currentEditMediaUrl = currentMediaUrl;
            currentEditMediaType = currentMediaType;
            currentEditMediaFile = null; // Clear any previously selected new media file.

            // Reset media previews and remove media button.
            if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
            if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.src = '';
            if (editMediaVideoPreview) editMediaVideoPreview.src = '';
            if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

            // Display existing media if available.
            if (currentMediaUrl) {
                if (currentMediaType === 'image') {
                    if (editMediaImagePreview) {
                        editMediaImagePreview.src = currentMediaUrl;
                        editMediaImagePreview.style.display = 'block';
                    }
                } else if (currentMediaType === 'video') {
                    if (editMediaVideoPreview) {
                        editMediaVideoPreview.src = currentMediaUrl;
                        editMediaVideoPreview.style.display = 'block';
                    }
                }
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'inline-block'; // Show remove media button.
            }

            if (editPostModal) editPostModal.classList.add('active'); // Show edit modal.
        }

        // Event listener for edit post media upload input.
        if (editPostMediaUpload) {
            editPostMediaUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                currentEditMediaFile = file; // Store the newly selected file.
                // Reset previews and hide remove media button.
                if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                if (editMediaImagePreview) editMediaImagePreview.src = '';
                if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (file.type.startsWith('image/')) {
                            if (editMediaImagePreview) {
                                editMediaImagePreview.src = e.target.result;
                                editMediaImagePreview.style.display = 'block';
                            }
                        } else if (file.type.startsWith('video/')) {
                            if (editMediaVideoPreview) {
                                editMediaVideoPreview.src = e.target.result;
                                editMediaVideoPreview.style.display = 'block';
                            }
                        }
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        // Event listener for removing media from an edited post.
        if (removeEditMediaButton) {
            removeEditMediaButton.addEventListener('click', () => {
                currentEditMediaFile = null;
                currentEditMediaUrl = null;
                currentEditMediaType = 'text';
                // Clear and hide all media related elements.
                if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                if (editMediaImagePreview) editMediaImagePreview.src = '';
                if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                if (editPostMediaUpload) editPostMediaUpload.value = ''; // Clear file input.
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
                showMessageBox("Media removed.", "info");
            });
        }

        /**
         * Saves the changes made to an edited post.
         * Handles new media upload, updates Firestore, and shows messages.
         */
        async function saveEditedPost() {
            if (!isAuthReady || !currentUser || !currentEditPostId) {
                showMessageBox("No post selected for editing.", 'error');
                return;
            }
            // Check if post creation (and thus editing) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post editing is currently disabled by administrators.", 'warning');
                return;
            }

            const newContent = editPostContentInput.value.trim();
            if (!newContent && !currentEditMediaFile && !currentEditMediaUrl) {
                showMessageBox("Post content or media cannot be empty.", 'info');
                return;
            }

            toggleButtonLoading(saveEditedPostButton, true); // Show loading spinner.
            showMessageBox("Saving changes...", 'loading', true); // Show persistent loading message.

            let finalMediaUrl = currentEditMediaUrl;
            let finalMediaType = currentEditMediaType;

            try {
                if (currentEditMediaFile) {
                    showMessageBox('Uploading new media...', 'loading', true);
                    let fileToUpload = currentEditMediaFile;
                    // Resize image files before upload.
                    if (currentEditMediaFile.type.startsWith('image/')) {
                        fileToUpload = await resizeImage(currentEditMediaFile);
                    }
                    finalMediaUrl = await uploadMediaToCloudinary(fileToUpload);
                    if (finalMediaUrl) {
                        finalMediaType = currentEditMediaFile.type.startsWith('image/') ? 'image' : 'video';
                        showMessageBox('New media uploaded!', 'success');
                    } else {
                        throw new Error("Failed to upload new media.");
                    }
                } else if (!currentEditMediaUrl && !currentEditMediaFile) {
                    // If no existing media and no new media, set to null/text.
                    finalMediaUrl = null;
                    finalMediaType = 'text';
                }

                const postRef = doc(db, "artifacts", appId, "public", "data", "posts", currentEditPostId);
                await updateDoc(postRef, {
                    content: newContent,
                    mediaUrl: finalMediaUrl,
                    mediaType: finalMediaType,
                    isEdited: true, // Mark post as edited.
                    updatedAt: serverTimestamp()
                });

                showMessageBox("Post updated successfully!", 'success');
                playNotificationSound('success');
                closeEditPostModal(); // Close the modal after successful save.
            } catch (error) {
                console.error("JCHAT_ERROR: Error saving edited post:", error);
                showMessageBox(`Failed to save changes: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(saveEditedPostButton, false); // Hide loading spinner.
            }
        }

        /**
         * Closes the edit post modal and resets its fields.
         */
        function closeEditPostModal() {
            if (editPostModal) editPostModal.classList.remove('active');
            if (editPostContentInput) editPostContentInput.value = '';
            if (editPostMediaUpload) editPostMediaUpload.value = '';
            if (mediaImagePreview) mediaImagePreview.style.display = 'none';
            if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
            if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.src = '';
            if (editMediaVideoPreview) editMediaVideoPreview.src = '';
            if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
            // Reset global state variables for editing.
            currentEditPostId = null;
            currentEditMediaFile = null;
            currentEditMediaUrl = null;
            currentEditMediaType = null;
        }

        // The deletePost function is no longer called from the UI, but it's kept here just in case it's needed elsewhere.
        /**
         * Deletes a post from Firestore.
         * Only the post author or an admin can delete a post.
         * Creates a pending reward for the deletion (negative XP/JCoins).
         * @param {string} postId - The ID of the post to delete.
         * @param {string} postAuthorId - The ID of the user who authored the post.
         */
        async function deletePost(postId, postAuthorId) {
            // Check permissions: current user must be the post author or an admin.
            if (!isAuthReady || !currentUser || (currentUser.uid !== postAuthorId && currentUser.uid !== ADMIN_UID)) {
                showMessageBox("You can only delete your own posts unless you are an admin.", 'error');
                return;
            }
            // Check if post creation (and thus deletion) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post deletion is currently disabled by administrators.", 'warning');
                return;
            }

            // Show confirmation modal before proceeding.
            const confirmed = await showConfirmationModal(
                "Delete Post",
                "Are you sure you want to delete this post? This action cannot be undone."
            );
            if (!confirmed) {
                return;
            }

            showMessageBox("Deleting post...", 'loading', true);

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);

            try {
                await runTransaction(db, async (transaction) => {
                    transaction.delete(postRef); // Delete the post document.
                });

                // Create a pending reward for post deletion (negative XP/JCoins).
                await createPendingActivityReward(
                    postAuthorId, // The user who originally posted.
                    currentUserProfileData.username, // Using current user's username for logging purposes.
                    'post_deletion',
                    -20, // Suggested XP deduction for deleting a post.
                    -5,  // Suggested JCoin deduction for deleting a post.
                    null,
                    postId
                );

                showMessageBox("Post deleted successfully!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting post:", error);
                showMessageBox(`Failed to delete post: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Renders a single post HTML element.
         * @param {object} post - The post data object from Firestore.
         * @param {string} postId - The ID of the post.
         * @returns {HTMLElement} The created post HTML element.
         */
        function renderPost(post, postId) {
            const isAuthor = currentUser && currentUser.uid === post.authorId;
            const authorInitial = (post.username || 'J').charAt(0).toUpperCase();

            const postElement = document.createElement('div');
            postElement.classList.add('post-card');
            postElement.setAttribute('data-post-id', postId);

            // Construct the inner HTML for the post card.
            postElement.innerHTML = `
                <div class="post-header">
                    <a href="/profile.html?userId=${post.authorId}" aria-label="View ${post.username || 'Anonymous'}'s Profile">
                        <div class="author-pic-wrapper">
                            ${post.profilePhoto ?
                                `<img src="${getCloudinaryImageUrl(post.profilePhoto, 'w_80,h_80,c_fill,g_face,r_max')}" alt="Author Pic" class="author-pic" onerror="this.onerror=null; this.src='https://placehold.co/80x80/CCCCCC/000000?text=${authorInitial}';">` :
                                `<i class="fas fa-user-circle author-pic-placeholder" role="img" aria-label="Author Avatar"></i>`
                            }
                        </div>
                    </a>
                    <div class="author-info">
                        <a href="/profile.html?userId=${post.authorId}" class="author-name">${post.username || 'Anonymous'}</a>
                        <p class="post-timestamp">${post.timestamp ? new Date(post.timestamp.toDate()).toLocaleString() : 'N/A'} ${post.isEdited ? '(Edited)' : ''}</p>
                    </div>
                    ${isAuthor || (currentUser && currentUser.uid === ADMIN_UID) ? `
                    <button class="post-options-button" data-post-id="${postId}" data-author-id="${post.authorId}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Post Options">
                        <i class="fas fa-ellipsis-h"></i>
                    </button>
                    <div class="post-options-dropdown" id="dropdown-${postId}">
                        <button class="edit-post-button" data-post-id="${postId}" data-content="${post.content}" data-media-url="${post.mediaUrl || ''}" data-media-type="${post.mediaType || 'text'}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) || (!isAuthor && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Edit Post">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <!-- Delete button removed as per user request -->
                        <button class="share-post-button" data-post-id="${postId}" data-content="${post.content}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Share Post">
                            <i class="fas fa-share"></i> Share
                        </button>
                    </div>
                    ` : ''}
                </div>
                <div class="post-content-text">
                    <p>${post.content}</p>
                </div>
                ${post.poll && post.poll.options ? `
                <div class="post-poll" data-post-id="${postId}">
                    ${post.poll.options.map((opt, i)=>`<button class=\"poll-vote-button\" data-post-id=\"${postId}\" data-index=\"${i}\">${opt.text}  <span class=\"poll-votes\">${opt.votes||0}</span></button>`).join('')}
                </div>` : ''}
                ${post.mediaUrl ? `
                <div class="post-media">
                    ${post.mediaType === 'image' ?
                        `<img src="${post.mediaUrl}" alt="Post Media" onerror="this.style.display='none';">` :
                        `<video src="${post.mediaUrl}" controls onerror="this.style.display='none';"></video>`
                    }
                </div>` : ''}
                <div class="post-reactions-summary">
                    <span>
                        <i class="fas fa-thumbs-up" style="color:var(--blue);"></i> <span class="like-count">${post.reactions?.like || 0}</span>
                        <i class="fas fa-heart" style="color:var(--pink);"></i> <span class="love-count">${post.reactions?.love || 0}</span>
                        <i class="fas fa-face-laugh" style="color:#ffd700;"></i> <span class="haha-count">${post.reactions?.haha || 0}</span>
                    </span>
                    <span><span class="comments-count">${post.commentsCount || 0}</span> Comments</span>
                </div>
                <div class="post-actions-row">
                    <button class="post-action-button save-post-button" data-post-id="${postId}" aria-label="Save Post">
                        <i class="fas fa-bookmark"></i> Save
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="like" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Like Post">
                        <i class="fas fa-thumbs-up"></i> Like
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="love" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Love Post">
                        <i class="fas fa-heart"></i> Love
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="haha" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Haha Post">
                        <i class="fas fa-face-laugh"></i> Haha
                    </button>
                    <button class="post-action-button comment-toggle-button" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Toggle Comments">
                        <i class="fas fa-comment"></i> Comment
                    </button>
                </div>
                <div class="comments-section" style="display:none;">
                    <div class="comments-list" id="comments-list-${postId}">
                        <p style="font-size:0.85rem; color:var(--text-light); text-align:left; margin-left:10px;" class="no-comments-message">No comments yet.</p>
                    </div>
                    <div class="comment-input-area">
                        <textarea placeholder="Write a comment..." class="comment-input" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Write a comment"></textarea>
                        <button class="submit-comment-button" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Post Comment">Post</button>
                    </div>
                </div>
            `;
            return postElement;
        }

        /**
         * Renders a single comment HTML element.
         * @param {object} comment - The comment data object from Firestore.
         * @param {string} commentId - The ID of the comment.
         * @param {string} postId - The ID of the post the comment belongs to.
         * @returns {HTMLElement} The created comment HTML element.
         */
        function renderComment(comment, commentId, postId) {
            const commentAuthorInitial = (comment.username || 'J').charAt(0).toUpperCase();
            const isCommentOwner = currentUser && currentUser.uid === comment.userId;

            const commentElement = document.createElement('div');
            commentElement.classList.add('comment-item');
            commentElement.setAttribute('data-comment-id', commentId);
            commentElement.innerHTML = `
                <a href="/profile.html?userId=${comment.userId}" aria-label="View ${comment.username || 'Anonymous'}'s Profile">
                    <div class="author-pic-wrapper" style="width:30px; height:30px; border-width:1px;">
                        ${comment.profilePhoto ?
                            `<img src="${getCloudinaryImageUrl(comment.profilePhoto, 'w_60,h_60,c_fill,g_face,r_max')}" alt="Author Pic" class="comment-author-pic" onerror="this.onerror=null; this.src='https://placehold.co/60x60/CCCCCC/000000?text=${commentAuthorInitial}';">` :
                            `<i class="fas fa-user-circle comment-author-pic-placeholder" style="font-size:30px;" role="img" aria-label="Comment Author Avatar"></i>`
                        }
                    </div>
                </a>
                <div class="comment-content-wrapper">
                    <a href="/profile.html?userId=${comment.userId}" class="comment-author-name">${comment.username || 'Anonymous'}</a>
                    <span class="comment-text">${comment.content}</span>
                    <span class="comment-timestamp">${comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleString() : 'N/A'}</span>
                    ${isCommentOwner || (currentUser && currentUser.uid === ADMIN_UID) ? `<button class="delete-comment-button" data-post-id="${postId}" data-comment-id="${commentId}" data-comment-author-id="${comment.userId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) || (!isCommentOwner && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Delete Comment"><i class="fas fa-trash-alt"></i></button>` : ''}
                </div>
            `;
            return commentElement;
        }


        /**
         * Fetches and displays posts in real-time using Firestore onSnapshot.
         * Manages post and comment listeners, and updates the UI dynamically.
         */
        async function fetchAndDisplayPosts() {
            console.log("JCHAT_DEBUG: fetchAndDisplayPosts called. isAuthReady:", isAuthReady);
            if (loadingPostsMessage) loadingPostsMessage.style.display = 'block'; // Show loading message.

            // Detach previous listeners to prevent memory leaks and duplicate updates.
            unsubscribeListeners.forEach(unsubscribe => {
                if (typeof unsubscribe === 'function') {
                    unsubscribe();
                }
            });
            unsubscribeListeners = []; // Clear the array of unsubscribe functions.
            if (postsFeed) postsFeed.innerHTML = ''; // Clear existing posts from the DOM.

            if (!postsFeed) {
                console.error("JCHAT_CRITICAL_ERROR: 'postsFeed' element not found in the DOM. Cannot display posts.");
                const mainContent = document.querySelector('main .content-wrapper');
                if (mainContent) {
                    mainContent.innerHTML = '<p style="text-align: center; color: var(--text-light); font-size: 1.1rem;">An error occurred loading content. Please refresh the page.</p>';
                }
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                return;
            }

            try {
                const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
                const q = query(postsCollectionRef, orderBy("timestamp", "desc")); // Order posts by timestamp descending.

                // Set up real-time listener for posts.
                const unsubscribePosts = onSnapshot(q, (querySnapshot) => {
                    console.log("JCHAT_DEBUG: onSnapshot for posts triggered. Number of posts:", querySnapshot.size);
                    const currentPostElements = new Map(); // Map to store current DOM elements by postId for efficient updates.
                    postsFeed.querySelectorAll('.post-card').forEach(card => {
                        currentPostElements.set(card.dataset.postId, card);
                    });

                    // Read filters
                    const typeFilter = postTypeFilter?.value || 'all';
                    const textSearch = (postSearchInput?.value || '').toLowerCase();
                    const fromDate = postDateFromInput?.value ? new Date(postDateFromInput.value + 'T00:00:00') : null;
                    const toDate = postDateToInput?.value ? new Date(postDateToInput.value + 'T23:59:59.999') : null;
                    const savedOnly = !!(showSavedOnlyCheckbox && showSavedOnlyCheckbox.checked);

                    const newOrderedPostIds = []; // To maintain the correct order of posts in the DOM.

                    querySnapshot.forEach(docSnapshot => {
                        const post = docSnapshot.data();
                        const postId = docSnapshot.id;

                        // Client-side filter
                        if (typeFilter !== 'all') {
                            const pType = post.mediaType ? post.mediaType : 'text';
                            if (pType !== typeFilter) return;
                        }
                        if (textSearch && !(post.content || '').toLowerCase().includes(textSearch)) return;
                        const ts = post.timestamp ? post.timestamp.toDate() : null;
                        if (fromDate && (!ts || ts < fromDate)) return;
                        if (toDate && (!ts || ts > toDate)) return;
                        if (savedOnly) {
                            const savedState = localStorage.getItem(`saved-post-${postId}`) === '1';
                            if (!savedState) return;
                        }

                        newOrderedPostIds.push(postId);

                        if (!postId) {
                            console.error("JCHAT_DEBUG: postId is undefined for a document snapshot. Skipping post.", docSnapshot.id);
                            return;
                        }

                        let postElement = currentPostElements.get(postId);

                        if (postElement) {
                            // If post already exists in DOM, update its content.
                            const contentP = postElement.querySelector('.post-content-text p');
                            if (contentP) contentP.textContent = post.content;

                            let postMediaDiv = postElement.querySelector('.post-media');
                            if (post.mediaUrl) {
                                if (!postMediaDiv) {
                                    postMediaDiv = document.createElement('div');
                                    postMediaDiv.classList.add('post-media');
                                    postElement.insertBefore(postMediaDiv, postElement.querySelector('.post-reactions-summary'));
                                }
                                postMediaDiv.innerHTML = post.mediaType === 'image' ?
                                    `<img src="${post.mediaUrl}" alt="Post Media" onerror="this.style.display='none';">` :
                                    `<video src="${post.mediaUrl}" controls onerror="this.style.display='none';"></video>`;
                                postMediaDiv.style.display = 'block';
                            } else if (postMediaDiv) {
                                postMediaDiv.remove(); // Remove media div if media was removed from post.
                            }

                            const timestampElement = postElement.querySelector('.post-timestamp');
                            if (timestampElement) {
                                timestampElement.textContent = `${post.timestamp ? new Date(post.timestamp.toDate()).toLocaleString() : 'N/A'} ${post.isEdited ? '(Edited)' : ''}`;
                            }

                            // Update reactions summary counts.
                            const summaryLikeCountElement = postElement.querySelector('.post-reactions-summary .like-count');
                            const summaryLoveCountElement = postElement.querySelector('.post-reactions-summary .love-count');
                            const summaryHahaCountElement = postElement.querySelector('.post-reactions-summary .haha-count');
                            if (summaryLikeCountElement) summaryLikeCountElement.textContent = post.reactions?.like || 0;
                            if (summaryLoveCountElement) summaryLoveCountElement.textContent = post.reactions?.love || 0;
                            if (summaryHahaCountElement) summaryHahaCountElement.textContent = post.reactions?.haha || 0;

                            // Update comments count.
                            const commentsCountElement = postElement.querySelector('.post-reactions-summary .comments-count');
                            if (commentsCountElement) commentsCountElement.textContent = post.commentsCount || 0;

                        } else {
                            // If post is new, create and append a new element.
                            postElement = renderPost(post, postId);
                            postsFeed.appendChild(postElement); // Add to DOM.
                        }

                        // Always ensure comment inputs and buttons are enabled/disabled based on current auth state and system settings.
                        const commentInput = postElement.querySelector('.comment-input');
                        const submitCommentButton = postElement.querySelector('.submit-comment-button');
                        if (commentInput) commentInput.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID);
                        if (submitCommentButton) submitCommentButton.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID);


                        // Setup onSnapshot for comments for this specific post.
                        const commentsListElement = document.getElementById(`comments-list-${postId}`);
                        if (commentsListElement && !commentsListElement.dataset.listenerAttached) { // Prevent attaching multiple listeners.
                            const commentsQuery = query(
                                collection(db, "artifacts", appId, "public", "data", "posts", postId, "comments"),
                                orderBy("timestamp", "asc")
                            );
                            const unsubscribeComments = onSnapshot(commentsQuery, (commentsSnapshot) => {
                                if (!commentsListElement) {
                                    console.error("JCHAT_ERROR: Comments list element not found for postId:", postId);
                                    return;
                                }
                                commentsListElement.innerHTML = ''; // Clear existing comments.

                                if (commentsSnapshot.empty) {
                                    commentsListElement.innerHTML = '<p style="font-size:0.85rem; color:var(--text-light); text-align:left; margin-left:10px;" class="no-comments-message">No comments yet.</p>';
                                } else {
                                    commentsSnapshot.forEach(commentDoc => {
                                        const comment = commentDoc.data();
                                        const commentId = commentDoc.id;
                                        commentsListElement.appendChild(renderComment(comment, commentId, postId));
                                    });
                                }
                                // Re-apply disabled state to delete comment buttons after rendering.
                                commentsListElement.querySelectorAll('.delete-comment-button').forEach(button => {
                                    const commentAuthorId = button.dataset.commentAuthorId;
                                    const isCommentOwner = currentUser && currentUser.uid === commentAuthorId;
                                    button.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) || (!isCommentOwner && currentUser.uid !== ADMIN_UID);
                                });
                            });
                            unsubscribeListeners.push(unsubscribeComments); // Add comment listener to the unsubscribe list.
                            commentsListElement.dataset.listenerAttached = 'true'; // Mark listener as attached.
                        }

                        // Setup onSnapshot for current user's reaction to this post (for newly added posts and updates).
                        if (currentUser) {
                            const userReactionRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "userReactions", currentUser.uid);
                            // Only attach if not already attached for this post and user.
                            if (!postElement.dataset.userReactionListenerAttached) {
                                const unsubscribeUserReaction = onSnapshot(userReactionRef, (reactionSnap) => {
                                    const currentPostCard = postsFeed.querySelector(`.post-card[data-post-id="${postId}"]`);
                                    if (currentPostCard) {
                                        const likeBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="like"]`);
                                        const loveBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="love"]`);
                                        const hahaBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="haha"]`);

                                        // Ensure buttons exist before manipulating classes.
                                        if (likeBtn) likeBtn.classList.remove('reacted-like');
                                        if (loveBtn) loveBtn.classList.remove('reacted-love');
                                        if (hahaBtn) hahaBtn.classList.remove('reacted-haha');

                                        if (reactionSnap.exists()) {
                                            const reactionData = reactionSnap.data();
                                            const activeReactionButton = currentPostCard.querySelector(`.react-button[data-reaction-type="${reactionData.type}"]`);
                                            if (activeReactionButton) {
                                                activeReactionButton.classList.add(`reacted-${reactionData.type}`);
                                            }
                                        }
                                    }
                                });
                                unsubscribeListeners.push(unsubscribeUserReaction); // Add user reaction listener to unsubscribe list.
                                postElement.dataset.userReactionListenerAttached = 'true'; // Mark listener as attached.
                            }
                        }
                    });

                    // Reorder posts in the DOM if necessary (important for orderBy).
                    const orderedElements = newOrderedPostIds.map(id => postsFeed.querySelector(`.post-card[data-post-id="${id}"]`));
                    orderedElements.forEach((element, index) => {
                        if (element && postsFeed.children[index] !== element) {
                            postsFeed.insertBefore(element, postsFeed.children[index]);
                        }
                    });

                    // Remove posts that no longer exist in the query snapshot (after reordering, to avoid re-inserting removed elements).
                    currentPostElements.forEach((element, id) => {
                        if (!newOrderedPostIds.includes(id)) {
                            element.remove();
                        }
                    });

                    // Display "No posts yet" message if the feed is empty.
                    if (querySnapshot.empty) {
                        if (!document.getElementById('noPostsMessage')) {
                            postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);" id="noPostsMessage">No posts yet. Be the first to post!</p>';
                        }
                    } else {
                        const noPostsMessage = document.getElementById('noPostsMessage');
                        if (noPostsMessage) noPostsMessage.remove();
                    }

                    if (loadingPostsMessage) loadingPostsMessage.style.display = 'none'; // Hide loading message.
                    // After posts are rendered/updated, apply system settings to their interactive elements.
                    applySystemSettings(currentSystemSettings);

                });
                unsubscribeListeners.push(unsubscribePosts); // Add the main posts listener to the unsubscribe list.

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching posts:", error);
                showMessageBox(`Error loading posts: ${error.message}`, 'error');
                if (postsFeed) postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);">Failed to load posts. Please try again later.</p>';
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
            }
        }


        // --- Event Delegation for Dynamic Elements ---
        // Attaches a single click listener to the document and delegates events to dynamically created elements.
        document.addEventListener('click', (event) => {
            // Handle React Buttons
            if (event.target.closest('.react-button')) {
                const button = event.target.closest('.react-button');
                if (!isAuthReady) { showMessageBox("Please log in to react.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Reactions are currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const reactionType = button.dataset.reactionType;
                handleReaction(postId, reactionType);
            }
            // Handle Poll Vote
            else if (event.target.closest('.poll-vote-button')) {
                const btn = event.target.closest('.poll-vote-button');
                const postId = btn.dataset.postId;
                const index = parseInt(btn.dataset.index, 10);
                votePoll(postId, index);
            }
            // Handle Comment Toggle Buttons
            else if (event.target.closest('.comment-toggle-button')) {
                const button = event.target.closest('.comment-toggle-button');
                const commentsSection = button.closest('.post-card').querySelector('.comments-section');
                if (commentsSection) {
                    commentsSection.style.display = commentsSection.style.display === 'none' ? 'block' : 'none';
                }
            }
            // Handle Submit Comment Buttons
            else if (event.target.closest('.submit-comment-button')) {
                const button = event.target.closest('.submit-comment-button');
                if (!isAuthReady) { showMessageBox("Please log in to comment.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Commenting is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const commentInput = button.closest('.comment-input-area').querySelector('.comment-input');
                addComment(postId, commentInput.value);
                commentInput.value = ''; // Clear comment input after submission.
            }
            // Handle Post Options Buttons (ellipsis menu)
            else if (event.target.closest('.post-options-button')) {
                const button = event.target.closest('.post-options-button');
                if (!isAuthReady) { showMessageBox("Please log in to manage posts.", 'error'); return; }
                // Admin can always manage posts, regular users only if feature is enabled.
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post management is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const dropdown = document.getElementById(`dropdown-${postId}`);
                // Close any other open dropdowns.
                document.querySelectorAll('.post-options-dropdown.active').forEach(openDropdown => {
                    if (openDropdown.id !== `dropdown-${postId}`) {
                        openDropdown.classList.remove('active');
                    }
                });
                if (dropdown) dropdown.classList.toggle('active'); // Toggle visibility of the clicked dropdown.
                event.stopPropagation(); // Prevent document click from closing it immediately.
            }
            // Handle Edit Post Button
            else if (event.target.closest('.edit-post-button')) {
                const button = event.target.closest('.edit-post-button');
                if (!isAuthReady) { showMessageBox("Please log in to edit posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post editing is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const content = button.dataset.content;
                const mediaUrl = button.dataset.mediaUrl;
                const mediaType = button.dataset.mediaType;
                openEditPostModal(postId, content, mediaUrl, mediaType);
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting edit.
            }
            // Handle Delete Post Button (This button is now removed from renderPost function, but keeping the handler for robustness)
            else if (event.target.closest('.delete-post-button')) {
                const button = event.target.closest('.delete-post-button');
                // This block should ideally not be reached if the button is not rendered.
                // However, for safety, if it somehow appears, it will be handled.
                if (!isAuthReady) { showMessageBox("Please log in to delete posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post deletion is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const authorId = button.dataset.authorId;
                deletePost(postId, authorId);
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting delete.
            }
            // Handle Share Post Button
            else if (event.target.closest('.share-post-button')) {
                const button = event.target.closest('.share-post-button');
                if (!isAuthReady) { showMessageBox("Please log in to share posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post sharing is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const content = button.dataset.content;
                showMessageBox(`You can share/post this: ${content.substring(0, 50)}...`, 'info');
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting share.
            }
            // Handle Delete Comment Button
            else if (event.target.closest('.delete-comment-button')) {
                const button = event.target.closest('.delete-comment-button');
                if (!isAuthReady) { showMessageBox("Please log in to delete comments.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Comment deletion is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const commentId = button.dataset.commentId;
                const commentAuthorId = button.dataset.commentAuthorId;
                deleteComment(postId, commentId, commentAuthorId);
            }
            // Close dropdowns if clicking anywhere else on the document (outside of a dropdown).
            else if (!event.target.closest('.post-options-dropdown')) {
                document.querySelectorAll('.post-options-dropdown.active').forEach(openDropdown => {
                    openDropdown.classList.remove('active');
                });
            }
        });

        // NEW: System Settings Logic
        // Document reference for global system settings in Firestore.
        const SYSTEM_SETTINGS_DOC_REF = doc(db, "artifacts", appId, "public", "data", "settings", "system_settings");

        /**
         * Fetches global system settings from Firestore.
         * If settings document doesn't exist, it creates it with default values.
         */
        async function fetchSystemSettings() {
            console.log("JCHAT_DEBUG: Fetching system settings...");
            try {
                const docSnap = await getDoc(SYSTEM_SETTINGS_DOC_REF);
                if (docSnap.exists()) {
                    currentSystemSettings = docSnap.data();
                    console.log("JCHAT_DEBUG: System settings fetched:", currentSystemSettings);
                } else {
                    console.warn("JCHAT_WARNING: System settings document not found. Initializing with default values.");
                    // Define default system settings.
                    currentSystemSettings = {
                        jcoinNairaRate: 7.5,
                        gasJcoinRate: 0.1,
                        dailyBonusAmount: 50,
                        defaultInspirationType: "motivational",
                        profanityFilterSensitivity: 5,
                        enableUserRegistration: true,
                        enableFriendRequests: true,
                        enablePublicChat: true,
                        enablePostCreation: true,
                        enableEmailNotifications: true,
                        maintenanceMode: false,
                        globalAnnouncement: "",
                        enableCalls: true, // NEW: Default to true for calls.
                    };
                    await setDoc(SYSTEM_SETTINGS_DOC_REF, currentSystemSettings); // Create the document.
                    console.log("JCHAT_DEBUG: Default system settings created.");
                }
                applySystemSettings(currentSystemSettings); // Apply settings immediately after fetching/initializing.
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching system settings:", error);
                showMessageBox(`Failed to load system settings: ${error.message}`, 'error', true);
            }
        }

        /**
         * Applies the fetched system settings to various UI elements and features.
         * Controls visibility and interactivity based on admin toggles and maintenance mode.
         * @param {object} settings - The system settings object.
         */
        function applySystemSettings(settings) {
            console.log("JCHAT_DEBUG: Applying system settings to UI:", settings);

            const isCurrentUserAdmin = currentUser && currentUser.uid === ADMIN_UID;

            // First, handle the global maintenance mode.
            if (settings.maintenanceMode) {
                if (isCurrentUserAdmin) {
                    // Admin bypasses maintenance overlay and global disabling.
                    if (maintenanceOverlay) maintenanceOverlay.classList.remove('active');
                    document.body.style.overflow = 'auto';
                    showMessageBox("JCHAT is in Maintenance Mode, but you (Admin) have full access.", 'info', true);
                    toggleInteractiveElements(true, true); // Enable everything for admin, pass isAdmin true.
                } else {
                    // Regular user sees maintenance overlay and all interactions are disabled.
                    if (maintenanceOverlay) {
                        maintenanceOverlay.classList.add('active');
                        if (maintenanceAnnouncementText) {
                            maintenanceAnnouncementText.textContent = settings.globalAnnouncement || "JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!";
                        }
                    }
                    toggleInteractiveElements(false, false); // Disable all interactions for regular users, pass isAdmin false.
                    document.body.style.overflow = 'hidden';
                    return; // IMPORTANT: Stop further processing of individual toggles for regular users in maintenance.
                }
            } else {
                // Maintenance mode is OFF for everyone.
                if (maintenanceOverlay) maintenanceOverlay.classList.remove('active');
                document.body.style.overflow = 'auto';
                toggleInteractiveElements(true, isCurrentUserAdmin); // Enable all interactions initially, pass isAdmin.
            }

            // Now, apply individual feature toggles.
            // These will refine the state set by the maintenance mode logic above.
            // For admins, these will apply normally. For regular users, if maintenance was ON,
            // this part is skipped. If maintenance was OFF, these apply normally.

            // Post Creation Section visibility and input states.
            if (postCreationSection) {
                if (settings.enablePostCreation || isCurrentUserAdmin) { // Admin can always see/use.
                    postCreationSection.style.display = 'flex';
                    if (postContentInput) postContentInput.disabled = false;
                    if (postMediaUpload) postMediaUpload.disabled = false;
                    if (createPostButton) createPostButton.disabled = false;
                } else {
                    postCreationSection.style.display = 'none';
                    if (postContentInput) postContentInput.disabled = true;
                    if (postMediaUpload) postMediaUpload.disabled = true;
                    if (createPostButton) createPostButton.disabled = true;
                }
            }

            // Sidebar links (only if they correspond to features that can be toggled).
            // These need to reflect the feature toggle, but also respect the overall `toggleInteractiveElements` state
            // which is set by maintenance mode. The `pointer-events` and `opacity` are good for this.
            if (chatLink) {
                if (settings.enablePublicChat || isCurrentUserAdmin) {
                    chatLink.style.pointerEvents = 'auto';
                    chatLink.style.opacity = '1';
                } else {
                    chatLink.style.pointerEvents = 'none';
                    chatLink.style.opacity = '0.5';
                }
            }
            if (findFriendsLink) {
                if (settings.enableFriendRequests || isCurrentUserAdmin) {
                    findFriendsLink.style.pointerEvents = 'auto';
                    findFriendsLink.style.opacity = '1';
                } else {
                    findFriendsLink.style.pointerEvents = 'none';
                    findFriendsLink.style.opacity = '0.5';
                }
            }
            if (friendsLink) {
                if (settings.enableFriendRequests || isCurrentUserAdmin) {
                    friendsLink.style.pointerEvents = 'auto';
                    friendsLink.style.opacity = '1';
                } else {
                    friendsLink.style.pointerEvents = 'none';
                    friendsLink.style.opacity = '0.5';
                }
            }
            if (groupsLink) { // Assuming a toggle for groups.
                // For now, groups are not explicitly tied to a system setting.
                // If a 'settings.enableGroups' existed, it would be used here.
                // Otherwise, its state is controlled by the global `toggleInteractiveElements`.
                groupsLink.style.pointerEvents = 'auto';
                groupsLink.style.opacity = '1';
            }
            if (jcoinShopLink) { // Assuming a toggle for shop.
                // For now, shop is not explicitly tied to a system setting.
                // If a 'settings.enableJCoinShop' existed, it would be used here.
                // Otherwise, its state is controlled by the global `toggleInteractiveElements`.
                jcoinShopLink.style.pointerEvents = 'auto';
                jcoinShopLink.style.opacity = '1';
            }

            // Re-apply disabled states to dynamically rendered post/comment elements.
            // This is crucial because these elements are rendered *before* settings are applied.
            document.querySelectorAll('.post-card').forEach(postCard => {
                const postId = postCard.dataset.postId;
                const postAuthorId = postCard.querySelector('.post-options-button')?.dataset.authorId || null; // Get authorId if options button exists.

                // Post actions (reactions, comments, options menu).
                postCard.querySelectorAll('.react-button, .comment-toggle-button').forEach(button => {
                    button.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);
                });

                // Comment input and submit button.
                const commentInput = postCard.querySelector('.comment-input');
                const submitCommentButton = postCard.querySelector('.submit-comment-button');
                if (commentInput) commentInput.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);
                if (submitCommentButton) submitCommentButton.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);

                // Delete comment buttons (more complex logic: can delete own if enabled, admin can delete any).
                postCard.querySelectorAll('.delete-comment-button').forEach(button => {
                    const commentAuthorId = button.dataset.commentAuthorId;
                    const isCommentOwner = currentUser && currentUser.uid === commentAuthorId;
                    button.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && !isCurrentUserAdmin) || (!isCommentOwner && !isCurrentUserAdmin);
                });

                // Post options (edit, share).
                postCard.querySelectorAll('.post-options-button, .edit-post-button, .share-post-button').forEach(button => {
                    // Only enable if current user is the author OR if current user is admin AND the feature is enabled.
                    // The isAuthor check is handled in renderPost, here we just control the disabled state based on settings and admin.
                    const isButtonAuthor = currentUser && currentUser.uid === postAuthorId;
                    button.disabled = !isAuthReady || ((!settings.enablePostCreation && !isCurrentUserAdmin) || (!isButtonAuthor && !isCurrentUserAdmin));
                });
            });

            // Re-evaluate daily bonus button state.
            checkAndStartDailyBonusTimer();
        }

        // WebRTC STUN/TURN servers (NEW)
        // Configuration for ICE servers, essential for WebRTC connection establishment.
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
            ]
        };

        /**
         * Initializes a new RTCPeerConnection.
         * Sets up onicecandidate and ontrack event handlers.
         * @returns {RTCPeerConnection} The initialized peer connection.
         */
        function createPeerConnection() {
            const pc = new RTCPeerConnection(iceServers);

            // Event handler for ICE candidates (network information).
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send ICE candidate to the other peer via Firestore.
                    if (callRef) {
                        const candidateData = JSON.parse(JSON.stringify(event.candidate)); // Deep copy to avoid Firestore issues.
                        if (isIncomingCall) { // If this peer is the receiver.
                            updateDoc(callRef, {
                                receiverCandidates: arrayUnion(candidateData)
                            }).catch(e => console.error("Error adding receiver candidate:", e));
                        } else { // If this peer is the caller.
                            updateDoc(callRef, {
                                callerCandidates: arrayUnion(candidateData)
                            }).catch(e => console.error("Error adding caller candidate:", e));
                        }
                    }
                }
            };

            // Event handler for remote media tracks.
            pc.ontrack = (event) => {
                // Attach remote stream to remoteVideo element.
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block';
                    remoteStream = event.streams[0];
                } else {
                    // Fallback for older browsers or individual tracks.
                    if (!remoteStream) {
                        remoteStream = new MediaStream();
                        remoteVideo.srcObject = remoteStream;
                        remoteVideo.style.display = 'block';
                    }
                    remoteStream.addTrack(event.track);
                }
            };

            return pc;
        }

        /**
         * Listens for incoming calls to the current user in real-time.
         */
        let unsubscribeCallListener = null; // Declare here so it can be cleared on unload.

        function listenForIncomingCalls() {
            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Unsubscribe from previous listener to prevent duplicates.
            }
            if (!currentUser) return;

            const callsCollectionRef = collection(db, "artifacts", appId, "public", "data", "calls");
            // Query for calls where current user is the receiver and status is 'ringing'.
            const q = query(callsCollectionRef, where("receiverId", "==", currentUser.uid), where("status", "==", "ringing"));

            unsubscribeCallListener = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    // No incoming calls.
                    stopRingingSound();
                    if (callState === 'ringing') { // If we were ringing and call disappeared (e.g., caller ended).
                        showMessageBox("Incoming call ended.", "info");
                        playNotificationSound('info');
                        endCall(false);
                    }
                    return;
                }

                const incomingCallDoc = snapshot.docs[0]; // Take the first incoming call.
                const callData = incomingCallDoc.data();

                // Check if calls are enabled by system settings (unless current user is admin).
                if (!currentSystemSettings.enableCalls && currentUser.uid !== ADMIN_UID) {
                    console.log("JCHAT_DEBUG: Calls disabled by admin. Declining incoming call.");
                    await updateDoc(incomingCallDoc.ref, { status: 'declined_by_system' });
                    showMessageBox("Incoming call declined: Calls are currently disabled by administrators.", "warning", true, 5000);
                    playNotificationSound('error');
                    return;
                }

                if (callState !== 'idle') {
                    // Already in a call or busy, decline new incoming call.
                    await updateDoc(incomingCallDoc.ref, { status: 'busy' });
                    showMessageBox(`Another call from ${callData.callerId === recipientUserProfileData?.userId ? recipientUserProfileData?.username : 'someone'} is incoming, but you are busy.`, "warning");
                    playNotificationSound('info');
                    return;
                }

                // New incoming call detected.
                callRef = incomingCallDoc.ref; // Store reference to the call document.
                isIncomingCall = true;
                callState = 'ringing';
                currentCallType = callData.callType;

                // Fetch caller's profile for display in the UI.
                const callerProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", callData.callerId);
                const callerProfileSnap = await getDoc(callerProfileDocRef);
                const callerUsername = callerProfileSnap.exists() ? callerProfileSnap.data().username : 'Unknown User';
                recipientUserProfileData = callerProfileSnap.exists() ? callerProfileSnap.data() : null; // Set recipient for UI.

                // Update call overlay UI.
                callOverlay.classList.add('active');
                callOverlay.classList.remove('voice-call', 'video-call'); // Clear previous call type classes.
                callOverlay.classList.add(currentCallType === 'voice' ? 'voice-call' : 'video-call');

                callStatusIcon.className = `fas fa-${currentCallType === 'voice' ? 'phone' : 'video'} call-status-icon`;
                callStatusText.textContent = `Incoming ${currentCallType} call from ${callerUsername}...`;
                callTimerDisplay.style.display = 'none'; // Hide timer initially.
                callActions.style.display = 'flex'; // Show call action buttons.
                acceptCallBtn.style.display = 'block';
                declineCallBtn.style.display = 'block';
                toggleMuteBtn.style.display = 'none';
                toggleVideoBtn.style.display = 'none';
                endCallBtn.style.display = 'none'; // Only accept/decline for incoming.
                callStatusIcon.style.animation = 'pulse-color 2s infinite alternate'; // Start icon animation.

                startRingingSound(); // Play ringing sound.

                // Set a timeout for no answer (20 seconds).
                callTimeoutId = setTimeout(async () => {
                    if (callState === 'ringing') {
                        stopRingingSound();
                        await updateDoc(callRef, { status: 'no-answer' });
                        showMessageBox("Incoming call unanswered.", "info");
                        playNotificationSound('info');
                        endCall(true); // End call and update Firestore.
                    }
                }, 20000);
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening for incoming calls:", error);
            });
        }

        /**
         * Handles accepting an incoming call.
         * Initializes WebRTC peer connection, gets local media, sets remote description,
         * creates and sets local answer, and updates Firestore.
         */
        async function acceptCall() {
            if (callState !== 'ringing' || !callRef || !currentUser) {
                showMessageBox("Cannot accept call in current state.", "warning");
                playNotificationSound('info');
                return;
            }

            stopRingingSound(); // Stop ringing sound.
            clearTimeout(callTimeoutId); // Clear no-answer timeout.

            callState = 'connected'; // Update call state.
            callStatusText.textContent = `Call with ${recipientUserProfileData?.username || 'user'}`;
            callTimerDisplay.style.display = 'block'; // Show call timer.
            callActions.style.display = 'flex'; // Show call action buttons.
            acceptCallBtn.style.display = 'none';
            declineCallBtn.style.display = 'none';
            endCallBtn.style.display = 'block';
            toggleMuteBtn.style.display = 'block';
            toggleVideoBtn.style.display = currentCallType === 'video' ? 'block' : 'none';
            callStatusIcon.style.animation = 'none'; // Stop icon animation.

            clearInterval(callDurationInterval); // Clear any old timer.
            callDurationInterval = setInterval(updateCallTimer, 1000); // Start new timer.

            showMessageBox("Call connected!", "success");
            playNotificationSound('success');

            try {
                // Get local media stream (audio and optionally video).
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: currentCallType === 'video'
                });
                localVideo.srcObject = localStream;
                if (currentCallType === 'video') {
                    localVideo.style.display = 'block'; // Show local video if it's a video call.
                }

                // Update current user's inCall status in public profile.
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: true });

                // Create Peer Connection.
                peerConnection = createPeerConnection();

                // Add local tracks to peer connection.
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // Get the offer from Firestore.
                const callDocSnap = await getDoc(callRef);
                const callData = callDocSnap.data();
                const remoteOffer = new RTCSessionDescription(callData.offer);
                await peerConnection.setRemoteDescription(remoteOffer);

                // Create and set local answer.
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Update Firestore with answer and status.
                await updateDoc(callRef, {
                    status: 'accepted',
                    answer: {
                        type: answer.type,
                        sdp: answer.sdp
                    },
                    lastActivity: serverTimestamp()
                });

                // Add any initial candidates from caller that might have arrived before answer.
                if (callData.callerCandidates && callData.callerCandidates.length > 0) {
                    for (const candidate of callData.callerCandidates) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        } catch (e) {
                            console.error("Error adding initial caller ICE candidate:", e);
                        }
                    }
                    await updateDoc(callRef, { callerCandidates: [] }); // Clear them after adding.
                }

                // Listen for caller candidates (new ones) after call is accepted.
                // This listener needs to be distinct from the one in listenForIncomingCalls
                // to avoid issues when the status changes from ringing to accepted.
                // Re-assigning unsubscribeCallListener here will replace the previous one.
                unsubscribeCallListener = onSnapshot(callRef, async (docSnap) => {
                    if (!docSnap.exists()) {
                        console.log("JCHAT_DEBUG: Call document disappeared. Ending call.");
                        endCall(false); // End call locally if document is gone.
                        return;
                    }
                    const data = docSnap.data();
                    if (data.callerCandidates && data.callerCandidates.length > 0) {
                        for (const candidate of data.callerCandidates) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.error("Error adding caller ICE candidate:", e);
                            }
                        }
                        await updateDoc(callRef, { callerCandidates: [] }); // Clear candidates after adding.
                    }
                    // If the other party ends the call, update local state.
                    if (data.status === 'ended' && callState !== 'idle') {
                        showMessageBox("Call ended by other party.", "info");
                        playNotificationSound('info');
                        endCall(false);
                    }
                });

            } catch (error) {
                console.error("JCHAT_ERROR: Error accepting call:", error);
                // Provide user-friendly error messages for common media issues.
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showMessageBox(`Failed to accept call: Microphone/Camera access denied. Please allow permissions in your browser settings.`, "error", true, 5000);
                } else if (error.name === 'NotFoundError') {
                    showMessageBox(`Failed to accept call: No microphone or camera found. Please ensure one is connected.`, "error", true, 5000);
                } else {
                    showMessageBox(`Failed to accept call: ${error.message}`, "error", true, 5000);
                }
                playNotificationSound('error');
                endCall(true); // Ensure cleanup even if acceptance fails.
            }
        }

        /**
         * Handles declining an incoming call.
         * Updates Firestore status and cleans up.
         */
        async function declineCall() {
            if (callState !== 'ringing' || !callRef) {
                showMessageBox("Cannot decline call in current state.", "warning");
                playNotificationSound('info');
                return;
            }

            stopRingingSound(); // Stop ringing.
            clearTimeout(callTimeoutId); // Clear no-answer timeout.
            showMessageBox("Call declined.", "info");
            playNotificationSound('info');

            try {
                await updateDoc(callRef, { status: 'declined', lastActivity: serverTimestamp() });
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating call status to declined:", error);
            } finally {
                endCall(false); // End call locally, Firestore already updated.
            }
        }

        /**
         * Toggles microphone mute/unmute during a call.
         */
        function toggleMute() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state.
                    isMuted = !track.enabled; // Update mute state.
                    toggleMuteBtn.classList.toggle('active', isMuted); // Toggle active class for styling.
                    toggleMuteBtn.querySelector('i').className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone'; // Change icon.
                });
            }
        }

        /**
         * Toggles video on/off during a call.
         */
        function toggleVideo() {
            if (localStream) {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state.
                    isVideoOff = !track.enabled; // Update video off state.
                    toggleVideoBtn.classList.toggle('active', isVideoOff); // Toggle active class for styling.
                    toggleVideoBtn.querySelector('i').className = isVideoOff ? 'fas fa-video-slash' : 'fas fa-video'; // Change icon.
                    localVideo.style.display = track.enabled ? 'block' : 'none'; // Hide/show local video element.
                });
            }
        }

        /**
         * Updates the call timer display every second.
         */
        function updateCallTimer() {
            callDuration++;
            const minutes = Math.floor(callDuration / 60);
            const seconds = callDuration % 60;
            callTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Ends the call and cleans up all WebRTC resources and UI.
         * @param {boolean} updateFirestore - Whether to update the Firestore call status to 'ended'.
         */
        async function endCall(updateFirestore = true) {
            stopRingingSound(); // Stop any ringing sound.
            clearInterval(callDurationInterval); // Stop call timer.
            clearTimeout(callTimeoutId); // Clear any no-answer timeout.

            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Unsubscribe from Firestore call listener.
                unsubscribeCallListener = null;
            }

            if (peerConnection) {
                peerConnection.close(); // Close the RTCPeerConnection.
                peerConnection = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop()); // Stop all local media tracks.
                localStream = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop()); // Stop all remote media tracks.
                remoteStream = null;
            }

            // Reset video element sources and display.
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            localVideo.style.display = 'none';
            remoteVideo.style.display = 'none';

            // Hide call overlay and reset call state.
            callOverlay.classList.remove('active', 'voice-call', 'video-call');
            callState = 'idle';
            isIncomingCall = false;
            callDuration = 0;
            callTimerDisplay.textContent = '00:00';

            // Reset call action button states and icons.
            toggleMuteBtn.classList.remove('active');
            toggleVideoBtn.classList.remove('active');
            toggleMuteBtn.querySelector('i').className = 'fas fa-microphone';
            toggleVideoBtn.querySelector('i').className = 'fas fa-video';
            toggleMuteBtn.style.display = 'none';
            toggleVideoBtn.style.display = 'none';
            acceptCallBtn.style.display = 'none';
            declineCallBtn.style.display = 'none';
            endCallBtn.style.display = 'none';
            callStatusIcon.style.animation = 'none';

            // Update user's inCall status in Firestore.
            if (currentUser && currentUser.uid) {
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on endCall:", e));
            }

            // Update Firestore call document status if explicitly requested.
            if (updateFirestore && callRef) {
                try {
                    await updateDoc(callRef, { status: 'ended', lastActivity: serverTimestamp() });
                } catch (error) {
                    console.error("JCHAT_ERROR: Error updating call status to ended in Firestore:", error);
                }
            }
            callRef = null; // Clear call reference.
        }


        // --- Authentication State Listener ---
        // This is the primary entry point after the DOM is loaded.
        onAuthStateChanged(auth, async (user) => {
            console.log("JCHAT_DEBUG: onAuthStateChanged triggered. User:", user ? user.uid : "null");
            if (user) {
                currentUser = user;
                isAuthReady = true; // Set to true early so profile fetching can proceed.
                await fetchAndDisplayHeaderProfile(user); // This sets currentUserProfileData and updates UI.
                console.log("JCHAT_DEBUG: Auth is ready. User ID:", currentUser.uid, "isAuthReady:", isAuthReady);

                // Start listening to system settings in real-time.
                const unsubscribeSettings = onSnapshot(SYSTEM_SETTINGS_DOC_REF, (docSnap) => {
                    if (docSnap.exists()) {
                        currentSystemSettings = docSnap.data();
                        console.log("JCHAT_DEBUG: Real-time system settings update:", currentSystemSettings);
                        applySystemSettings(currentSystemSettings); // Apply settings on every change.
                        // Start listening for calls only after settings are loaded and calls are enabled.
                        if (currentSystemSettings.enableCalls) {
                            listenForIncomingCalls();
                        } else {
                            if (unsubscribeCallListener) {
                                unsubscribeCallListener(); // Stop listening if calls are disabled.
                                unsubscribeCallListener = null;
                            }
                            if (callState !== 'idle') {
                                endCall(false); // End any active call if feature is disabled.
                                showMessageBox("Call ended: Calls are now disabled by administrators.", "warning", true, 5000);
                            }
                        }
                    } else {
                        console.warn("JCHAT_WARNING: System settings document not found during snapshot. Re-fetching.");
                        fetchSystemSettings(); // Re-fetch if document disappears.
                    }
                }, (error) => {
                    console.error("JCHAT_ERROR: Error listening to system settings:", error);
                    showMessageBox("Failed to get real-time settings updates.", 'error', true);
                });
                unsubscribeListeners.push(unsubscribeSettings); // Add to list to unsubscribe on unload.

                await fetchSystemSettings(); // Initial fetch of system settings.
                await fetchAndDisplayPosts(); // This will setup all real-time listeners for posts and comments.
                fetchNotificationCount(user.uid);


            } else {
                console.log("JCHAT_DEBUG: No user signed in. Attempting anonymous sign-in or redirecting to login page.");
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("JCHAT_DEBUG: Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("JCHAT_DEBUG: Signed in anonymously.");
                    }
                } catch (error) {
                    console.error("JCHAT_ERROR: Error during anonymous sign-in or custom token sign-in:", error);
                    if (!auth.currentUser) {
                        window.location.href = '/login.html'; // Redirect to login if all sign-in attempts fail.
                        return; // Stop further execution.
                    }
                }
                // If we reach here, either anonymous sign-in succeeded or custom token worked.
                // Re-check currentUser after potential anonymous sign-in.
                currentUser = auth.currentUser;
                if (currentUser) {
                    isAuthReady = true;
                    await fetchAndDisplayHeaderProfile(currentUser);
                    await fetchNotificationCount(currentUser.uid);
                    console.log("JCHAT_DEBUG: Anonymous/Custom Token Auth successful. User ID:", currentUser.uid, "isAuthReady:", isAuthReady);

                    // Start listening to system settings for anonymous users too (e.g., for maintenance mode).
                    const unsubscribeSettings = onSnapshot(SYSTEM_SETTINGS_DOC_REF, (docSnap) => {
                        if (docSnap.exists()) {
                            currentSystemSettings = docSnap.data();
                            console.log("JCHAT_DEBUG: Real-time system settings update for anonymous user:", currentSystemSettings);
                            applySystemSettings(currentSystemSettings);
                            // Calls are disabled for anonymous users by default by applySystemSettings, so no need to start listener.
                        } else {
                            console.warn("JCHAT_WARNING: System settings document not found during snapshot for anonymous user. Re-fetching.");
                            fetchSystemSettings();
                        }
                    }, (error) => {
                        console.error("JCHAT_ERROR: Error listening to system settings for anonymous user:", error);
                        showMessageBox("Failed to get real-time settings updates.", 'error', true);
                    });
                    unsubscribeListeners.push(unsubscribeSettings);

                    await fetchSystemSettings(); // Initial fetch for anonymous.
                    await fetchAndDisplayPosts(); // Fetch posts for anonymous (they can view, but not interact).

                } else {
                    // This case should ideally not be reached if the above logic is correct,
                    // but as a fallback, ensure UI is for logged out state.
                    isAuthReady = false;
                    toggleInteractiveElements(false, false); // Disable all elements for unauthenticated non-admin.
                    if (headerDisplayName) headerDisplayName.textContent = "Guest";
                    if (headerProfilePic) headerProfilePic.style.display = 'none';
                    if (headerAvatarIcon) headerAvatarIcon.style.display = 'block';
                    if (adminIconLink) adminIconLink.style.display = 'none'; // Ensure admin icon is hidden for guests.
                    if (postsFeed) postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);">Please log in to see posts and interact.</p>';
                    if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                    if (inspirationQuoteElement) inspirationQuoteElement.textContent = "Please log in to get your daily inspiration.";
                    if (inspirationAuthorElement) inspirationAuthorElement.textContent = "";

                    // Ensure daily bonus button is disabled and countdown is cleared for logged out state.
                    if (claimDailyBonusButton) {
                        claimDailyBonusButton.disabled = true;
                        claimDailyBonusButton.querySelector('.button-text').textContent = "Login to Claim Bonus";
                    }
                    if (dailyBonusCountdownInterval) {
                        clearInterval(dailyBonusCountdownInterval);
                        dailyBonusCountdownInterval = null;
                    }
                    console.log("JCHAT_DEBUG: Auth is NOT ready (final fallback). isAuthReady:", isAuthReady);

                    // Set default system settings for unauthenticated view if not fetched.
                    currentSystemSettings = {
                        jcoinNairaRate: 7.5, gasJcoinRate: 0.1, dailyBonusAmount: 50,
                        defaultInspirationType: "motivational", profanityFilterSensitivity: 5,
                        enableUserRegistration: true, enableFriendRequests: true, enablePublicChat: true,
                        enablePostCreation: true, enableEmailNotifications: true, maintenanceMode: false,
                        enableCalls: true, // Default to true for calls even for anonymous users to see UI.
                        globalAnnouncement: "",
                    };
                    applySystemSettings(currentSystemSettings); // Apply default settings for unauthenticated state.
                }
            }
        });

        // --- Event Listeners for static elements ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("JCHAT_DEBUG: DOMContentLoaded fired.");
            // Apply saved theme or default.
            const savedTheme = localStorage.getItem('jchat-theme');
            if (savedTheme && themes.includes(savedTheme)) {
                applyTheme(savedTheme);
            } else {
                applyTheme('theme-dark-mode');
            }
            // Initially disable interactive elements until authentication state is confirmed.
            toggleInteractiveElements(false, false);
            console.log(`JCHAT_DEBUG: Initial postContentInput disabled state: ${postContentInput ? postContentInput.disabled : 'N/A (element not found)'}`);

            // Set active class for current page in sidebar.
            const currentPagePath = window.location.pathname;
            sidebarNavItems.forEach(item => {
                if (item.getAttribute('href') === currentPagePath) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });

            // Call Overlay Button Listeners (NEW)
            if (acceptCallBtn) acceptCallBtn.addEventListener('click', acceptCall);
            if (declineCallBtn) declineCallBtn.addEventListener('click', declineCall);
            if (endCallBtn) endCallBtn.addEventListener('click', () => endCall(true)); // Pass true to update Firestore.
            if (toggleMuteBtn) toggleMuteBtn.addEventListener('click', toggleMute);
            if (toggleVideoBtn) toggleVideoBtn.addEventListener('click', toggleVideo);
        });

        // Listen for changes in local storage (e.g., theme changes from other tabs).
        window.addEventListener('storage', (event) => {
            if (event.key === 'jchat-theme') {
                const newTheme = event.newValue || 'theme-dark-mode';
                if (themes.includes(newTheme)) {
                    applyTheme(newTheme);
                }
            }
        });

        // Cleanup resources before the page unloads.
        window.addEventListener('beforeunload', async () => {
            // Detach all Firestore listeners before the page unloads.
            unsubscribeListeners.forEach(unsubscribe => {
                if (typeof unsubscribe === 'function') {
                    unsubscribe();
                }
            });
            unsubscribeListeners = []; // Clear the array.
            console.log("JCHAT_DEBUG: All Firestore listeners detached.");
            if (inspirationIntervalId) {
                clearInterval(inspirationIntervalId);
                console.log("JCHAT_DEBUG: Inspiration interval cleared.");
            }
            if (dailyBonusCountdownInterval) {
                clearInterval(dailyBonusCountdownInterval);
                console.log("JCHAT_DEBUG: Daily bonus countdown interval cleared.");
            }

            // Ensure inCall status is turned off when leaving the page.
            if (currentUser && currentUser.uid) {
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on beforeunload:", e));
            }
            // End any active WebRTC call.
            if (callState !== 'idle') {
                await endCall(false); // End call without updating Firestore status to avoid conflicts during unload.
            }
        });

        // Event listeners for specific UI buttons.
        if (sharePostInspirationButton) {
            sharePostInspirationButton.addEventListener('click', () => {
                if (!isAuthReady) { showMessageBox("Please log in to share inspiration.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post creation is currently disabled by administrators, so sharing as a post is not possible.", 'warning'); return; }
                const currentQuote = inspirationQuoteElement.textContent;
                const currentAuthor = inspirationAuthorElement.textContent;
                showMessageBox(`You can share/post this: ${currentQuote} ${currentAuthor}`, 'info');
            });
        }
        if (customizeInspirationButton) customizeInspirationButton.addEventListener('click', openCustomizeModal);
        if (cancelCustomizeButton) cancelCustomizeButton.addEventListener('click', closeCustomizeModal);
        if (saveCustomizeButton) saveCustomizeButton.addEventListener('click', saveInspirationType);
        if (claimDailyBonusButton) claimDailyBonusButton.addEventListener('click', handleClaimDailyBonusClick);

        // Close customization modal if clicking outside its content.
        if (customizeInspirationModal) {
            customizeInspirationModal.addEventListener('click', (event) => {
                if (event.target === customizeInspirationModal) {
                    closeCustomizeModal();
                }
            });
        }

        if (createPostButton) createPostButton.addEventListener('click', createNewPost);

        if (cancelEditPostButton) cancelEditPostButton.addEventListener('click', closeEditPostModal);
        if (saveEditedPostButton) saveEditedPostButton.addEventListener('click', saveEditedPost);

        // Close edit post modal if clicking outside its content.
        if (editPostModal) {
            editPostModal.addEventListener('click', (event) => {
                if (event.target === editPostModal) {
                    closeEditPostModal();
                }
            });
        }

        // Sidebar toggle logic.
        function toggleSidebar() {
            sidebarNav.classList.toggle('sidebar-hidden');
            sidebarNav.classList.toggle('sidebar-visible');
        }

        if (sidebarToggleFab) sidebarToggleFab.addEventListener('click', toggleSidebar);
        if (sidebarCloseBtn) sidebarCloseBtn.addEventListener('click', toggleSidebar);
        if (sidebarLogoutLink) sidebarLogoutLink.addEventListener('click', handleLogout); // Add logout to sidebar.

        // Export helpers (CSV/JSON) for posts
        function toCsv(rows) {
            if (!rows.length) return '';
            const headers = Object.keys(rows[0]);
            const escape = (v) => {
                if (v == null) return '';
                const s = String(v).replace(/"/g, '""');
                return /[",\n]/.test(s) ? `"${s}"` : s;
            };
            const lines = [headers.join(',')];
            for (const r of rows) lines.push(headers.map(h => escape(r[h])).join(','));
            return lines.join('\n');
        }

        async function fetchAllPostsForExport(filters) {
            const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
            const qAll = query(postsCollectionRef, orderBy("timestamp", "desc"));
            const snap = await getDocs(qAll);
            const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            return items.filter(p => {
                const pType = p.mediaType ? p.mediaType : 'text';
                if (filters.type && filters.type !== 'all' && pType !== filters.type) return false;
                if (filters.search && !(p.content || '').toLowerCase().includes(filters.search)) return false;
                if (filters.from || filters.to) {
                    const ts = p.timestamp ? p.timestamp.toDate() : null;
                    if (!ts) return false;
                    if (filters.from && ts < filters.from) return false;
                    if (filters.to && ts > filters.to) return false;
                }
                return true;
            });
        }

        function getPostFilterState() {
            const type = postTypeFilter?.value || 'all';
            const search = (postSearchInput?.value || '').toLowerCase();
            let from = null, to = null;
            if (postDateFromInput?.value) from = new Date(postDateFromInput.value + 'T00:00:00');
            if (postDateToInput?.value) to = new Date(postDateToInput.value + 'T23:59:59.999');
            return { type, search, from, to };
        }

        // Wire controls
        document.addEventListener('DOMContentLoaded', () => {
            if (postTypeFilter) postTypeFilter.addEventListener('change', fetchAndDisplayPosts);
            if (postSearchInput) postSearchInput.addEventListener('input', fetchAndDisplayPosts);
            if (postDateFromInput) postDateFromInput.addEventListener('change', fetchAndDisplayPosts);
            if (postDateToInput) postDateToInput.addEventListener('change', fetchAndDisplayPosts);
            if (exportPostsCsvButton) exportPostsCsvButton.addEventListener('click', async () => {
                if (!currentUser && !isAuthReady) return showMessageBox('Please log in.', 'warning');
                showMessageBox('Preparing CSV export...', 'loading', true);
                try {
                    const filters = getPostFilterState();
                    const items = await fetchAllPostsForExport(filters);
                    const rows = items.map(p => ({
                        id: p.id,
                        type: p.mediaType ? p.mediaType : 'text',
                        content: p.content || '',
                        authorId: p.authorId || '',
                        timestamp: p.timestamp ? p.timestamp.toDate().toISOString() : ''
                    }));
                    const csv = toCsv(rows);
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-posts-${Date.now()}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('CSV downloaded.', 'success');
                } catch (e) {
                    console.error(e);
                    showMessageBox('Failed to export CSV.', 'error');
                }
            });
            if (exportPostsJsonButton) exportPostsJsonButton.addEventListener('click', async () => {
                if (!currentUser && !isAuthReady) return showMessageBox('Please log in.', 'warning');
                showMessageBox('Preparing JSON export...', 'loading', true);
                try {
                    const filters = getPostFilterState();
                    const items = await fetchAllPostsForExport(filters);
                    const json = JSON.stringify(items.map(p => ({
                        id: p.id,
                        type: p.mediaType ? p.mediaType : 'text',
                        content: p.content || '',
                        authorId: p.authorId || '',
                        timestamp: p.timestamp ? p.timestamp.toDate().toISOString() : ''
                    })), null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-posts-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('JSON downloaded.', 'success');
                } catch (e) {
                    console.error(e);
                    showMessageBox('Failed to export JSON.', 'error');
                }
            });
        });

        // Save/Unsave post helper
        async function toggleSavePost(postId, shouldSave) {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            const savedRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saved_posts', postId);
            if (shouldSave) {
                await setDoc(savedRef, { savedAt: serverTimestamp() }).catch(e => console.error('Save failed', e));
                showMessageBox('Post saved.', 'success');
            } else {
                await deleteDoc(savedRef).catch(e => console.error('Unsave failed', e));
                showMessageBox('Removed from saved.', 'info');
            }
        }

        // Enhance post content: link hashtags
        function linkHashtags(text) {
            if (!text) return '';
            return text.replace(/(^|\s)#(\w{2,30})/g, (m, p1, tag) => `${p1}<a href="#" class="hashtag-link" data-tag="${tag}">#${tag}</a>`);
        }

        // Track hashtags for trending display
        function updateTrendingHashtags(allPosts) {
            const counts = new Map();
            allPosts.forEach(p => {
                const content = p.content || '';
                const matches = content.match(/#\w{2,30}/g) || [];
                matches.forEach(tag => {
                    counts.set(tag, (counts.get(tag) || 0) + 1);
                });
            });
            const top = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5);
            if (trendingHashtagsDiv) {
                if (top.length === 0) { trendingHashtagsDiv.textContent = ''; return; }
                trendingHashtagsDiv.innerHTML = 'Trending: ' + top.map(([tag]) => `<a href="#" class="hashtag-link" data-tag="${tag.substring(1)}">${tag}</a>`).join('  ');
            }
        }

        // Extend renderPost to link hashtags
        const _origRenderPost = renderPost;
        renderPost = function(post, postId) {
            const el = _origRenderPost(post, postId);
            const textDiv = el.querySelector('.post-content-text p');
            if (textDiv) {
                textDiv.innerHTML = linkHashtags(post.content);
            }
            return el;
        }

        // Hook into document click for save and hashtag
        document.addEventListener('click', (ev) => {
            const saveBtn = ev.target.closest('.save-post-button');
            if (saveBtn) {
                const pid = saveBtn.dataset.postId;
                const saved = saveBtn.classList.toggle('saved');
                localStorage.setItem(`saved-post-${pid}`, saved ? '1' : '0');
                toggleSavePost(pid, saved);
            }
            const tagLink = ev.target.closest('.hashtag-link');
            if (tagLink) {
                const tag = tagLink.dataset.tag;
                if (postSearchInput) postSearchInput.value = `#${tag}`;
                fetchAndDisplayPosts();
            }
        });

        // Modify posts onSnapshot to compute trending + filter saved only
        const _origFetchAndDisplayPosts = fetchAndDisplayPosts;
        fetchAndDisplayPosts = async function() {
            await _origFetchAndDisplayPosts();
            // After initial render, we cannot easily intercept onSnapshot pipeline; recompute trending client-side from DOM
            const cards = [...(postsFeed?.querySelectorAll('.post-card') || [])];
            const posts = cards.map(c => ({
                id: c.dataset.postId,
                content: (c.querySelector('.post-content-text p')?.textContent) || ''
            }));
            updateTrendingHashtags(posts);
        }

        // Re-trigger fetch when toggling saved only
        document.addEventListener('DOMContentLoaded', () => {
            if (showSavedOnlyCheckbox) showSavedOnlyCheckbox.addEventListener('change', fetchAndDisplayPosts);
        });

        // Theme selector
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            const saved = localStorage.getItem('jchat-theme');
            if (saved && [...themeSelect.options].some(o => o.value === saved)) {
                themeSelect.value = saved;
            }
            themeSelect.addEventListener('change', () => applyTheme(themeSelect.value));
        }

        // Streaks & Quests basic implementation
        const streakInfo = document.getElementById('streakInfo');
        const questsList = document.getElementById('questsList');
        async function updateStreakAndQuestsUI() {
            if (!currentUser || !currentUserProfileData) { if (streakInfo) streakInfo.textContent = 'Login to start a streak.'; return; }
            try {
                const streakDocRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'streak');
                const streakSnap = await getDoc(streakDocRef);
                const today = new Date(); today.setHours(0,0,0,0);
                let streakCount = 0; let lastDate = null;
                if (streakSnap.exists()) {
                    const d = streakSnap.data();
                    streakCount = d.count || 0;
                    lastDate = d.lastDate ? d.lastDate.toDate() : null;
                }
                // Increment if lastDate is before today
                const needIncrement = !lastDate || (new Date(lastDate.setHours(0,0,0,0)) < today);
                if (needIncrement) {
                    await setDoc(streakDocRef, { count: streakCount + 1, lastDate: serverTimestamp() }, { merge: true });
                    streakCount += 1;
                }
                if (streakInfo) streakInfo.textContent = `Current streak: ${streakCount} day${streakCount===1?'':'s'}`;
            } catch (e) { console.error('Streak update failed', e); }

            // Quests (static weekly set)
            const weekQuests = [
                { id:'q1', title:'React 10 times', target:10 },
                { id:'q2', title:'Comment 5 times', target:5 },
                { id:'q3', title:'Create 2 posts', target:2 },
            ];
            if (questsList) {
                questsList.innerHTML = '';
                weekQuests.forEach(q => {
                    const progress = 0; // placeholder; wire to activity logs later
                    const pct = Math.min(100, Math.round((progress / q.target) * 100));
                    const row = document.createElement('div');
                    row.className = 'quest-item';
                    row.innerHTML = `<span>${q.title}</span><div class="quest-progress"><div style="width:${pct}%"></div></div><span>${progress}/${q.target}</span>`;
                    questsList.appendChild(row);
                });
            }
        }

        // Daily Spin
        const spinNowButton = document.getElementById('spinNowButton');
        const spinStatus = document.getElementById('spinStatus');
        if (spinNowButton) {
            spinNowButton.addEventListener('click', async () => {
                if (!currentUser) { showMessageBox('Login to spin.', 'warning'); return; }
                const spinRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'daily_spin');
                const snap = await getDoc(spinRef);
                const now = new Date();
                if (snap.exists()) {
                    const last = snap.data().lastSpinAt?.toDate();
                    if (last) {
                        const since = now - last;
                        if (since < 24*60*60*1000) {
                            const hrs = Math.ceil((24*60*60*1000 - since)/3600000);
                            if (spinStatus) spinStatus.textContent = `Come back in ~${hrs}h.`;
                            return;
                        }
                    }
                }
                // Weighted rewards
                const rewards = [ {j:5, w:40}, {j:10, w:30}, {j:20, w:20}, {j:50, w:8}, {j:100, w:2} ];
                const totalW = rewards.reduce((a,b)=>a+b.w,0);
                let r = Math.random()*totalW, pick = rewards[0];
                for (const it of rewards) { if (r < it.w) { pick = it; break; } r -= it.w; }
                // Credit user
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'profiles', 'user_profile');
                    await runTransaction(db, async (trx) => {
                        const ps = await trx.get(profileRef);
                        const cur = ps.exists()? (ps.data().jCoins||0):0;
                        trx.update(profileRef, { jCoins: cur + pick.j, updatedAt: serverTimestamp() });
                    });
                    await setDoc(spinRef, { lastSpinAt: serverTimestamp() }, { merge: true });
                    if (spinStatus) spinStatus.textContent = `You won ${pick.j} JCoins!`;
                } catch(e) { console.error(e); showMessageBox('Spin failed.', 'error'); }
            });
        }

        // Stories
        const addStoryButton = document.getElementById('addStoryButton');
        const storyUploadInput = document.getElementById('storyUploadInput');
        const storiesBar = document.getElementById('storiesBar');
        let currentStories = [];
        if (addStoryButton && storyUploadInput) {
            addStoryButton.addEventListener('click', ()=> storyUploadInput.click());
            storyUploadInput.addEventListener('change', async (e)=>{
                const file = e.target.files[0]; if (!file || !currentUser) return;
                showMessageBox('Uploading story...', 'loading', true);
                const url = await uploadMediaToCloudinary(file);
                if (!url) { showMessageBox('Story upload failed.', 'error'); return; }
                const storiesRef = collection(db, 'artifacts', appId, 'public', 'data', 'stories');
                await addDoc(storiesRef, { userId: currentUser.uid, username: currentUserProfileData?.username||'User', mediaUrl: url, mediaType: file.type.startsWith('image/')?'image':'video', viewCount: 0, createdAt: serverTimestamp() });
                showMessageBox('Story posted!', 'success');
                fetchStories();
            });
        }
        async function fetchStories() {
            if (!storiesBar) return;
            storiesBar.innerHTML = '';
            const storiesRef = collection(db, 'artifacts', appId, 'public', 'data', 'stories');
            const qStories = query(storiesRef, orderBy('createdAt','desc'));
            const snap = await getDocs(qStories);
            const now = Date.now();
            currentStories = snap.docs
                .map(d => ({ id: d.id, ...d.data() }))
                .filter(s => (now - (s.createdAt?.toDate()?.getTime() || 0)) <= 24*60*60*1000);
            currentStories.forEach((s, idx) => {
                const item = document.createElement('div');
                item.className = 'story-item';
                const avatar = document.createElement('div');
                avatar.className = 'story-avatar';
                if (s.mediaType==='image') {
                    avatar.innerHTML = `<img src="${s.mediaUrl}" alt="story">`;
                } else {
                    avatar.innerHTML = `<i class=\"fas fa-video\"></i>`;
                }
                const name = document.createElement('span');
                name.style.color='var(--text-light)'; name.style.fontSize='0.8rem';
                name.textContent = s.username?.split(' ')[0] || 'User';
                item.appendChild(avatar); item.appendChild(name);
                item.addEventListener('click', ()=> openStory(idx));
                storiesBar.appendChild(item);
            });
        }

        // Story viewer refs/state
        const storyViewer = document.getElementById('storyViewer');
        const storyImageEl = document.getElementById('storyImage');
        const storyVideoEl = document.getElementById('storyVideo');
        const storyViewerTitle = document.getElementById('storyViewerTitle');
        const closeStoryViewerBtn = document.getElementById('closeStoryViewer');
        const prevStoryBtn = document.getElementById('prevStoryBtn');
        const nextStoryBtn = document.getElementById('nextStoryBtn');
        let currentStoryIndex = 0;
        const viewedStoryIds = new Set();

        async function openStory(index) {
            if (!currentStories || !currentStories.length) return;
            currentStoryIndex = Math.max(0, Math.min(index, currentStories.length-1));
            const s = currentStories[currentStoryIndex];
            if (!s) return;
            if (storyViewerTitle) storyViewerTitle.textContent = `${s.username || 'Story'}`;
            if (s.mediaType === 'image') {
                if (storyVideoEl) { try { storyVideoEl.pause(); } catch{} storyVideoEl.style.display = 'none'; storyVideoEl.src=''; }
                if (storyImageEl) { storyImageEl.src = s.mediaUrl; storyImageEl.style.display = 'block'; }
            } else {
                if (storyImageEl) { storyImageEl.style.display = 'none'; storyImageEl.src=''; }
                if (storyVideoEl) { storyVideoEl.src = s.mediaUrl; storyVideoEl.style.display = 'block'; storyVideoEl.play().catch(()=>{}); }
            }
            if (storyViewer) storyViewer.classList.add('active');
            if (!viewedStoryIds.has(s.id)) {
                viewedStoryIds.add(s.id);
                try {
                    const storyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'stories', s.id);
                    await updateDoc(storyDocRef, { viewCount: (s.viewCount || 0) + 1 });
                    s.viewCount = (s.viewCount || 0) + 1;
                } catch (e) { console.error('Failed to update viewCount', e); }
            }
            if (prevStoryBtn) prevStoryBtn.disabled = currentStoryIndex <= 0;
            if (nextStoryBtn) nextStoryBtn.disabled = currentStoryIndex >= currentStories.length-1;
        }
        function closeStoryViewer() {
            if (storyViewer) storyViewer.classList.remove('active');
            if (storyImageEl) { storyImageEl.style.display = 'none'; storyImageEl.src=''; }
            if (storyVideoEl) { try { storyVideoEl.pause(); } catch{} storyVideoEl.style.display = 'none'; storyVideoEl.src=''; }
        }
        if (closeStoryViewerBtn) closeStoryViewerBtn.addEventListener('click', closeStoryViewer);
        if (prevStoryBtn) prevStoryBtn.addEventListener('click', ()=> openStory(currentStoryIndex-1));
        if (nextStoryBtn) nextStoryBtn.addEventListener('click', ()=> openStory(currentStoryIndex+1));

        document.addEventListener('DOMContentLoaded', () => {
            updateStreakAndQuestsUI();
            fetchStories();
        });

        // Smart Scroll logic
        const smartScrollBtn = document.getElementById('smartScrollBtn');
        let scrollTarget = 'bottom';
        function updateSmartScrollState() {
            const nearTop = window.scrollY < 50;
            const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 50);
            if (nearBottom) { scrollTarget = 'top'; if (smartScrollBtn) { smartScrollBtn.querySelector('i').className='fas fa-arrow-up'; smartScrollBtn.querySelector('.label').textContent='Top'; } }
            else { scrollTarget = 'bottom'; if (smartScrollBtn) { smartScrollBtn.querySelector('i').className='fas fa-arrow-down'; smartScrollBtn.querySelector('.label').textContent='Bottom'; } }
        }
        if (smartScrollBtn) {
            smartScrollBtn.addEventListener('click', ()=> {
                if (scrollTarget === 'bottom') {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                } else {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
            window.addEventListener('scroll', updateSmartScrollState, { passive: true });
            window.addEventListener('resize', updateSmartScrollState);
            document.addEventListener('DOMContentLoaded', updateSmartScrollState);
        }
    </script>
</body>
</html>