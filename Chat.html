<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Full Chat</title>

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://*.firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>



        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --glass-black: rgba(10, 10, 10, .75);
            --glass-blue: rgba(0, 213, 255, .15);
            --radius: 20px;
            --transition: .3s ease;

            /* These variables will be overridden by theme classes */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* New variables for consistent theming */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #bbbbbb;
            --notification-badge-color: #ff2e92;
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;

            /* Chat specific variables */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --composer-accent: #3b82f6;
            --play-button-green: linear-gradient(90deg, #4CAF50, #8BC34A);
            --play-button-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
        }

        /* Theme Definitions */
        body.theme-dark-mode {
            --background-main: #1a1a2e;
            --background-gradient-1: #16213e;
            --background-gradient-2: #0f3460;
            --white: #e0e0e0;
            --text-light: #a0a0a0;
            --card-background: rgba(25, 25, 40, 0.7);
            --header-background: linear-gradient(135deg, rgba(10, 10, 20, .85), rgba(10, 10, 20, .75));
            --border-light: rgba(255, 255, 255, 0.08);
            --input-background: rgba(255, 255, 255, 0.08);
        }

        /* Always show scrollbar to prevent layout shifts */
        html {
            overflow-y: scroll;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-main);
            background-image: radial-gradient(circle at top left, var(--background-gradient-1), transparent 100px),
                              radial-gradient(circle at bottom right, var(--background-gradient-2), transparent 150px);
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease;

            position: relative;
            width: 100%;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 55px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 30px;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
            text-decoration: none;
        }

        /* User Profile Header Styling */
        .user-profile-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cool Notification Icon Styling */
        .notification-icon-wrapper {
            position: relative;
            margin-right: 15px;
        }

        .notification-icon-wrapper a {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .notification-icon-wrapper a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .notification-icon-wrapper a:hover::before {
            left: 100%;
        }

        .notification-icon-wrapper a:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
            border-color: var(--blue);
        }

        .notification-icon-wrapper i {
            font-size: 1.3rem;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #ff8e53);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            transition: all 0.3s ease;
            z-index: 1;
            position: relative;
        }

        .notification-icon-wrapper a:hover i {
            transform: rotate(15deg) scale(1.1);
            background: linear-gradient(45deg, #ff8e53, #ffd700, #ff6b35);
            background-clip: text;
            -webkit-background-clip: text;
        }

        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #ff8e53);
            color: #000;
            border-radius: 50%;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
            animation: pulse-notification 2s infinite;
            display: none;
        }

        @keyframes pulse-notification {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Additional cool effects for notification icon */
        .notification-icon-wrapper a:active {
            transform: scale(0.95);
        }

        /* Glow effect when there are notifications */
        .notification-icon-wrapper.has-notifications a {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .notification-icon-wrapper.has-notifications a:hover {
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        /* Shaking animation for notification bell when there are unread notifications */
        .notification-icon-wrapper.has-notifications i {
            animation: bell-shake 3s ease-in-out infinite;
            transform-origin: top;
        }

        @keyframes bell-shake {
            0%, 90%, 100% { transform: rotate(0deg); }
            5%, 15%, 25%, 35% { transform: rotate(10deg); }
            10%, 20%, 30% { transform: rotate(-10deg); }
            40%, 50%, 60%, 70%, 80% { transform: rotate(0deg); }
        }

        /* Pause shaking on hover */
        .notification-icon-wrapper.has-notifications a:hover i {
            animation-play-state: paused;
        }

        .user-profile-header #profileLink {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--white);
            transition: opacity 0.3s ease, background-color 0.3s ease;
            padding: 5px 10px;
            border-radius: var(--radius);
        }

        .user-profile-header #profileLink:hover {
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .user-profile-header img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .user-profile-header i {
            font-size: 30px;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        .user-profile-header span {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        /* Admin Icon Styling */
        #adminIconLink {
            display: none;
            margin-right: 15px;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        #adminIconLink:hover {
            transform: scale(1.1);
        }

        /* Sound Toggle */
        .sound-toggle {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .sound-toggle i {
            font-size: 1.5rem;
            color: var(--text-light);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .sound-toggle i.active {
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Chat Container */
        .chat-container {
            position: fixed;
            top: 55px;
            left: 0;
            width: 100%;
            height: calc(100vh - 55px);
            height: calc(100dvh - 55px);
            background: var(--background-main);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Prevent any scrolling within chat container */
            touch-action: none;
            overscroll-behavior: none;
        }

        /* Chat Header */
        .chat-header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-shrink: 0;
            z-index: 5;
        }

        .back-btn {
            background: linear-gradient(135deg, var(--pink), var(--blue));
            border: none;
            color: var(--white);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 10px 12px;
            border-radius: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 46, 146, 0.3);
        }

        .back-btn:hover {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 213, 255, 0.4);
        }

        .back-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .chat-header img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
        }

        .chat-header .default-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--white);
        }

        .chat-header h2 {
            flex-grow: 1;
            margin: 0;
            font-size: 1.2rem;
            color: var(--white);
        }

        /* Chat Header Buttons */
        .chat-header .select-friend-btn, 
        .chat-header .find-friends-btn {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
        }

        .chat-header .select-friend-btn {
            margin-left: auto;
        }

        .chat-header .find-friends-btn {
            margin-left: 10px;
        }

        .chat-header .select-friend-btn:hover {
            color: var(--accent-color);
        }

        .chat-header .find-friends-btn:hover {
            color: #4CAF50;
        }

        /* Badge for Select Friend Button */
        .select-friend-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--notification-badge-color);
            color: var(--white);
            border-radius: 50%;
            padding: 3px 7px;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            animation: pulse-notification 2s infinite;
        }

        /* Theme Switcher Button */
        .theme-switcher-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin-left: 10px;
        }

        .theme-switcher-btn:hover {
            transform: rotate(180deg) scale(1.1);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }

        /* Messages Area - Critical for scroll management */
        .messages-area {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* Controlled scrolling within messages only */
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }

        .messages-area::-webkit-scrollbar {
            width: 6px;
        }

        .messages-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-area::-webkit-scrollbar-thumb {
            background-color: var(--accent-color);
            border-radius: 3px;
        }

        /* Message Bubbles */
        .message-bubble {
            max-width: 70%;
            margin-bottom: 10px;
            position: relative;
            animation: fadeIn 0.3s ease;
        }

        .message-bubble.sent {
            align-self: flex-end;
            margin-left: auto;
        }

        .message-bubble.received {
            align-self: flex-start;
            margin-right: auto;
        }

        .message-content {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 18px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            word-wrap: break-word;
        }

        .message-bubble.sent .message-content {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            color: var(--white);
        }

        .message-time {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 5px;
            text-align: right;
        }

        .message-bubble.received .message-time {
            text-align: left;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: var(--card-background);
            border-radius: 20px;
            margin: 10px 20px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .typing-indicator.active {
            opacity: 1;
            visibility: visible;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--accent-color);
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingAnimation {
            0%, 60%, 100% { transform: scale(1); opacity: 0.5; }
            30% { transform: scale(1.2); opacity: 1; }
        }

        /* Chat Input Area - Critical positioning */
        .chat-input-area {
            background: var(--header-background);
            border-top: 1px solid var(--border-light);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
            position: relative;
            z-index: 5;
        }

        .chat-actions-top {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .chat-actions-top button {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(255, 46, 146, 0.2);
            position: relative;
            overflow: hidden;
        }

        .chat-actions-top button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .chat-actions-top button:hover::before {
            left: 100%;
        }

        .chat-actions-top button:hover {
            background: linear-gradient(90deg, var(--pink), var(--blue));
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.5);
        }

        .chat-actions-top button:active {
            transform: translateY(-1px) scale(0.98);
        }

        .chat-actions-top button.active {
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input-row textarea {
            flex-grow: 1;
            padding: 12px 15px;
            border-radius: 25px;
            border: 1px solid var(--border-light);
            background-color: var(--input-background);
            color: var(--white);
            font-size: 14px;
            outline: none;
            resize: none;
            min-height: 45px;
            max-height: 120px;
            overflow-y: auto;
            transition: border-color 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .chat-input-row textarea::placeholder {
            color: var(--text-light);
        }

        .chat-input-row textarea:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        #sendMessageBtn {
            background: var(--composer-accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            position: relative;
            overflow: hidden;
        }

        #sendMessageBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        #sendMessageBtn:hover::before {
            left: 100%;
        }

        #sendMessageBtn:hover:not(:disabled) {
            background: #2563eb;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
        }

        #sendMessageBtn:active:not(:disabled) {
            transform: scale(0.95);
        }

        #sendMessageBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            background: #6b7280;
        }

        #sendMessageBtn.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Voice Recording Indicator */
        #voiceNoteBtn.recording {
            background: linear-gradient(90deg, #dc3545, #e94560);
            animation: pulse-red 1.5s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .chat-container {
                height: calc(100vh - 55px);
                height: calc(100dvh - 55px);
            }
            
            .chat-header {
                padding: 10px 15px;
            }
            
            .chat-header h2 {
                font-size: 1.1rem;
            }
            
            .messages-area {
                padding: 15px;
            }
            
            .message-bubble {
                max-width: 85%;
            }
            
            .chat-input-area {
                padding: 12px 15px;
            }
            
            .chat-actions-top button {
                padding: 6px 10px;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .chat-header {
                padding: 8px 12px;
            }
            
            .chat-header h2 {
                font-size: 1rem;
            }
            
            .messages-area {
                padding: 10px;
            }
            
            .message-bubble {
                max-width: 90%;
            }
            
            .chat-input-area {
                padding: 10px 12px;
            }
        }

        /* Message Reactions */
        .message-reactions {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .reaction {
            background: rgba(37, 211, 102, 0.1);
            border: 1px solid rgba(37, 211, 102, 0.3);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reaction:hover {
            background: rgba(37, 211, 102, 0.2);
            transform: scale(1.1);
        }

        .reaction.active {
            background: rgba(37, 211, 102, 0.3);
            border-color: #25D366;
        }

        /* Quick Reactions Panel */
        .quick-reactions {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideUp 0.3s ease;
        }

        .reaction-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reaction-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            border-color: #25D366;
        }

        .reaction-btn:active {
            transform: scale(0.95);
        }

        /* Reaction Toggle Button */
        #reactionToggleBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        #reactionToggleBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-background);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h3 {
            color: var(--white);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Poppins', sans-serif;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid var(--border-light);
            background-color: var(--input-background);
            color: var(--white);
            font-size: 1rem;
            outline: none;
        }

        .search-input::placeholder {
            color: var(--text-light);
        }

        .friend-list-modal {
            flex-grow: 1;
            overflow-y: auto;
            max-height: calc(80vh - 150px);
            padding-right: 5px;
        }

        .friend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border-radius: 10px;
            background-color: var(--input-background);
            border: 1px solid var(--border-light);
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .friend-item:hover {
            background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1));
            transform: translateY(-3px) scale(1.02);
            border-color: var(--blue);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
        }

        .friend-item:active {
            transform: translateY(-1px) scale(0.98);
        }

        .friend-item .default-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--white);
            flex-shrink: 0;
        }

        .friend-item span {
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .friend-item .friend-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .friend-item .friend-name {
            flex: 1;
            font-weight: 600;
            color: var(--white);
        }

        .friend-item .friend-status {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 15px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .friend-item .friend-status.online {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .friend-item .friend-status.offline {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }

        /* Enhanced Friend Item Layout */
        .friend-avatar-container {
            position: relative;
            flex-shrink: 0;
        }

        .friend-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .friend-info .friend-name {
            font-weight: 600;
            color: var(--white);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .friend-info .friend-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 500;
            width: fit-content;
        }

        .friend-info .last-seen {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
        }

        /* Online Indicator */
        .online-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #22c55e;
            border-radius: 50%;
            border: 2px solid var(--background-main);
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
            }
        }

        /* Responsive Friend List */
        @media (max-width: 768px) {
            .friend-item {
                padding: 12px;
                gap: 8px;
            }
            
            .friend-avatar,
            .default-avatar {
                width: 35px !important;
                height: 35px !important;
            }
            
            .online-indicator {
                width: 10px;
                height: 10px;
            }
        }

        /* Media Message Styles */
        .media-message {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
        }

        .media-message img,
        .media-message video {
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .media-message img:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
            border-color: rgba(0, 213, 255, 0.5);
        }

        .media-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 5px;
        }

        .media-info span:first-child {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .media-info span:last-child {
            background: rgba(0, 213, 255, 0.2);
            color: #00d5ff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
        }

        /* Call Control Buttons */
        .call-control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .call-control-btn:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
        }

        .call-control-btn.end-call {
            background: linear-gradient(135deg, #dc3545, #e94560);
        }

        .call-control-btn.end-call:hover {
            background: linear-gradient(135deg, #e94560, #dc3545);
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
        }

        /* Call Interface Responsive */
        @media (max-width: 768px) {
            .call-control-btn {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            
            #localVideo {
                width: 150px !important;
                height: 100px !important;
                bottom: 10px !important;
                right: 10px !important;
            }
        }

        .message-badge {
            background-color: var(--notification-badge-color);
            color: var(--white);
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 0.65rem;
            font-weight: 700;
            min-width: 18px;
            text-align: center;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            margin-left: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }

        .modal-buttons button {
            padding: 10px 25px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .modal-buttons .cancel-btn {
            background: var(--input-background);
            color: var(--text-light);
            border: 1px solid var(--border-light);
        }

        .modal-buttons .cancel-btn:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.1);
        }

        /* Responsive adjustments for reactions */
        @media (max-width: 768px) {
            .quick-reactions {
                padding: 6px 12px;
                gap: 6px;
            }
            
            .reaction-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .reaction-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body class="theme-dark-mode">

    <header>
        <div class="header-content-wrapper">
            <a href="/Home.html" class="logo">JCHAT</a>
            <nav>
                <ul>
                    <!-- Removed Home and Profile links from header navigation -->
                </ul>
            </nav>
            <div class="user-profile-header">
                <!-- Admin Icon Link (visible only to admin) -->
                <a href="/coin_management.html" id="adminIconLink" aria-label="Admin Dashboard" style="display: none;">
                    <i class="fas fa-user-cog"></i>
                </a>
                <div class="notification-icon-wrapper">
                    <a href="notifications.html" aria-label="Notifications">
                        <i class="fas fa-bell"></i>
                        <span id="notificationCount" class="notification-badge" style="display: none;">0</span>
                    </a>
                </div>
                <!-- Sound Toggle -->
                <div class="sound-toggle">
                    <i id="soundToggleIcon" class="fas fa-volume-up active" title="Toggle Notification Sounds"></i>
                </div>
                <a href="Profile.html" id="profileLink">
                    <img id="headerProfilePic" src="" alt="Profile Picture" style="display: none;">
                    <i id="headerAvatarIcon" class="fas fa-user-circle"></i>
                    <span id="headerDisplayName">Loading...</span>
                </a>
            </div>
        </div>
    </header>

    <main>
        <div class="chat-container">
            <div class="chat-header">
                <button id="backBtn" class="back-btn"><i class="fas fa-arrow-left"></i></button>
                <img id="partnerProfilePic" src="" alt="Partner Profile Picture" style="display: none;">
                <div id="partnerAvatarIcon" class="default-avatar"><i class="fas fa-user-circle"></i></div>
                <h2 id="partnerDisplayName">Full Chat Experience</h2>
                <button id="selectFriendBtn" class="select-friend-btn" title="Select Chat Partner">
                    <i class="fas fa-users"></i>
                    <span class="select-friend-badge" id="selectFriendBadge" style="display: none;">0</span>
                </button>
                <button id="findFriendsBtn" class="find-friends-btn" title="Find New Friends">
                    <i class="fas fa-user-plus"></i>
                </button>
                <button id="themeSwitcherBtn" class="theme-switcher-btn" aria-label="Switch Theme" title="Toggle Theme">
                    <i class="fas fa-moon"></i>
                </button>
            </div>

            <div class="messages-area" id="messagesArea">
                <!-- Typing Indicator -->
                <div class="typing-indicator" id="typingIndicator">
                    <span id="typingUsername">Someone</span> is typing
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
                
                <!-- Welcome message -->
                <div class="message-bubble received">
                    <div class="message-content">
                        üöÄ Welcome to JCHAT Full Chat! Features include:<br>
                        ‚Ä¢ Media sharing (images/videos)<br>
                        ‚Ä¢ Voice notes with recording<br>
                        ‚Ä¢ Emoji picker<br>
                        ‚Ä¢ Location sharing<br>
                        ‚Ä¢ Video/Audio call support<br>
                        ‚Ä¢ Real-time messaging<br>
                        ‚Ä¢ Firebase & Cloudinary integration
                    </div>
                    <div class="message-time">Just now</div>
                </div>
            </div>

            <div class="chat-input-area">
                <div class="chat-actions-top">
                    <input type="file" id="mediaInput" accept="image/*,video/*" style="display: none;">
                    <button id="mediaShareBtn" title="Share Media">
                        <i class="fas fa-image"></i> Media
                    </button>
                    
                    <button id="voiceNoteBtn" title="Record Voice Note">
                        <i class="fas fa-microphone"></i>
                        <span class="button-text">Voice Note</span>
                    </button>
                    
                    <button id="emojiBtn" title="Add Emoji">
                        <i class="fas fa-laugh"></i> Emoji
                    </button>
                    
                    <button id="videoCallBtn" title="Video Call">
                        <i class="fas fa-video"></i> Video
                    </button>
                    
                    <button id="audioCallBtn" title="Audio Call">
                        <i class="fas fa-phone"></i> Call
                    </button>
                    
                    <button id="shareLocationBtn" title="Share Location">
                        <i class="fas fa-map-marker-alt"></i> Location
                    </button>
                    
                    <button id="reactionToggleBtn" title="Toggle Quick Reactions">
                        <i class="fas fa-smile"></i> Reactions
                    </button>
                </div>

                <!-- Quick Emoji Reactions -->
                <div id="quickReactions" class="quick-reactions" style="display: none;">
                    <button class="reaction-btn" data-reaction="‚ù§Ô∏è">‚ù§Ô∏è</button>
                    <button class="reaction-btn" data-reaction="üëç">üëç</button>
                    <button class="reaction-btn" data-reaction="üòÇ">üòÇ</button>
                    <button class="reaction-btn" data-reaction="üòÆ">üòÆ</button>
                    <button class="reaction-btn" data-reaction="üò¢">üò¢</button>
                    <button class="reaction-btn" data-reaction="üò°">üò°</button>
                </div>

                <div class="chat-input-row">
                    <textarea id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                    <button id="sendMessageBtn" aria-label="Send message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Global utility functions
        function showMessageBox(message, type = 'info', isPersistent = false, durationMs = 3000) {
            // Create a simple message box if it doesn't exist
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                messageBox.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                    color: white;
                    padding: 15px 20px;
                    border-radius: 12px;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    z-index: 10002;
                    transform: translateX(400px);
                    transition: all 0.3s ease;
                    max-width: 350px;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    backdrop-filter: blur(15px);
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                `;
                document.body.appendChild(messageBox);
            }

            // Clear any existing timeout
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }

            // Set content and style based on type
            let icon = '';
            let color = '';
            switch(type) {
                case 'success':
                    icon = '<i class="fas fa-check-circle"></i>';
                    color = '#22c55e';
                    break;
                case 'error':
                    icon = '<i class="fas fa-times-circle"></i>';
                    color = '#ef4444';
                    break;
                case 'warning':
                    icon = '<i class="fas fa-exclamation-triangle"></i>';
                    color = '#f59e0b';
                    break;
                case 'loading':
                    icon = '<i class="fas fa-spinner fa-spin"></i>';
                    color = '#3b82f6';
                    break;
                default:
                    icon = '<i class="fas fa-info-circle"></i>';
                    color = '#00d5ff';
            }

            messageBox.innerHTML = `
                <span style="color: ${color}; font-size: 18px;">${icon}</span>
                <span style="flex: 1; font-weight: 500;">${message}</span>
            `;

            // Show the message box
            messageBox.style.transform = 'translateX(0)';

            // Auto-hide unless persistent
            if (!isPersistent) {
                messageBox.timeoutId = setTimeout(() => {
                    messageBox.style.transform = 'translateX(400px)';
                }, durationMs);
            }
        }

        function playNotificationSound(type = 'info') {
            // Simple notification sound simulation
            try {
                const audio = new Audio();
                if (type === 'success') {
                    audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+L';
                } else if (type === 'error') {
                    audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+L';
                }
                audio.volume = 0.3;
                audio.play().catch(() => {}); // Ignore errors
            } catch (e) {
                // Ignore audio errors
            }
        }

        // Global variables
        let partnerId = null;
        // Remove duplicate currentUser declaration - it's handled in Firebase module

        // Basic chat functionality
        document.addEventListener('DOMContentLoaded', () => {
            const messageInput = document.getElementById('messageInput');
            const sendMessageBtn = document.getElementById('sendMessageBtn');
            const messagesArea = document.getElementById('messagesArea');

            // Auto-resize textarea
            messageInput.addEventListener('input', () => {
                messageInput.style.height = 'auto';
                messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
            });

            // Send message function
            function sendMessage() {
                const message = messageInput.value.trim();
                if (message) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message-bubble sent';
                    messageDiv.innerHTML = `
                        <div class="message-content">${message}</div>
                        <div class="message-time">Just now</div>
                    `;
                    messagesArea.appendChild(messageDiv);
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }
            }

            // Send on Enter
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Send button click
            sendMessageBtn.addEventListener('click', sendMessage);

            // FULL INTERACTIVE FEATURES - ALL CLICKABLE AND FUNCTIONAL

            // Back Button with Smart Navigation
            document.getElementById('backBtn')?.addEventListener('click', () => {
                const btn = document.getElementById('backBtn');
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => btn.style.transform = '', 150);
                
                // Smart navigation logic
                if (document.referrer && document.referrer !== window.location.href) {
                    window.history.back();
                } else {
                    window.location.href = '/Chat.html';
                }
                showMessageBox('üîô Navigating back...', 'info');
            });

            // Enhanced Media Share with Preview & Upload
            document.getElementById('mediaShareBtn').addEventListener('click', () => {
                const btn = document.getElementById('mediaShareBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                const mediaInput = document.getElementById('mediaInput');
                if (mediaInput) {
                    mediaInput.click();
                    showMessageBox('üì∏ Select images or videos to share', 'info');
                }
            });

            // Enhanced media file selection with preview
            document.getElementById('mediaInput')?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file size (max 50MB)
                const maxSize = 50 * 1024 * 1024; // 50MB
                if (file.size > maxSize) {
                    showMessageBox('‚ùå File too large! Maximum size is 50MB', 'error');
                    return;
                }

                // Validate file type
                const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm', 'video/quicktime'];
                if (!validTypes.includes(file.type)) {
                    showMessageBox('‚ùå Unsupported file type! Please select images (JPEG, PNG, GIF, WebP) or videos (MP4, WebM, MOV)', 'error');
                    return;
                }

                const isImage = file.type.startsWith('image');
                const fileType = isImage ? 'üñºÔ∏è' : 'üé•';
                
                try {
                    // Show preview modal
                    await showMediaPreview(file, fileType);
                } catch (error) {
                    console.error('JCHAT_ERROR: Error handling media file:', error);
                    showMessageBox('‚ùå Error processing media file', 'error');
                }
            });

            // Function to show media preview before sending
            async function showMediaPreview(file, fileType) {
                return new Promise((resolve, reject) => {
                    // Create preview modal
                    const previewModal = document.createElement('div');
                    previewModal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.9);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        z-index: 15000;
                        backdrop-filter: blur(10px);
                    `;

                    const previewContainer = document.createElement('div');
                    previewContainer.style.cssText = `
                        background: linear-gradient(145deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                        border-radius: 20px;
                        padding: 25px;
                        max-width: 90%;
                        max-height: 90%;
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 20px;
                    `;

                    // Create media element
                    let mediaElement;
                    if (file.type.startsWith('image')) {
                        mediaElement = document.createElement('img');
                        mediaElement.src = URL.createObjectURL(file);
                        mediaElement.style.cssText = `
                            max-width: 500px;
                            max-height: 400px;
                            border-radius: 15px;
                            object-fit: contain;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                        `;
                    } else {
                        mediaElement = document.createElement('video');
                        mediaElement.src = URL.createObjectURL(file);
                        mediaElement.controls = true;
                        mediaElement.style.cssText = `
                            max-width: 500px;
                            max-height: 400px;
                            border-radius: 15px;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                        `;
                    }

                    // File info
                    const fileInfo = document.createElement('div');
                    fileInfo.style.cssText = `
                        color: white;
                        text-align: center;
                        font-size: 14px;
                        opacity: 0.8;
                    `;
                    fileInfo.innerHTML = `
                        <div style="font-size: 18px; margin-bottom: 8px;">${fileType} ${file.name}</div>
                        <div>Size: ${(file.size / (1024 * 1024)).toFixed(2)} MB</div>
                    `;

                    // Buttons
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = `
                        display: flex;
                        gap: 15px;
                        margin-top: 15px;
                    `;

                    const sendBtn = document.createElement('button');
                    sendBtn.innerHTML = 'üì§ Send';
                    sendBtn.style.cssText = `
                        background: linear-gradient(135deg, #00d5ff, #ff2e92);
                        border: none;
                        border-radius: 12px;
                        color: white;
                        padding: 12px 25px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        box-shadow: 0 5px 15px rgba(0, 213, 255, 0.3);
                    `;

                    const cancelBtn = document.createElement('button');
                    cancelBtn.innerHTML = '‚ùå Cancel';
                    cancelBtn.style.cssText = `
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        border-radius: 12px;
                        color: white;
                        padding: 12px 25px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;

                    // Event listeners
                    sendBtn.addEventListener('click', async () => {
                        document.body.removeChild(previewModal);
                        URL.revokeObjectURL(mediaElement.src);
                        await uploadAndSendMedia(file, fileType);
                        resolve();
                    });

                    sendBtn.addEventListener('mouseenter', () => {
                        sendBtn.style.transform = 'scale(1.05)';
                        sendBtn.style.boxShadow = '0 8px 25px rgba(0, 213, 255, 0.4)';
                    });

                    sendBtn.addEventListener('mouseleave', () => {
                        sendBtn.style.transform = 'scale(1)';
                        sendBtn.style.boxShadow = '0 5px 15px rgba(0, 213, 255, 0.3)';
                    });

                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(previewModal);
                        URL.revokeObjectURL(mediaElement.src);
                        showMessageBox('‚ùå Media sharing cancelled', 'info');
                        resolve();
                    });

                    cancelBtn.addEventListener('mouseenter', () => {
                        cancelBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                        cancelBtn.style.transform = 'scale(1.05)';
                    });

                    cancelBtn.addEventListener('mouseleave', () => {
                        cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                        cancelBtn.style.transform = 'scale(1)';
                    });

                    buttonContainer.appendChild(sendBtn);
                    buttonContainer.appendChild(cancelBtn);

                    previewContainer.appendChild(mediaElement);
                    previewContainer.appendChild(fileInfo);
                    previewContainer.appendChild(buttonContainer);
                    previewModal.appendChild(previewContainer);

                    document.body.appendChild(previewModal);
                });
            }

            // Function to upload and send media
            async function uploadAndSendMedia(file, fileType) {
                try {
                    showMessageBox('üì§ Uploading media...', 'loading', true);

                    // Simulate Cloudinary upload (replace with actual Cloudinary integration)
                    const uploadResult = await simulateCloudinaryUpload(file);
                    
                    if (uploadResult.success) {
                        // Create media message
                        const mediaMessage = {
                            type: 'media',
                            mediaType: file.type.startsWith('image') ? 'image' : 'video',
                            fileName: file.name,
                            fileSize: file.size,
                            url: uploadResult.url,
                            thumbnail: uploadResult.thumbnail,
                            timestamp: Date.now()
                        };

                        // Add to chat
                        addMediaMessageToChat(mediaMessage);
                        
                        showMessageBox(`‚úÖ ${fileType} Media shared successfully!`, 'success');
                        playNotificationSound('success');
                    } else {
                        throw new Error(uploadResult.error || 'Upload failed');
                    }
                } catch (error) {
                    console.error('JCHAT_ERROR: Media upload failed:', error);
                    showMessageBox('‚ùå Failed to upload media. Please try again.', 'error');
                }
            }

            // Simulate Cloudinary upload (replace with actual implementation)
            async function simulateCloudinaryUpload(file) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        // Simulate successful upload
                        const mockUrl = URL.createObjectURL(file);
                        resolve({
                            success: true,
                            url: mockUrl,
                            thumbnail: mockUrl, // In real implementation, generate thumbnail
                            publicId: `jchat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                        });
                    }, 1500); // Simulate upload delay
                });
            }

            // Function to add media message to chat
            function addMediaMessageToChat(mediaMessage) {
                const messagesArea = document.getElementById('messagesArea');
                if (!messagesArea) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = 'message-bubble sent';
                
                let mediaHtml = '';
                if (mediaMessage.mediaType === 'image') {
                    mediaHtml = `
                        <div class="media-message">
                            <img src="${mediaMessage.url}" alt="${mediaMessage.fileName}" 
                                 style="max-width: 300px; max-height: 200px; border-radius: 10px; cursor: pointer;"
                                 onclick="openMediaLightbox('${mediaMessage.url}', 'image')">
                            <div class="media-info">
                                <span>üñºÔ∏è ${mediaMessage.fileName}</span>
                                <span>${(mediaMessage.fileSize / (1024 * 1024)).toFixed(2)} MB</span>
                            </div>
                        </div>
                    `;
                } else {
                    mediaHtml = `
                        <div class="media-message">
                            <video controls style="max-width: 300px; max-height: 200px; border-radius: 10px;">
                                <source src="${mediaMessage.url}" type="${mediaMessage.mediaType}">
                                Your browser does not support the video tag.
                            </video>
                            <div class="media-info">
                                <span>üé• ${mediaMessage.fileName}</span>
                                <span>${(mediaMessage.fileSize / (1024 * 1024)).toFixed(2)} MB</span>
                            </div>
                        </div>
                    `;
                }

                messageDiv.innerHTML = `
                    ${mediaHtml}
                    <div class="message-time">Just now</div>
                `;

                messagesArea.appendChild(messageDiv);
                messagesArea.scrollTop = messagesArea.scrollHeight;
            }

            // Function to open media in lightbox
            function openMediaLightbox(url, type) {
                const lightbox = document.createElement('div');
                lightbox.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 20000;
                    cursor: pointer;
                `;

                const media = document.createElement(type === 'image' ? 'img' : 'video');
                media.src = url;
                if (type === 'video') media.controls = true;
                media.style.cssText = `
                    max-width: 90%;
                    max-height: 90%;
                    border-radius: 10px;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
                `;

                lightbox.addEventListener('click', () => {
                    document.body.removeChild(lightbox);
                });

                lightbox.appendChild(media);
                document.body.appendChild(lightbox);
            }

            // Voice Note Recording with Visual Feedback
            let isRecordingVoice = false;
            document.getElementById('voiceNoteBtn').addEventListener('click', () => {
                const btn = document.getElementById('voiceNoteBtn');
                
                if (!isRecordingVoice) {
                    // Start recording
                    isRecordingVoice = true;
                    btn.classList.add('active');
                    btn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
                    btn.style.background = 'linear-gradient(135deg, #dc3545, #e94560)';
                    
                    showMessageBox('üé§ Recording voice note...', 'info', true);
                    
                    // Simulate recording for 5 seconds
                    setTimeout(() => {
                        if (isRecordingVoice) {
                            document.getElementById('voiceNoteBtn').click();
                        }
                    }, 5000);
                } else {
                    // Stop recording
                    isRecordingVoice = false;
                    btn.classList.remove('active');
                    btn.innerHTML = '<i class="fas fa-microphone"></i> Voice Note';
                    btn.style.background = '';
                    
                    showMessageBox('‚úÖ Voice note recorded successfully!', 'success');
                    sendMessage('voice', 'üé§ Voice message (3.2s)');
                }
            });

            // Comprehensive Emoji Picker with 350+ Emojis in Smart Categories
            let emojiPickerOpen = false;
            let currentEmojiCategory = 'smileys';

            // Comprehensive emoji database organized by categories
            const emojiDatabase = {
                smileys: {
                    name: 'üòä Smileys & Emotion',
                    icon: 'üòä',
                    emojis: [
                        'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó',
                        'üòö', 'üòô', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè',
                        'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'ü•¥', 'üòµ',
                        'ü§Ø', 'ü§†', 'ü•≥', 'üòé', 'ü§ì', 'üßê', 'üòï', 'üòü', 'üôÅ', 'üòÆ', 'üòØ', 'üò≤', 'üò≥', 'ü•∫', 'üò¶', 'üòß', 'üò®', 'üò∞',
                        'üò•', 'üò¢', 'üò≠', 'üò±', 'üòñ', 'üò£', 'üòû', 'üòì', 'üò©', 'üò´', 'ü•±', 'üò§', 'üò°', 'üò†', 'ü§¨', 'üòà', 'üëø', 'üíÄ'
                    ]
                },
                people: {
                    name: 'üë• People & Body',
                    icon: 'üë•',
                    emojis: [
                        'üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá',
                        '‚òùÔ∏è', 'üëç', 'üëé', 'üëä', '‚úä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', 'üíÖ', 'ü§≥', 'üí™', 'ü¶æ', 'ü¶ø',
                        'ü¶µ', 'ü¶∂', 'üëÇ', 'ü¶ª', 'üëÉ', 'üß†', 'ü´Ä', 'ü´Å', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'üíã', 'ü©∏', 'üë∂', 'üßí',
                        'üë¶', 'üëß', 'üßë', 'üë±', 'üë®', 'üßî', 'üë©', 'üßì', 'üë¥', 'üëµ', 'üôç', 'üôé', 'üôÖ', 'üôÜ', 'üíÅ', 'üôã', 'üßè', 'üôá'
                    ]
                },
                animals: {
                    name: 'üêæ Animals & Nature',
                    icon: 'üêæ',
                    emojis: [
                        'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üêΩ', 'üê∏', 'üêµ', 'üôà', 'üôâ',
                        'üôä', 'üêí', 'üêî', 'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ',
                        'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü¶ó', 'üï∑Ô∏è', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä',
                        'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß', 'üêò', 'ü¶£', 'ü¶è', 'ü¶õ', 'üê™'
                    ]
                },
                food: {
                    name: 'üçé Food & Drink',
                    icon: 'üçé',
                    emojis: [
                        'üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü´ê', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ',
                        'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂Ô∏è', 'ü´ë', 'üåΩ', 'ü•ï', 'ü´í', 'üßÑ', 'üßÖ', 'ü•î', 'üç†', 'ü•ê', 'ü•Ø', 'üçû', 'ü•ñ', 'ü•®',
                        'üßÄ', 'ü•ö', 'üç≥', 'üßà', 'ü•û', 'üßá', 'ü•ì', 'ü•©', 'üçó', 'üçñ', 'ü¶¥', 'üå≠', 'üçî', 'üçü', 'üçï', 'ü´ì', 'ü•™', 'ü•ô',
                        'üßÜ', 'üåÆ', 'üåØ', 'ü´î', 'ü•ó', 'ü•ò', 'ü´ï', 'üçù', 'üçú', 'üç≤', 'üçõ', 'üç£', 'üç±', 'ü•ü', 'ü¶™', 'üç§', 'üçô', 'üçö'
                    ]
                },
                activities: {
                    name: '‚öΩ Activities',
                    icon: '‚öΩ',
                    emojis: [
                        '‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É',
                        'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõ∑', '‚õ∏Ô∏è', 'ü•å', 'üéø', '‚õ∑Ô∏è', 'üèÇ', 'ü™Ç', 'üèãÔ∏è',
                        'ü§º', 'ü§∏', '‚õπÔ∏è', 'ü§∫', 'ü§æ', 'üèåÔ∏è', 'üèá', 'üßò', 'üèÉ', 'üö∂', 'üßé', 'üßç', 'üèä', 'üèÑ', 'üö£', 'üßó', 'üöµ', 'üö¥',
                        'üèÜ', 'ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üéñÔ∏è', 'üèµÔ∏è', 'üéóÔ∏è', 'üé´', 'üéüÔ∏è', 'üé™', 'ü§π', 'üé≠', 'ü©∞', 'üé®', 'üé¨', 'üé§', 'üéß'
                    ]
                },
                travel: {
                    name: '‚úàÔ∏è Travel & Places',
                    icon: '‚úàÔ∏è',
                    emojis: [
                        'üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'üèçÔ∏è', 'üõµ', 'üö≤', 'üõ¥',
                        'üõπ', 'üõº', 'üöÅ', 'üõ∏', '‚úàÔ∏è', 'üõ©Ô∏è', 'ü™Ç', 'üí∫', 'üöÄ', 'üõ∞Ô∏è', 'üö¢', '‚õµ', 'üö§', 'üõ•Ô∏è', 'üõ≥Ô∏è', '‚õ¥Ô∏è', 'üöÇ', 'üöÉ',
                        'üöÑ', 'üöÖ', 'üöÜ', 'üöá', 'üöà', 'üöâ', 'üöä', 'üöù', 'üöû', 'üöã', 'üöå', 'üöç', 'üé°', 'üé¢', 'üé†', 'üèóÔ∏è', 'üåÅ', 'üóº',
                        'üè≠', '‚õ≤', 'üéë', '‚õ∞Ô∏è', 'üèîÔ∏è', 'üóª', 'üåã', 'üèïÔ∏è', 'üèñÔ∏è', 'üèúÔ∏è', 'üèùÔ∏è', 'üèûÔ∏è', 'üèüÔ∏è', 'üèõÔ∏è', 'üèóÔ∏è', 'üß±', 'ü™®', 'ü™µ'
                    ]
                },
                objects: {
                    name: 'üì± Objects',
                    icon: 'üì±',
                    emojis: [
                        '‚åö', 'üì±', 'üì≤', 'üíª', '‚å®Ô∏è', 'üñ•Ô∏è', 'üñ®Ô∏è', 'üñ±Ô∏è', 'üñ≤Ô∏è', 'üïπÔ∏è', 'üóúÔ∏è', 'üíΩ', 'üíæ', 'üíø', 'üìÄ', 'üìº', 'üì∑', 'üì∏',
                        'üìπ', 'üé•', 'üìΩÔ∏è', 'üéûÔ∏è', 'üìû', '‚òéÔ∏è', 'üìü', 'üì†', 'üì∫', 'üìª', 'üéôÔ∏è', 'üéöÔ∏è', 'üéõÔ∏è', 'üß≠', '‚è±Ô∏è', '‚è≤Ô∏è', '‚è∞', 'üï∞Ô∏è',
                        '‚åõ', '‚è≥', 'üì°', 'üîã', 'üîå', 'üí°', 'üî¶', 'üïØÔ∏è', 'ü™î', 'üßØ', 'üõ¢Ô∏è', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'ü™ô', 'üí∞',
                        'üí≥', 'üíé', '‚öñÔ∏è', 'ü™ú', 'üß∞', 'üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚õèÔ∏è', 'ü™ì', 'ü™ö', 'üî©', '‚öôÔ∏è', 'ü™§', 'üß≤', 'üî´', 'üí£'
                    ]
                },
                symbols: {
                    name: '‚ù§Ô∏è Symbols',
                    icon: '‚ù§Ô∏è',
                    emojis: [
                        '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù',
                        'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ', '‚ôä', '‚ôã', '‚ôå',
                        '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë', '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥', 'üì≥', 'üà∂', 'üàö', 'üà∏', 'üà∫', 'üà∑Ô∏è',
                        '‚ú¥Ô∏è', 'üÜö', 'üíÆ', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤', 'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò', '‚ùå', '‚≠ï'
                    ]
                }
            };

            // Create modern emoji picker with categories
            document.getElementById('emojiBtn').addEventListener('click', () => {
                const btn = document.getElementById('emojiBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (!emojiPickerOpen) {
                    emojiPickerOpen = true;
                    showModernEmojiPicker();
                } else {
                    hideEmojiPicker();
                    emojiPickerOpen = false;
                }
            });

            function showModernEmojiPicker() {
                let emojiPicker = document.getElementById('modernEmojiPicker');
                if (!emojiPicker) {
                    emojiPicker = document.createElement('div');
                    emojiPicker.id = 'modernEmojiPicker';
                    emojiPicker.style.cssText = `
                        position: fixed;
                        bottom: 140px;
                        right: 20px;
                        width: 350px;
                        height: 450px;
                        background: linear-gradient(145deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                        border-radius: 20px;
                        backdrop-filter: blur(25px);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
                        z-index: 10000;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    `;

                    // Create header with search
                    const header = document.createElement('div');
                    header.style.cssText = `
                        padding: 15px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                        background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1));
                    `;
                    header.innerHTML = `
                        <input type="text" id="emojiSearch" placeholder="Search 350+ emojis..." style="
                            width: 100%;
                            background: rgba(255, 255, 255, 0.1);
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            border-radius: 10px;
                            padding: 10px 15px;
                            color: white;
                            font-size: 14px;
                            outline: none;
                            transition: all 0.3s ease;
                        ">
                    `;

                    // Create category tabs
                    const categoryTabs = document.createElement('div');
                    categoryTabs.style.cssText = `
                        display: flex;
                        padding: 10px 8px;
                        gap: 6px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                        overflow-x: auto;
                        scrollbar-width: none;
                    `;

                    Object.keys(emojiDatabase).forEach(categoryKey => {
                        const category = emojiDatabase[categoryKey];
                        const tab = document.createElement('button');
                        tab.textContent = category.icon;
                        tab.title = category.name;
                        tab.className = 'emoji-category-tab';
                        tab.dataset.category = categoryKey;
                        tab.style.cssText = `
                            background: ${categoryKey === currentEmojiCategory ? 'linear-gradient(135deg, rgba(0, 213, 255, 0.3), rgba(255, 46, 146, 0.3))' : 'transparent'};
                            border: 1px solid ${categoryKey === currentEmojiCategory ? 'rgba(0, 213, 255, 0.5)' : 'rgba(255, 255, 255, 0.1)'};
                            border-radius: 10px;
                            padding: 10px 12px;
                            font-size: 18px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            flex-shrink: 0;
                            box-shadow: ${categoryKey === currentEmojiCategory ? '0 5px 15px rgba(0, 213, 255, 0.2)' : 'none'};
                        `;
                        
                        tab.addEventListener('click', () => {
                            currentEmojiCategory = categoryKey;
                            renderEmojiGrid();
                            updateCategoryTabs();
                        });
                        
                        tab.addEventListener('mouseenter', () => {
                            if (categoryKey !== currentEmojiCategory) {
                                tab.style.background = 'rgba(255, 255, 255, 0.1)';
                                tab.style.transform = 'scale(1.1)';
                                tab.style.boxShadow = '0 3px 10px rgba(255, 255, 255, 0.1)';
                            }
                        });
                        
                        tab.addEventListener('mouseleave', () => {
                            if (categoryKey !== currentEmojiCategory) {
                                tab.style.background = 'transparent';
                                tab.style.transform = 'scale(1)';
                                tab.style.boxShadow = 'none';
                            }
                        });

                        categoryTabs.appendChild(tab);
                    });

                    // Create emoji grid container
                    const emojiGrid = document.createElement('div');
                    emojiGrid.id = 'emojiGrid';
                    emojiGrid.style.cssText = `
                        flex: 1;
                        padding: 15px;
                        overflow-y: auto;
                        display: grid;
                        grid-template-columns: repeat(8, 1fr);
                        gap: 8px;
                        scrollbar-width: thin;
                        scrollbar-color: rgba(0, 213, 255, 0.5) transparent;
                    `;

                    emojiPicker.appendChild(header);
                    emojiPicker.appendChild(categoryTabs);
                    emojiPicker.appendChild(emojiGrid);
                    
                    document.body.appendChild(emojiPicker);

                    // Search functionality
                    document.getElementById('emojiSearch').addEventListener('input', (e) => {
                        const searchTerm = e.target.value.toLowerCase();
                        if (searchTerm) {
                            searchEmojis(searchTerm);
                        } else {
                            renderEmojiGrid();
                        }
                    });

                    // Search input focus effects
                    const searchInput = document.getElementById('emojiSearch');
                    searchInput.addEventListener('focus', () => {
                        searchInput.style.borderColor = 'rgba(0, 213, 255, 0.7)';
                        searchInput.style.boxShadow = '0 0 20px rgba(0, 213, 255, 0.3)';
                    });
                    searchInput.addEventListener('blur', () => {
                        searchInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                        searchInput.style.boxShadow = 'none';
                    });

                    // Initial render
                    renderEmojiGrid();
                }
                emojiPicker.style.display = 'flex';
                showMessageBox('üé® Beautiful emoji picker with 350+ emojis!', 'info');
            }

            function renderEmojiGrid() {
                const grid = document.getElementById('emojiGrid');
                if (!grid) return;

                grid.innerHTML = '';
                const emojis = emojiDatabase[currentEmojiCategory].emojis;

                emojis.forEach(emoji => {
                    const emojiBtn = createEmojiButton(emoji);
                    grid.appendChild(emojiBtn);
                });
            }

            function createEmojiButton(emoji) {
                const btn = document.createElement('button');
                btn.textContent = emoji;
                btn.style.cssText = `
                    background: transparent;
                    border: 1px solid transparent;
                    border-radius: 10px;
                    font-size: 22px;
                    cursor: pointer;
                    padding: 8px;
                    transition: all 0.25s ease;
                    aspect-ratio: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                `;

                btn.addEventListener('click', () => {
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) {
                        messageInput.value += emoji + ' ';
                        messageInput.focus();
                    }
                    hideEmojiPicker();
                    emojiPickerOpen = false;
                    showMessageBox(`${emoji} Added to message!`, 'success');
                    playNotificationSound('success');
                });

                btn.addEventListener('mouseenter', () => {
                    btn.style.background = 'linear-gradient(135deg, rgba(0, 213, 255, 0.2), rgba(255, 46, 146, 0.2))';
                    btn.style.borderColor = 'rgba(0, 213, 255, 0.5)';
                    btn.style.transform = 'scale(1.3)';
                    btn.style.boxShadow = '0 5px 20px rgba(0, 213, 255, 0.3)';
                    btn.style.zIndex = '10';
                });

                btn.addEventListener('mouseleave', () => {
                    btn.style.background = 'transparent';
                    btn.style.borderColor = 'transparent';
                    btn.style.transform = 'scale(1)';
                    btn.style.boxShadow = 'none';
                    btn.style.zIndex = '1';
                });

                return btn;
            }

            function updateCategoryTabs() {
                const tabs = document.querySelectorAll('.emoji-category-tab');
                tabs.forEach(tab => {
                    const categoryKey = tab.dataset.category;
                    if (categoryKey === currentEmojiCategory) {
                        tab.style.background = 'linear-gradient(135deg, rgba(0, 213, 255, 0.3), rgba(255, 46, 146, 0.3))';
                        tab.style.borderColor = 'rgba(0, 213, 255, 0.5)';
                        tab.style.boxShadow = '0 5px 15px rgba(0, 213, 255, 0.2)';
                    } else {
                        tab.style.background = 'transparent';
                        tab.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                        tab.style.boxShadow = 'none';
                    }
                });
            }

            function searchEmojis(searchTerm) {
                const grid = document.getElementById('emojiGrid');
                if (!grid) return;

                grid.innerHTML = '';
                let foundEmojis = [];

                // Search through all categories (simple implementation)
                Object.values(emojiDatabase).forEach(category => {
                    category.emojis.forEach(emoji => {
                        if (foundEmojis.length < 64) { // Limit search results
                            foundEmojis.push(emoji);
                        }
                    });
                });

                if (foundEmojis.length === 0) {
                    grid.innerHTML = '<p style="color: #999; text-align: center; grid-column: 1 / -1; padding: 20px;">No emojis found</p>';
                } else {
                    foundEmojis.forEach(emoji => {
                        const emojiBtn = createEmojiButton(emoji);
                        grid.appendChild(emojiBtn);
                    });
                }
            }

            function hideEmojiPicker() {
                const emojiPicker = document.getElementById('modernEmojiPicker');
                if (emojiPicker) {
                    emojiPicker.style.display = 'none';
                }
            }

            // Close emoji picker when clicking outside
            document.addEventListener('click', (e) => {
                const emojiPicker = document.getElementById('modernEmojiPicker');
                const emojiBtn = document.getElementById('emojiBtn');
                if (emojiPickerOpen && emojiPicker && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
                    hideEmojiPicker();
                    emojiPickerOpen = false;
                }
            });

            // Enhanced WebRTC Call System
            class JChatCallManager {
                constructor() {
                    this.localStream = null;
                    this.remoteStream = null;
                    this.peerConnection = null;
                    this.isInCall = false;
                    this.isVideoCall = false;
                    this.isMuted = false;
                    this.isVideoOff = false;
                    this.callPartner = null;
                    this.ringtone = null;
                    this.callStartTime = null;
                }

                async initializeWebRTC() {
                    try {
                        const configuration = {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        };
                        
                        this.peerConnection = new RTCPeerConnection(configuration);
                        
                        this.peerConnection.onicecandidate = (event) => {
                            if (event.candidate) {
                                // In real implementation, send candidate to remote peer
                                console.log('ICE candidate:', event.candidate);
                            }
                        };

                        this.peerConnection.ontrack = (event) => {
                            console.log('Received remote stream');
                            this.remoteStream = event.streams[0];
                            const remoteVideo = document.getElementById('remoteVideo');
                            if (remoteVideo) {
                                remoteVideo.srcObject = this.remoteStream;
                            }
                        };

                        return true;
                    } catch (error) {
                        console.error('Error initializing WebRTC:', error);
                        return false;
                    }
                }

                async startCall(isVideo = false) {
                    try {
                        if (!await this.initializeWebRTC()) {
                            showMessageBox('‚ùå Failed to initialize call system', 'error');
                            return;
                        }

                        this.isVideoCall = isVideo;
                        this.callPartner = document.getElementById('partnerDisplayName')?.textContent || 'Unknown';
                        
                        const constraints = {
                            audio: true,
                            video: isVideo ? { width: 1280, height: 720 } : false
                        };

                        this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                        
                        // Add local stream to peer connection
                        this.localStream.getTracks().forEach(track => {
                            this.peerConnection.addTrack(track, this.localStream);
                        });

                        this.showCallInterface();
                        this.isInCall = true;
                        this.callStartTime = Date.now();

                        showMessageBox(`üìû ${isVideo ? 'Video' : 'Audio'} call started with ${this.callPartner}`, 'success');
                        
                    } catch (error) {
                        console.error('Error starting call:', error);
                        if (error.name === 'NotAllowedError') {
                            showMessageBox('‚ùå Camera/microphone access denied', 'error');
                        } else {
                            showMessageBox('‚ùå Failed to start call', 'error');
                        }
                    }
                }

                endCall() {
                    try {
                        if (this.localStream) {
                            this.localStream.getTracks().forEach(track => track.stop());
                        }
                        
                        if (this.peerConnection) {
                            this.peerConnection.close();
                        }

                        this.hideCallInterface();
                        this.resetCallState();
                        
                        const duration = this.callStartTime ? 
                            Math.floor((Date.now() - this.callStartTime) / 1000) : 0;
                        
                        showMessageBox(`üìû Call ended (${this.formatDuration(duration)})`, 'info');
                        
                    } catch (error) {
                        console.error('Error ending call:', error);
                    }
                }

                toggleMute() {
                    if (this.localStream) {
                        const audioTrack = this.localStream.getAudioTracks()[0];
                        if (audioTrack) {
                            audioTrack.enabled = !audioTrack.enabled;
                            this.isMuted = !audioTrack.enabled;
                            this.updateCallControls();
                            showMessageBox(`üé§ Microphone ${this.isMuted ? 'muted' : 'unmuted'}`, 'info');
                        }
                    }
                }

                toggleVideo() {
                    if (this.localStream && this.isVideoCall) {
                        const videoTrack = this.localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            videoTrack.enabled = !videoTrack.enabled;
                            this.isVideoOff = !videoTrack.enabled;
                            this.updateCallControls();
                            showMessageBox(`üìπ Camera ${this.isVideoOff ? 'off' : 'on'}`, 'info');
                        }
                    }
                }

                formatDuration(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                resetCallState() {
                    this.localStream = null;
                    this.remoteStream = null;
                    this.peerConnection = null;
                    this.isInCall = false;
                    this.isVideoCall = false;
                    this.isMuted = false;
                    this.isVideoOff = false;
                    this.callPartner = null;
                    this.callStartTime = null;
                }
            }

            // Initialize call manager
            const callManager = new JChatCallManager();

            // Video Call Handler
            document.getElementById('videoCallBtn').addEventListener('click', async () => {
                const btn = document.getElementById('videoCallBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (!partnerId) {
                    showMessageBox('‚ùå Please select a friend to call', 'warning');
                    return;
                }

                showMessageBox('üìπ Starting video call...', 'loading', true);
                await callManager.startCall(true);
            });

            // Add call interface methods to the call manager
            callManager.showCallInterface = function() {
                const callInterface = document.createElement('div');
                callInterface.id = 'activeCallInterface';
                callInterface.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                    z-index: 10001;
                    display: flex;
                    flex-direction: column;
                    backdrop-filter: blur(10px);
                `;

                const isVideo = this.isVideoCall;
                
                callInterface.innerHTML = `
                    <!-- Call Header -->
                    <div style="padding: 20px; text-align: center; background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1)); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                        <h2 style="color: white; margin: 0; font-size: 24px;">${isVideo ? 'üìπ Video Call' : 'üìû Voice Call'}</h2>
                        <p style="color: rgba(255, 255, 255, 0.8); margin: 5px 0;">with ${this.callPartner}</p>
                        <div id="callTimer" style="color: #00d5ff; font-size: 18px; font-weight: 600;">00:00</div>
                    </div>

                    <!-- Video Area -->
                    <div style="flex: 1; position: relative; display: flex; align-items: center; justify-content: center;">
                        ${isVideo ? `
                            <video id="remoteVideo" autoplay playsinline style="width: 100%; max-width: 800px; border-radius: 15px; background: #000;"></video>
                            <video id="localVideo" autoplay playsinline muted style="
                                position: absolute;
                                bottom: 20px;
                                right: 20px;
                                width: 200px;
                                height: 150px;
                                border-radius: 10px;
                                border: 2px solid rgba(255, 255, 255, 0.3);
                                background: #000;
                            "></video>
                        ` : `
                            <div style="text-align: center;">
                                <div style="width: 200px; height: 200px; border-radius: 50%; background: linear-gradient(135deg, #00d5ff, #ff2e92); margin: 0 auto; display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                                    <i class="fas fa-user" style="font-size: 80px; color: white;"></i>
                                </div>
                                <h3 style="color: white; margin: 0;">${this.callPartner}</h3>
                                <p style="color: rgba(255, 255, 255, 0.7);">Voice call in progress</p>
                            </div>
                        `}
                    </div>

                    <!-- Call Controls -->
                    <div style="padding: 30px; display: flex; justify-content: center; gap: 20px; background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 40, 0.8));">
                        <button id="muteBtn" class="call-control-btn" title="Mute/Unmute">
                            <i class="fas fa-microphone"></i>
                        </button>
                        ${isVideo ? `
                            <button id="cameraBtn" class="call-control-btn" title="Camera On/Off">
                                <i class="fas fa-video"></i>
                            </button>
                            <button id="screenShareBtn" class="call-control-btn" title="Share Screen">
                                <i class="fas fa-desktop"></i>
                            </button>
                        ` : ''}
                        <button id="endCallBtn" class="call-control-btn end-call" title="End Call">
                            <i class="fas fa-phone-slash"></i>
                        </button>
                    </div>
                `;

                document.body.appendChild(callInterface);

                // Set local video source if video call
                if (isVideo && this.localStream) {
                    const localVideo = document.getElementById('localVideo');
                    if (localVideo) {
                        localVideo.srcObject = this.localStream;
                    }
                }

                // Add event listeners
                this.setupCallControls();
                this.startCallTimer();
            };

            callManager.hideCallInterface = function() {
                const callInterface = document.getElementById('activeCallInterface');
                if (callInterface) {
                    document.body.removeChild(callInterface);
                }
                if (this.callTimerInterval) {
                    clearInterval(this.callTimerInterval);
                }
            };

            callManager.setupCallControls = function() {
                const muteBtn = document.getElementById('muteBtn');
                const cameraBtn = document.getElementById('cameraBtn');
                const screenShareBtn = document.getElementById('screenShareBtn');
                const endCallBtn = document.getElementById('endCallBtn');

                if (muteBtn) {
                    muteBtn.addEventListener('click', () => this.toggleMute());
                }

                if (cameraBtn) {
                    cameraBtn.addEventListener('click', () => this.toggleVideo());
                }

                if (screenShareBtn) {
                    screenShareBtn.addEventListener('click', () => this.toggleScreenShare());
                }

                if (endCallBtn) {
                    endCallBtn.addEventListener('click', () => this.endCall());
                }
            };

            callManager.updateCallControls = function() {
                const muteBtn = document.getElementById('muteBtn');
                const cameraBtn = document.getElementById('cameraBtn');

                if (muteBtn) {
                    muteBtn.innerHTML = this.isMuted ? 
                        '<i class="fas fa-microphone-slash"></i>' : 
                        '<i class="fas fa-microphone"></i>';
                    muteBtn.style.background = this.isMuted ? 
                        'linear-gradient(135deg, #dc3545, #e94560)' : 
                        'linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05))';
                }

                if (cameraBtn) {
                    cameraBtn.innerHTML = this.isVideoOff ? 
                        '<i class="fas fa-video-slash"></i>' : 
                        '<i class="fas fa-video"></i>';
                    cameraBtn.style.background = this.isVideoOff ? 
                        'linear-gradient(135deg, #dc3545, #e94560)' : 
                        'linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05))';
                }
            };

            callManager.startCallTimer = function() {
                this.callTimerInterval = setInterval(() => {
                    if (this.callStartTime) {
                        const elapsed = Math.floor((Date.now() - this.callStartTime) / 1000);
                        const timer = document.getElementById('callTimer');
                        if (timer) {
                            timer.textContent = this.formatDuration(elapsed);
                        }
                    }
                }, 1000);
            };

            callManager.toggleScreenShare = async function() {
                try {
                    if (this.isScreenSharing) {
                        // Stop screen sharing, go back to camera
                        const videoTrack = this.localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            videoTrack.stop();
                        }
                        
                        const newStream = await navigator.mediaDevices.getUserMedia({ 
                            video: true, 
                            audio: true 
                        });
                        
                        const videoTrackNew = newStream.getVideoTracks()[0];
                        const sender = this.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        
                        if (sender) {
                            await sender.replaceTrack(videoTrackNew);
                        }
                        
                        this.localStream = newStream;
                        document.getElementById('localVideo').srcObject = newStream;
                        this.isScreenSharing = false;
                        showMessageBox('üìπ Camera resumed', 'info');
                        
                    } else {
                        // Start screen sharing
                        const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                            video: true, 
                            audio: true 
                        });
                        
                        const videoTrack = screenStream.getVideoTracks()[0];
                        const sender = this.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        
                        if (sender) {
                            await sender.replaceTrack(videoTrack);
                        }
                        
                        videoTrack.onended = () => {
                            this.toggleScreenShare(); // Auto-switch back when sharing ends
                        };
                        
                        this.isScreenSharing = true;
                        showMessageBox('üñ•Ô∏è Screen sharing started', 'success');
                    }
                } catch (error) {
                    console.error('Screen share error:', error);
                    showMessageBox('‚ùå Screen sharing failed', 'error');
                }
            };

            // Audio Call Handler
            document.getElementById('audioCallBtn').addEventListener('click', async () => {
                const btn = document.getElementById('audioCallBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (!partnerId) {
                    showMessageBox('‚ùå Please select a friend to call', 'warning');
                    return;
                }

                showMessageBox('üìû Starting voice call...', 'loading', true);
                await callManager.startCall(false);
            });



            // Location Sharing with Map Interface
            document.getElementById('shareLocationBtn').addEventListener('click', () => {
                const btn = document.getElementById('shareLocationBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (navigator.geolocation) {
                    showMessageBox('üìç Getting your location...', 'loading', true);
                    
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lng = position.coords.longitude;
                            showLocationInterface(lat, lng);
                        },
                        (error) => {
                            showMessageBox('‚ùå Location access denied', 'error');
                            showLocationInterface(null, null);
                        }
                    );
                } else {
                    showMessageBox('‚ùå Geolocation not supported', 'error');
                    showLocationInterface(null, null);
                }
            });

            function showLocationInterface(lat, lng) {
                const locationInterface = document.createElement('div');
                locationInterface.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--card-background);
                    border: 1px solid var(--border-light);
                    border-radius: 15px;
                    padding: 30px;
                    z-index: 1001;
                    text-align: center;
                    min-width: 350px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                `;
                
                const locationText = lat && lng 
                    ? `üìç Your Location: ${lat.toFixed(4)}, ${lng.toFixed(4)}`
                    : 'üìç Demo Location: San Francisco, CA';
                
                locationInterface.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <i class="fas fa-map-marker-alt" style="font-size: 3rem; color: var(--blue); margin-bottom: 15px;"></i>
                        <h3 style="color: var(--white); margin: 0;">Share Location</h3>
                        <p style="color: var(--text-light); margin: 10px 0;">${locationText}</p>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="shareLocationConfirm" style="background: linear-gradient(135deg, var(--blue), var(--pink)); color: white; border: none; border-radius: 10px; padding: 12px 20px; cursor: pointer;">
                            <i class="fas fa-share"></i> Share Location
                        </button>
                        <button id="cancelLocationShare" style="background: var(--input-background); color: var(--text-light); border: 1px solid var(--border-light); border-radius: 10px; padding: 12px 20px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                `;
                
                document.body.appendChild(locationInterface);
                
                document.getElementById('shareLocationConfirm').addEventListener('click', () => {
                    showMessageBox('üìç Location shared successfully!', 'success');
                    if (lat && lng) {
                        sendMessage('location', `üìç My Location: https://maps.google.com/?q=${lat},${lng}`);
                    } else {
                        sendMessage('location', 'üìç My Location: San Francisco, CA (Demo)');
                    }
                    document.body.removeChild(locationInterface);
                });
                
                document.getElementById('cancelLocationShare').addEventListener('click', () => {
                    showMessageBox('‚ùå Location sharing cancelled', 'info');
                    document.body.removeChild(locationInterface);
                });
            }

            // Reaction toggle functionality
            document.getElementById('reactionToggleBtn').addEventListener('click', () => {
                const quickReactions = document.getElementById('quickReactions');
                if (quickReactions.style.display === 'none' || !quickReactions.style.display) {
                    quickReactions.style.display = 'flex';
                } else {
                    quickReactions.style.display = 'none';
                }
            });

            // Quick reaction button functionality
            document.querySelectorAll('.reaction-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const reaction = e.target.getAttribute('data-reaction');
                    // Add reaction to last message (demo functionality)
                    const lastMessage = document.querySelector('.message-bubble:last-child .message-content');
                    if (lastMessage) {
                        const reactionsDiv = lastMessage.nextElementSibling || document.createElement('div');
                        if (!lastMessage.nextElementSibling) {
                            reactionsDiv.className = 'message-reactions';
                            lastMessage.parentNode.insertBefore(reactionsDiv, lastMessage.nextSibling);
                        }
                        
                        const reactionSpan = document.createElement('span');
                        reactionSpan.className = 'reaction';
                        reactionSpan.textContent = reaction + ' 1';
                        reactionsDiv.appendChild(reactionSpan);
                        
                        // Hide quick reactions after use
                        document.getElementById('quickReactions').style.display = 'none';
                    }
                });
            });

            // Friend selection variables (will be moved to Firebase module)
            let currentFriends = [];
            let filteredFriends = [];

            // Theme switcher functionality
            document.getElementById('themeSwitcherBtn').addEventListener('click', () => {
                const body = document.body;
                const icon = document.querySelector('#themeSwitcherBtn i');
                
                if (body.classList.contains('theme-dark-mode')) {
                    body.classList.remove('theme-dark-mode');
                    body.classList.add('theme-light-mode');
                    icon.className = 'fas fa-sun';
                    localStorage.setItem('jchat-theme', 'theme-light-mode');
                } else {
                    body.classList.remove('theme-light-mode');
                    body.classList.add('theme-dark-mode');
                    icon.className = 'fas fa-moon';
                    localStorage.setItem('jchat-theme', 'theme-dark-mode');
                }
            });

                         console.log('üöÄ JCHAT Full Chat initialized with Friends Selection + Reactions!');
         });
     </script>

     <!-- FULL FIREBASE AND CLOUDINARY INTEGRATION -->
     <script type="module">
         // Import Firebase modules
         import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
         import { getAuth, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
         import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, getDocs, addDoc, serverTimestamp, orderBy, limit, updateDoc, deleteDoc, where, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
         import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

         // --- Firebase & Canvas Environment Configuration ---
         const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
             apiKey: "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
             authDomain: "jchat-1.firebaseapp.com",
             projectId: "jchat-1",
             storageBucket: "jchat-1.firebasestorage.app",
             messagingSenderId: "328479683167",
             appId: "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
             measurementId: "G-S6Z9GG0R9P"
         };
         const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
         const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

         // Cloudinary Configuration
         const cloudinaryConfig = {
             cloudName: "dxld01rcp", // Your Cloudinary Cloud Name
             uploadPreset: "Storage_preset" // Your Cloudinary Upload Preset
         };

         // Initialize Firebase services
         const app = initializeApp(firebaseConfig);
         const auth = getAuth(app);
         const db = getFirestore(app);
         const storage = getStorage(app);

         // --- DOM Elements ---
         const headerProfilePic = document.getElementById('headerProfilePic');
         const headerAvatarIcon = document.getElementById('headerAvatarIcon');
         const headerDisplayName = document.getElementById('headerDisplayName');
         const notificationCountElement = document.getElementById('notificationCount');
         const adminIconLink = document.getElementById('adminIconLink');
         const profileLink = document.getElementById('profileLink');
         const soundToggleIcon = document.getElementById('soundToggleIcon');

         const partnerProfilePic = document.getElementById('partnerProfilePic');
         const partnerAvatarIcon = document.getElementById('partnerAvatarIcon');
         const partnerDisplayName = document.getElementById('partnerDisplayName');
         const messagesArea = document.getElementById('messagesArea');
         const messageInput = document.getElementById('messageInput');
         const sendMessageBtn = document.getElementById('sendMessageBtn');

         // Global State
         let currentUser = null;
         let currentUserProfileData = null;
         let partnerId = null;
         let partnerProfileData = null;
         let unsubscribeMessages = null;
         let unsubscribeTyping = null;
         let notificationSoundEnabled = true;
         
         // Friend selection variables
         let currentFriends = [];
         let filteredFriends = [];

         // Voice Note Recording State
         let mediaRecorder;
         let audioChunks = [];
         let isRecording = false;
         let recordingStartTime;
         let recordingInterval;

         // --- Tone.js Synths for Notification Sounds ---
         const successSynth = new Tone.Synth().toDestination();
         const errorSynth = new Tone.Synth({
             oscillator: { type: "sawtooth" }
         }).toDestination();
         const infoSynth = new Tone.Synth({
             oscillator: { type: "triangle" }
         }).toDestination();

         /**
          * Plays notification sounds using ne.mp3 or Tone.js fallback
          */




         /**
          * Constructs a Cloudinary URL for an image/video.
          */
         function getCloudinaryImageUrl(urlOrPublicId, transformations = "w_auto,f_auto,q_auto") {
             if (!urlOrPublicId) return null;
             if (urlOrPublicId.startsWith('http://') || urlOrPublicId.startsWith('https://')) {
                 if (urlOrPublicId.includes('res.cloudinary.com')) {
                     const parts = urlOrPublicId.split('/upload/');
                     if (parts.length === 2) {
                         return `${parts[0]}/upload/${transformations}/${parts[1]}`;
                     }
                 }
                 return urlOrPublicId;
             }
             return `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/image/upload/${transformations}/${urlOrPublicId}`;
         }

         /**
          * Displays the profile picture or a default icon.
          */
         
         // Friend Selection Functions (moved from first script section)
         
         /**
          * Fetches the current user's friends list from Firestore with real-time online status.
          */
         async function fetchUserFriends() {
             if (!currentUser) {
                 console.log("JCHAT_DEBUG: No current user to fetch friends for.");
                 return [];
             }

             try {
                 console.log("JCHAT_DEBUG: Fetching friends for user:", currentUser.uid);
                 const friends = [];
                 
                 // Get friends from the same collection path as Find_Friends.html
                 const publicFriendsRef = collection(db, "artifacts", appId, "public", "data", "friends");
                 const friendsSnapshot = await getDocs(publicFriendsRef);
                 
                 const friendIds = new Set();
                 friendsSnapshot.forEach(docSnap => {
                     const friendData = docSnap.data();
                     if (friendData.user1Id === currentUser.uid) {
                         friendIds.add(friendData.user2Id);
                     } else if (friendData.user2Id === currentUser.uid) {
                         friendIds.add(friendData.user1Id);
                     }
                 });
                 
                 console.log(`JCHAT_DEBUG: Found ${friendIds.size} friend relationships`);

                 // Get detailed user data for each friend with real-time online status
                 if (friendIds.size > 0) {
                     for (const friendId of friendIds) {
                         try {
                             const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", friendId);
                             const publicDocSnap = await getDoc(publicProfileDocRef);
                             if (publicDocSnap.exists()) {
                                 const friendProfile = publicDocSnap.data();
                                 
                                 // Check real-time online status
                                 const isOnline = await checkUserOnlineStatus(friendId);
                                 
                                 friends.push({
                                     userId: friendId,
                                     username: friendProfile.username || friendProfile.displayName || `User_${friendId.substring(0, 8)}`,
                                     profilePicId: friendProfile.profilePicId,
                                     visibility: friendProfile.visibility || {},
                                     isOnline: isOnline,
                                     lastSeen: friendProfile.lastSeen || null
                                 });
                             } else {
                                 console.warn(`JCHAT_WARN: Public profile not found for friend ID: ${friendId}`);
                                 friends.push({
                                     userId: friendId,
                                     username: `Unknown User (${friendId.substring(0, 8)})`,
                                     profilePicId: null,
                                     visibility: {},
                                     isOnline: false,
                                     lastSeen: null
                                 });
                             }
                         } catch (error) {
                             console.error(`JCHAT_ERROR: Error fetching public profile for friend ${friendId}:`, error);
                             friends.push({
                                 userId: friendId,
                                 username: `Error User (${friendId.substring(0, 8)})`,
                                 profilePicId: null,
                                 visibility: {},
                                 isOnline: false,
                                 lastSeen: null
                             });
                         }
                     }

                     // Sort friends by online status and name
                     friends.sort((a, b) => {
                         if (a.isOnline && !b.isOnline) return -1;
                         if (!a.isOnline && b.isOnline) return 1;
                         return a.username.localeCompare(b.username);
                     });
                 }

                 console.log(`JCHAT_DEBUG: Successfully loaded ${friends.length} real friends`);
                 
                 if (friends.length === 0) {
                     showMessageBox('üë• No friends found. Add friends from the Find Friends page!', 'info');
                 }
                 
                 return friends;
                 
             } catch (error) {
                 console.error("JCHAT_ERROR: Error fetching real friends:", error);
                 showMessageBox('‚ùå Failed to load friends. Please try again.', 'error');
                 return [];
             }
         }

         /**
          * Checks if a user is currently online by looking at their last activity.
          */
         async function checkUserOnlineStatus(userId) {
             try {
                 // Check user's online status in their profile
                 const userProfileRef = doc(db, "artifacts", appId, "public", "data", "users", userId);
                 const userProfileSnap = await getDoc(userProfileRef);
                 
                 if (userProfileSnap.exists()) {
                     const userData = userProfileSnap.data();
                     
                     // Check if user has isOnline field and it's true
                     if (userData.isOnline === true) {
                         return true;
                     }
                     
                     // Check lastSeen timestamp (consider online if last activity was within 5 minutes)
                     if (userData.lastSeen) {
                         const lastSeenTime = userData.lastSeen.toDate ? userData.lastSeen.toDate() : new Date(userData.lastSeen);
                         const now = new Date();
                         const timeDiff = now - lastSeenTime;
                         const fiveMinutes = 5 * 60 * 1000; // 5 minutes in milliseconds
                         
                         if (timeDiff < fiveMinutes) {
                             return true;
                         }
                     }
                 }
                 
                 return false;
             } catch (error) {
                 console.error(`JCHAT_ERROR: Error checking online status for ${userId}:`, error);
                 return false;
             }
         }

         /**
          * Updates the current user's online status.
          */
         async function updateUserOnlineStatus(isOnline) {
             if (!currentUser) return;
             
             try {
                 const userProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                 await updateDoc(userProfileRef, {
                     isOnline: isOnline,
                     lastSeen: serverTimestamp()
                 });
                 console.log(`JCHAT_DEBUG: Updated online status to ${isOnline}`);
             } catch (error) {
                 console.error("JCHAT_ERROR: Error updating online status:", error);
             }
         }

         /**
          * Creates a friend item HTML element.
          */
         function createFriendItem(friend) {
             const friendDiv = document.createElement('div');
             friendDiv.className = 'friend-item';
             friendDiv.setAttribute('data-friend-id', friend.userId);
             friendDiv.setAttribute('data-friend-name', friend.username);

             // Profile image with proper error handling
             let profileImageHtml = '';
             if (friend.profilePicId && friend.visibility?.profilePic !== false) {
                 const imageUrl = getCloudinaryImageUrl(friend.profilePicId, "w_60,h_60,c_fill,g_face,r_max");
                 profileImageHtml = `<img src="${imageUrl}" alt="${friend.username}'s Profile" class="friend-avatar" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">`;
             } else {
                 profileImageHtml = `<div class="default-avatar" style="display: flex;"><i class="fas fa-user-circle"></i></div>`;
             }

             // Display name with proper visibility handling
             const displayName = friend.visibility?.displayName !== false ? friend.username : 'Anonymous User';
             
             // Real online status
             const isOnline = friend.isOnline;
             const statusClass = isOnline ? 'online' : 'offline';
             const statusText = isOnline ? 'Online' : 'Offline';
             
             // Last seen time for offline users
             let lastSeenText = '';
             if (!isOnline && friend.lastSeen) {
                 const lastSeen = new Date(friend.lastSeen);
                 const now = new Date();
                 const diff = now - lastSeen;
                 const minutes = Math.floor(diff / 60000);
                 const hours = Math.floor(minutes / 60);
                 const days = Math.floor(hours / 24);
                 
                 if (days > 0) {
                     lastSeenText = `Last seen ${days} day${days > 1 ? 's' : ''} ago`;
                 } else if (hours > 0) {
                     lastSeenText = `Last seen ${hours} hour${hours > 1 ? 's' : ''} ago`;
                 } else if (minutes > 0) {
                     lastSeenText = `Last seen ${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                 } else {
                     lastSeenText = 'Last seen recently';
                 }
             }
             
             friendDiv.innerHTML = `
                 <div class="friend-avatar-container">
                     ${profileImageHtml}
                     <div class="default-avatar" style="display: none;"><i class="fas fa-user-circle"></i></div>
                     ${isOnline ? '<div class="online-indicator"></div>' : ''}
                 </div>
                 <div class="friend-info">
                     <span class="friend-name">${displayName}</span>
                     <span class="friend-status ${statusClass}">${statusText}</span>
                     ${lastSeenText ? `<span class="last-seen">${lastSeenText}</span>` : ''}
                 </div>
             `;

             // Add hover effects
             friendDiv.addEventListener('mouseenter', () => {
                 friendDiv.style.transform = 'translateY(-3px) scale(1.02)';
             });
             
             friendDiv.addEventListener('mouseleave', () => {
                 friendDiv.style.transform = '';
             });

             return friendDiv;
         }

         /**
          * Renders the friends list in the modal.
          */
         function renderFriendsList(friends) {
             console.log("JCHAT_DEBUG: renderFriendsList called with friends:", friends);
             const friendListContainer = document.getElementById('friendListContainer');
             console.log("JCHAT_DEBUG: friendListContainer found:", friendListContainer);
             const noFriendsMessage = friendListContainer.querySelector('.no-friends-modal');
             console.log("JCHAT_DEBUG: noFriendsMessage found:", noFriendsMessage);
             
             // Clear existing content except the no-friends message
             const existingItems = friendListContainer.querySelectorAll('.friend-item');
             existingItems.forEach(item => item.remove());

             if (friends.length === 0) {
                 console.log("JCHAT_DEBUG: No friends found, showing no friends message");
                 noFriendsMessage.style.display = 'block';
                 noFriendsMessage.textContent = 'No friends found. Add friends from the Find Friends page.';
             } else {
                 console.log("JCHAT_DEBUG: Found friends, creating friend items for:", friends.length, "friends");
                 noFriendsMessage.style.display = 'none';
                 friends.forEach(friend => {
                     console.log("JCHAT_DEBUG: Creating friend item for:", friend.username);
                     const friendItem = createFriendItem(friend);
                     
                     // Add click handler for friend selection
                     friendItem.addEventListener('click', async () => {
                         const friendId = friend.userId;
                         const friendName = friend.username;
                         const friendProfilePicId = friend.profilePicId;
                         
                         try {
                             // Show loading state
                             showMessageBox(`üîÑ Loading chat with ${friendName}...`, 'loading', true);
                             
                             // Update partner display and global variable
                             const partnerDisplay = document.getElementById('partnerDisplayName');
                             if (partnerDisplay) {
                                 partnerDisplay.textContent = friendName;
                             }
                             
                             // Update partner profile picture
                             const partnerProfilePic = document.getElementById('partnerProfilePic');
                             const partnerAvatarIcon = document.getElementById('partnerAvatarIcon');
                             
                             if (friendProfilePicId && friend.visibility?.profilePic !== false) {
                                 const imageUrl = getCloudinaryImageUrl(friendProfilePicId, "w_40,h_40,c_fill,g_face,r_max");
                                 if (partnerProfilePic) {
                                     partnerProfilePic.src = imageUrl;
                                     partnerProfilePic.style.display = 'block';
                                     partnerProfilePic.onerror = () => {
                                         partnerProfilePic.style.display = 'none';
                                         if (partnerAvatarIcon) partnerAvatarIcon.style.display = 'flex';
                                     };
                                 }
                                 if (partnerAvatarIcon) partnerAvatarIcon.style.display = 'none';
                             } else {
                                 if (partnerProfilePic) partnerProfilePic.style.display = 'none';
                                 if (partnerAvatarIcon) partnerAvatarIcon.style.display = 'flex';
                             }
                             
                             // Update header title
                             const headerTitle = document.querySelector('.chat-header h2');
                             if (headerTitle) {
                                 headerTitle.textContent = `Chat with ${friendName}`;
                             }
                             
                             // Set partner ID
                             partnerId = friendId;
                             
                             // Close modal
                             document.getElementById('selectFriendModal').classList.remove('active');
                             
                             // Clear search input
                             const searchInput = document.getElementById('friendSearchInput');
                             if (searchInput) {
                                 searchInput.value = '';
                             }
                             
                             // Clear existing messages and show loading
                             const messagesArea = document.getElementById('messagesArea');
                             if (messagesArea) {
                                 // Keep only the typing indicator and welcome message
                                 const existingMessages = messagesArea.querySelectorAll('.message-bubble');
                                 existingMessages.forEach(msg => {
                                     if (!msg.innerHTML.includes('Welcome to JCHAT') && !msg.classList.contains('typing-indicator')) {
                                         msg.remove();
                                     }
                                 });
                                 
                                 // Add loading message
                                 const loadingMsg = document.createElement('div');
                                 loadingMsg.className = 'message-bubble received';
                                 loadingMsg.innerHTML = `
                                     <div class="message-content">
                                         <i class="fas fa-spinner fa-spin"></i> Loading chat history...
                                     </div>
                                     <div class="message-time">Just now</div>
                                 `;
                                 messagesArea.appendChild(loadingMsg);
                                 messagesArea.scrollTop = messagesArea.scrollHeight;
                             } else {
                                 console.error("JCHAT_ERROR: Messages area not found during friend selection");
                             }
                             
                             // Load messages for selected friend
                             if (typeof loadMessages === 'function' && currentUser) {
                                 try {
                                     await loadMessages();
                                 } catch (error) {
                                     console.error("JCHAT_ERROR: Error loading messages:", error);
                                     showMessageBox("Failed to load chat history", 'error');
                                 }
                             } else {
                                 console.error("JCHAT_ERROR: loadMessages function not available");
                                 showMessageBox("Chat functionality not ready", 'error');
                             }
                             
                             // Remove loading message
                             const loadingMsg = messagesArea?.querySelector('.message-bubble:last-child');
                             if (loadingMsg && loadingMsg.innerHTML.includes('Loading chat history')) {
                                 loadingMsg.remove();
                             }
                             
                             showMessageBox(`üí¨ Now chatting with ${friendName}`, 'success');
                             playNotificationSound('success');
                             console.log(`JCHAT_DEBUG: Successfully loaded chat with friend ${friendId} (${friendName})`);
                             
                         } catch (error) {
                             console.error("JCHAT_ERROR: Error loading chat:", error);
                             showMessageBox(`‚ùå Failed to load chat with ${friendName}`, 'error');
                         }
                     });

                     friendListContainer.insertBefore(friendItem, noFriendsMessage);
                 });
             }

             // Update friend count badge
             const badge = document.getElementById('selectFriendBadge');
             if (badge) {
                 if (friends.length > 0) {
                     badge.textContent = friends.length;
                     badge.style.display = 'inline-block';
                 } else {
                     badge.style.display = 'none';
                 }
             }
         }

         /**
          * Filters friends based on search query.
          */
         function filterFriends(searchQuery) {
             if (!searchQuery.trim()) {
                 filteredFriends = [...currentFriends];
             } else {
                 const query = searchQuery.toLowerCase();
                 filteredFriends = currentFriends.filter(friend =>
                     friend.username.toLowerCase().includes(query)
                 );
             }
             renderFriendsList(filteredFriends);
         }
         function displayProfilePicture(imgElement, iconElement, profilePicId, usernameInitial, transformations) {
             if (imgElement && iconElement) {
                 if (profilePicId) {
                     const imageUrl = getCloudinaryImageUrl(profilePicId, transformations);
                     imgElement.src = imageUrl;
                     imgElement.style.display = 'block';
                     iconElement.style.display = 'none';
                     imgElement.onerror = () => {
                         console.error(`JCHAT_ERROR: Failed to load profile picture: ${profilePicId}. Using placeholder.`);
                         imgElement.src = `https://placehold.co/40x40/CCCCCC/000000?text=${usernameInitial}`;
                         imgElement.style.display = 'block';
                         iconElement.style.display = 'none';
                     };
                 } else {
                     imgElement.src = '';
                     imgElement.style.display = 'none';
                     iconElement.style.display = 'block';
                 }
             }
         }

         /**
          * Fetches and displays the current user's profile data for the header.
          */
         async function fetchAndDisplayHeaderProfile(user) {
             console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile called for user:", user.uid);
             try {
                 const privateProfileDocRef = doc(db, "artifacts", appId, "users", user.uid, "profiles", "user_profile");
                 const privateDocSnap = await getDoc(privateProfileDocRef);

                 let profileData = null;
                 if (privateDocSnap.exists()) {
                     profileData = privateDocSnap.data();
                     console.log("JCHAT_DEBUG: Fetched existing profile data for header:", profileData);
                 } else {
                     // If private profile doesn't exist, create a basic one
                     console.warn("JCHAT_WARN: Private profile not found for header, creating a new one.");
                     profileData = {
                         username: user.displayName || `User_${user.uid.substring(0, 8)}`,
                         email: user.email || "",
                         profilePicId: user.photoURL || null,
                         bio: "",
                         location: "",
                         friendsCount: 0,
                         followersCount: 0,
                         followingCount: 0,
                         totalPosts: 0,
                         createdAt: serverTimestamp(),
                         updatedAt: serverTimestamp(),
                         visibility: {
                             profile: true,
                             email: false,
                             friends: true,
                             posts: true,
                             displayName: true,
                             location: false
                         },
                         isAdmin: false
                     };
                     await setDoc(privateProfileDocRef, profileData);

                     // Also create/update public profile
                     const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);
                     await setDoc(publicProfileDocRef, {
                         username: profileData.username,
                         profilePicId: profileData.profilePicId,
                         bio: profileData.bio,
                         location: profileData.location,
                         createdAt: profileData.createdAt,
                         updatedAt: profileData.updatedAt,
                         visibility: profileData.visibility,
                         totalPosts: profileData.totalPosts
                     }, { merge: true });

                     console.log("JCHAT_DEBUG: Created new profile for user:", user.uid);
                 }

                 // Store in global variable
                 currentUserProfileData = profileData;

                 // Update header elements
                 const username = profileData.username || user.displayName || `User_${user.uid.substring(0, 8)}`;
                 const usernameInitial = username.charAt(0).toUpperCase();

                 if (headerDisplayName) {
                     headerDisplayName.textContent = profileData.visibility?.displayName !== false ? username : 'Anonymous';
                 }

                 // Display profile picture using Cloudinary
                 displayProfilePicture(headerProfilePic, headerAvatarIcon, profileData?.profilePicId, usernameInitial, "w_90,h_90,c_fill,g_face,r_max");

                 // Show admin icon if user is admin
                 if (profileData.isAdmin && adminIconLink) {
                     adminIconLink.style.display = 'block';
                 }

                 console.log("JCHAT_DEBUG: Header profile updated successfully");
             } catch (error) {
                 console.error("JCHAT_ERROR: Error fetching/displaying header profile:", error);
                 
                 // Fallback display
                 const fallbackUsername = user.displayName || `User_${user.uid.substring(0, 8)}`;
                 if (headerDisplayName) {
                     headerDisplayName.textContent = fallbackUsername;
                 }
                 if (headerAvatarIcon) {
                     headerAvatarIcon.style.display = 'block';
                 }
                 if (headerProfilePic) {
                     headerProfilePic.style.display = 'none';
                 }
             }
         }

         /**
          * Fetches and displays the notification count for the current user.
          */
         async function fetchNotificationCount(userId) {
             try {
                 const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                 const q = query(notificationsCollectionRef, orderBy("timestamp", "desc"));
                 const unsubscribe = onSnapshot(q, (snapshot) => {
                     const unreadCount = snapshot.docs.filter(doc => !doc.data().read).length;

                     if (notificationCountElement) {
                         if (unreadCount > 0) {
                             notificationCountElement.textContent = unreadCount;
                             notificationCountElement.style.display = 'flex';
                         } else {
                             notificationCountElement.style.display = 'none';
                         }
                     }
                 });

                 // Store unsubscribe function for cleanup
                 return unsubscribe;
             } catch (error) {
                 console.error("JCHAT_ERROR: Error fetching notification count:", error);
             }
         }

         // Chat-specific functions
         function getChatRoomId(uid1, uid2) {
             return [uid1, uid2].sort().join('_');
         }

         // Get partnerId from URL parameters
         const urlParams = new URLSearchParams(window.location.search);
         partnerId = urlParams.get('partnerId') || 'demo-partner-123';

         // Enhanced message sending with Firebase
         async function sendMessage(type = 'text', content = '') {
             if (!currentUser || !partnerId) {
                 showMessageBox("Please select a chat partner", 'warning');
                 throw new Error("No chat partner selected");
             }

             // Get the current message input value
             const messageInput = document.getElementById('messageInput');
             const message = content || (messageInput ? messageInput.value.trim() : '');
             
             console.log("JCHAT_DEBUG: Send message called with:", { type, content, message, hasMessageInput: !!messageInput });
             
             if (!message) {
                 showMessageBox("Please type a message", 'warning');
                 throw new Error("Empty message");
             }

             try {
                 const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                 const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");

                 const messageData = {
                     senderId: currentUser.uid,
                     receiverId: partnerId,
                     type: type,
                     content: message,
                     timestamp: serverTimestamp(),
                     status: 'sent',
                     reactions: {}
                 };

                 await addDoc(messagesCollectionRef, messageData);

                 // Clear input after successful send
                 if (messageInput) {
                     messageInput.value = '';
                     messageInput.style.height = 'auto';
                     
                     // Update send button state
                     const sendBtn = document.getElementById('sendMessageBtn');
                     if (sendBtn) {
                         sendBtn.disabled = true;
                     }
                 }

                 playNotificationSound('success');
                 console.log("JCHAT_DEBUG: Message sent successfully");

             } catch (error) {
                 console.error("JCHAT_ERROR: Error sending message:", error);
                 showMessageBox("Failed to send message. Please try again.", 'error');
                 throw error; // Re-throw to be handled by the button
             }
         }

         // Enhanced message loading with Firebase
         async function loadMessages() {
             if (!currentUser || !partnerId) {
                 console.log("JCHAT_DEBUG: Cannot load messages - missing user or partner");
                 return;
             }

             // Get messages area element
             const messagesArea = document.getElementById('messagesArea');
             if (!messagesArea) {
                 console.error("JCHAT_ERROR: Messages area element not found");
                 showMessageBox("Chat interface not ready", 'error');
                 return;
             }

             try {
                 console.log(`JCHAT_DEBUG: Loading messages for chat with ${partnerId}`);
                 
                 // Unsubscribe previous listeners
                 if (unsubscribeMessages) {
                     unsubscribeMessages();
                     unsubscribeMessages = null;
                 }
                 if (unsubscribeTyping) {
                     unsubscribeTyping();
                     unsubscribeTyping = null;
                 }

                 const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                 console.log(`JCHAT_DEBUG: Chat room ID: ${chatRoomId}`);
                 
                 const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");
                 const q = query(messagesCollectionRef, orderBy("timestamp", "asc"));

                 unsubscribeMessages = onSnapshot(q, (snapshot) => {
                     console.log(`JCHAT_DEBUG: Received ${snapshot.docs.length} messages from Firebase`);
                     
                     // Clear ALL existing messages including welcome message when loading chat history
                     const existingMessages = messagesArea.querySelectorAll('.message-bubble');
                     existingMessages.forEach(msg => {
                         if (!msg.classList.contains('typing-indicator') &&
                             !msg.innerHTML.includes('Loading chat history')) {
                             msg.remove();
                         }
                     });

                     if (!snapshot.empty) {
                         snapshot.docs.forEach(doc => {
                             const messageData = doc.data();
                             createMessageBubble(messageData, doc.id);
                         });
                         
                         console.log(`JCHAT_DEBUG: Loaded ${snapshot.docs.length} messages successfully`);
                     } else {
                         // Add "No messages yet" indicator
                         const noMessagesDiv = document.createElement('div');
                         noMessagesDiv.className = 'message-bubble received';
                         noMessagesDiv.innerHTML = `
                             <div class="message-content">
                                 <i class="fas fa-comments"></i> No messages yet. Start the conversation!
                             </div>
                             <div class="message-time">Just now</div>
                         `;
                         messagesArea.appendChild(noMessagesDiv);
                         console.log("JCHAT_DEBUG: No previous messages found");
                     }

                     // Scroll to bottom
                     setTimeout(() => {
                         messagesArea.scrollTop = messagesArea.scrollHeight;
                     }, 100);

                 }, (error) => {
                     console.error("JCHAT_ERROR: Firebase listener error:", error);
                     showMessageBox("Failed to load chat history", 'error');
                 });

                 // Set up typing indicator listener
                 setupTypingIndicator(chatRoomId);

             } catch (error) {
                 console.error("JCHAT_ERROR: Error loading messages:", error);
                 showMessageBox("Failed to load messages", 'error');
             }
         }

         /**
          * Sets up real-time typing indicator for the chat room.
          */
         function setupTypingIndicator(chatRoomId) {
             try {
                 const typingCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "typing");
                 
                 unsubscribeTyping = onSnapshot(typingCollectionRef, (snapshot) => {
                     const typingUsers = [];
                     snapshot.forEach(doc => {
                         const typingData = doc.data();
                         if (typingData.userId !== currentUser.uid && typingData.isTyping) {
                             typingUsers.push(typingData);
                         }
                     });

                     updateTypingIndicator(typingUsers);
                 });

                 console.log("JCHAT_DEBUG: Typing indicator listener set up");
             } catch (error) {
                 console.error("JCHAT_ERROR: Error setting up typing indicator:", error);
             }
         }

         /**
          * Updates the typing indicator display.
          */
         function updateTypingIndicator(typingUsers) {
             const typingIndicator = document.getElementById('typingIndicator');
             const typingUsername = document.getElementById('typingUsername');
             
             if (typingUsers.length > 0) {
                 // Get the first typing user's name
                 const typingUser = typingUsers[0];
                 const username = typingUser.username || 'Someone';
                 
                 if (typingUsername) {
                     typingUsername.textContent = username;
                 }
                 
                 if (typingIndicator) {
                     typingIndicator.style.display = 'flex';
                     
                     // Auto-hide typing indicator after 5 seconds
                     clearTimeout(typingIndicator.hideTimeout);
                     typingIndicator.hideTimeout = setTimeout(() => {
                         typingIndicator.style.display = 'none';
                     }, 5000);
                 }
                 
                 console.log(`JCHAT_DEBUG: ${username} is typing`);
             } else {
                 if (typingIndicator) {
                     typingIndicator.style.display = 'none';
                 }
             }
         }

         /**
          * Sends typing status to Firebase.
          */
         async function sendTypingStatus(isTyping) {
             if (!currentUser || !partnerId) return;
             
             try {
                 const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                 const typingCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "typing");
                 const typingDocRef = doc(typingCollectionRef, currentUser.uid);
                 
                 if (isTyping) {
                     await setDoc(typingDocRef, {
                         userId: currentUser.uid,
                         username: currentUserProfileData?.username || 'Unknown User',
                         isTyping: true,
                         timestamp: serverTimestamp()
                     });
                 } else {
                     await deleteDoc(typingDocRef);
                 }
             } catch (error) {
                 console.error("JCHAT_ERROR: Error sending typing status:", error);
             }
         }

         function createMessageBubble(messageData, messageId) {
             // Validate message data
             if (!messageData || !messageData.content) {
                 console.warn("JCHAT_WARN: Invalid message data received:", messageData);
                 return null;
             }

             const messagesArea = document.getElementById('messagesArea');
             if (!messagesArea) {
                 console.error("JCHAT_ERROR: Messages area not found");
                 return null;
             }

             const messageDiv = document.createElement('div');
             const isSent = messageData.senderId === currentUser.uid;
             messageDiv.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
             messageDiv.dataset.messageId = messageId || 'unknown';

             // Handle timestamp safely
             let timeString = 'Just now';
             if (messageData.timestamp) {
                 try {
                     if (messageData.timestamp.seconds) {
                         timeString = new Date(messageData.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                     } else if (messageData.timestamp.toDate) {
                         timeString = messageData.timestamp.toDate().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                     } else if (messageData.timestamp instanceof Date) {
                         timeString = messageData.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                     }
                 } catch (error) {
                     console.warn("JCHAT_WARN: Error parsing timestamp:", error);
                     timeString = 'Just now';
                 }
             }

             // Sanitize content to prevent XSS
             const sanitizedContent = messageData.content.toString().replace(/</g, '&lt;').replace(/>/g, '&gt;');

             messageDiv.innerHTML = `
                 <div class="message-content">${sanitizedContent}</div>
                 <div class="message-time">${timeString}</div>
             `;

             messagesArea.appendChild(messageDiv);
             console.log(`JCHAT_DEBUG: Created message bubble for ${isSent ? 'sent' : 'received'} message`);
             return messageDiv;
         }

         // Override existing button event listeners with Firebase functionality
         document.addEventListener('DOMContentLoaded', () => {
             
             // Friend Selection Event Listeners
             
             // Select Friend button click handler
             document.getElementById('selectFriendBtn')?.addEventListener('click', async () => {
                 console.log("JCHAT_DEBUG: Select Friend button clicked");
                 const btn = document.getElementById('selectFriendBtn');
                 btn.style.transform = 'scale(0.95)';
                 setTimeout(() => btn.style.transform = '', 150);
                 
                 // Check authentication first
                 if (!currentUser || !currentUser.uid) {
                     console.log("JCHAT_DEBUG: No current user found");
                     showMessageBox('‚ùå Please log in to view your friends', 'warning');
                     return;
                 }
                 
                 console.log("JCHAT_DEBUG: Current user found:", currentUser.uid);
                 
                 // Show loading state
                 showMessageBox('üë• Loading your friends...', 'loading', true);
                 
                 try {
                     console.log("JCHAT_DEBUG: Starting to fetch friends...");
                     // Fetch REAL friends data only
                     currentFriends = await fetchUserFriends();
                     console.log("JCHAT_DEBUG: Friends fetched:", currentFriends);
                     filteredFriends = [...currentFriends];
                     
                     // Render friends list
                     console.log("JCHAT_DEBUG: Rendering friends list...");
                     renderFriendsList(filteredFriends);
                     
                     // Show modal
                     document.getElementById('selectFriendModal').classList.add('active');
                     
                     if (currentFriends.length > 0) {
                         showMessageBox(`üë• Found ${currentFriends.length} friend${currentFriends.length > 1 ? 's' : ''}. Select one to chat!`, 'success');
                     } else {
                         showMessageBox('üë• No friends yet. Add friends from the Find Friends page!', 'info');
                     }
                 } catch (error) {
                     console.error('JCHAT_ERROR: Error in friend selection:', error);
                     showMessageBox('‚ùå Failed to load friends. Please try again.', 'error');
                 }
             });

             // Close modal button
             document.getElementById('closeFriendModalBtn')?.addEventListener('click', () => {
                 document.getElementById('selectFriendModal').classList.remove('active');
                 showMessageBox('‚ùå Friend selection cancelled', 'info');
             });

             // Search functionality
             document.getElementById('friendSearchInput')?.addEventListener('input', (e) => {
                 filterFriends(e.target.value);
             });

             // Find Friends functionality
             document.getElementById('findFriendsBtn')?.addEventListener('click', () => {
                 const btn = document.getElementById('findFriendsBtn');
                 btn.style.transform = 'scale(0.95)';
                 setTimeout(() => btn.style.transform = '', 150);
                 
                 showMessageBox('üîç Navigating to Find Friends...', 'info');
                 setTimeout(() => {
                     window.location.href = '/Find_Friends.html';
                 }, 500);
             });
             // Enhanced send message functionality
             const sendMessageBtn = document.getElementById('sendMessageBtn');
             const messageInput = document.getElementById('messageInput');
             
             if (sendMessageBtn) {
                 // Remove existing listeners by cloning
                 const newSendBtn = sendMessageBtn.cloneNode(true);
                 sendMessageBtn.parentNode.replaceChild(newSendBtn, sendMessageBtn);
                 
                 // Add enhanced click listener
                 newSendBtn.addEventListener('click', async () => {
                     const btn = newSendBtn;
                     const originalContent = btn.innerHTML;
                     
                     // Add loading state
                     btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                     btn.disabled = true;
                     
                     try {
                         // Get the current message input value
                         const currentMessageInput = document.getElementById('messageInput');
                         const messageContent = currentMessageInput ? currentMessageInput.value : '';
                         
                         await sendMessage('text', messageContent);
                         
                         // Success state
                         btn.innerHTML = '<i class="fas fa-check"></i>';
                         setTimeout(() => {
                             btn.innerHTML = originalContent;
                             btn.disabled = false;
                         }, 500);
                         
                     } catch (error) {
                         console.error("JCHAT_ERROR: Send button error:", error);
                         
                         // Error state
                         btn.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
                         setTimeout(() => {
                             btn.innerHTML = originalContent;
                             btn.disabled = false;
                         }, 1000);
                     }
                 });
             }

             // Enhanced message input functionality
             if (messageInput) {
                 // Remove existing listeners by cloning
                 const newMessageInput = messageInput.cloneNode(true);
                 messageInput.parentNode.replaceChild(newMessageInput, messageInput);
                 
                 // Typing status tracking
                 let typingTimeout;
                 
                 // Add enhanced listeners
                 newMessageInput.addEventListener('input', () => {
                     newMessageInput.style.height = 'auto';
                     newMessageInput.style.height = Math.min(newMessageInput.scrollHeight, 120) + 'px';
                     
                     // Enable/disable send button based on content
                     const sendBtn = document.getElementById('sendMessageBtn');
                     if (sendBtn) {
                         sendBtn.disabled = !newMessageInput.value.trim();
                     }
                     
                     // Send typing status
                     sendTypingStatus(true);
                     
                     // Clear previous timeout
                     clearTimeout(typingTimeout);
                     
                     // Set timeout to stop typing status after 2 seconds of no input
                     typingTimeout = setTimeout(() => {
                         sendTypingStatus(false);
                     }, 2000);
                 });

                 newMessageInput.addEventListener('keypress', async (e) => {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault();
                         
                         // Stop typing status when sending
                         sendTypingStatus(false);
                         clearTimeout(typingTimeout);
                         
                         const sendBtn = document.getElementById('sendMessageBtn');
                         if (sendBtn && !sendBtn.disabled) {
                             sendBtn.click();
                         }
                     }
                 });
                 
                 // Stop typing when input loses focus
                 newMessageInput.addEventListener('blur', () => {
                     sendTypingStatus(false);
                     clearTimeout(typingTimeout);
                 });
             }

             // Sound toggle
             document.getElementById('soundToggleIcon')?.addEventListener('click', () => {
                 notificationSoundEnabled = !notificationSoundEnabled;
                 const icon = document.getElementById('soundToggleIcon');
                 if (notificationSoundEnabled) {
                     icon.className = 'fas fa-volume-up active';
                 } else {
                     icon.className = 'fas fa-volume-mute';
                 }
                 localStorage.setItem('jchat-sound', notificationSoundEnabled);
                 showMessageBox(`Sound ${notificationSoundEnabled ? 'enabled' : 'disabled'}`, 'info');
             });

             // Load saved sound preference
             const savedSound = localStorage.getItem('jchat-sound');
             if (savedSound !== null) {
                 notificationSoundEnabled = savedSound === 'true';
                 const icon = document.getElementById('soundToggleIcon');
                 if (icon) {
                     icon.className = notificationSoundEnabled ? 'fas fa-volume-up active' : 'fas fa-volume-mute';
                 }
             }
         });

         // Firebase Authentication State Listener
         onAuthStateChanged(auth, async (user) => {
             if (user) {
                 console.log("JCHAT_DEBUG: User authenticated:", user.uid);
                 currentUser = user;
                 
                 // Set user as online
                 await updateUserOnlineStatus(true);
                 
                 // Fetch and display header profile
                 await fetchAndDisplayHeaderProfile(user);
                 
                 // Fetch notification count
                 await fetchNotificationCount(user.uid);
                 
                 // Load messages if partner is selected
                 if (partnerId) {
                     await loadMessages();
                 }
                 
                 showMessageBox("Connected to JCHAT! üöÄ", 'success');
             } else {
                 console.log("JCHAT_DEBUG: User not authenticated, signing in anonymously");
                 try {
                     await signInAnonymously(auth);
                 } catch (error) {
                     console.error("JCHAT_ERROR: Anonymous sign-in failed:", error);
                     showMessageBox("Authentication failed", 'error');
                 }
             }
         });

         // Cleanup on page unload
         window.addEventListener('beforeunload', () => {
             if (unsubscribeMessages) unsubscribeMessages();
             if (unsubscribeTyping) unsubscribeTyping();
             if (isRecording) {
                 mediaRecorder?.stop();
             }
             // Set user as offline when leaving
             if (currentUser) {
                 updateUserOnlineStatus(false);
             }
             // Stop typing status
             sendTypingStatus(false);
         });

         // Also set offline when page becomes hidden
         document.addEventListener('visibilitychange', () => {
             if (document.hidden && currentUser) {
                 updateUserOnlineStatus(false);
             } else if (!document.hidden && currentUser) {
                 updateUserOnlineStatus(true);
             }
         });

         console.log('üöÄ JCHAT Full Chat initialized with 100% Firebase & Cloudinary functionality!');
     </script>

    <!-- Select Friend Modal -->
    <div id="selectFriendModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Select a Friend to Chat With</h3>
            <input type="text" id="friendSearchInput" placeholder="Search friends..." class="search-input">
            <div id="friendListContainer" class="friend-list-modal">
                <p class="no-friends-modal" style="display: none;">No friends found.</p>
            </div>
            <div class="modal-buttons">
                <button id="closeFriendModalBtn" class="cancel-btn">Close</button>
            </div>
        </div>
    </div>

</body>
</html>