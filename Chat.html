<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Full Chat</title>

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://*.firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>



        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --glass-black: rgba(10, 10, 10, .75);
            --glass-blue: rgba(0, 213, 255, .15);
            --radius: 20px;
            --transition: .3s ease;

            /* These variables will be overridden by theme classes */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* New variables for consistent theming */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #bbbbbb;
            --notification-badge-color: #ff2e92;
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;

            /* Chat specific variables */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --composer-accent: #3b82f6;
            --play-button-green: linear-gradient(90deg, #4CAF50, #8BC34A);
            --play-button-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
        }

        /* Theme Definitions */
        body.theme-dark-mode {
            --background-main: #1a1a2e;
            --background-gradient-1: #16213e;
            --background-gradient-2: #0f3460;
            --white: #e0e0e0;
            --text-light: #a0a0a0;
            --card-background: rgba(25, 25, 40, 0.7);
            --header-background: linear-gradient(135deg, rgba(10, 10, 20, .85), rgba(10, 10, 20, .75));
            --border-light: rgba(255, 255, 255, 0.08);
            --input-background: rgba(255, 255, 255, 0.08);
        }

        /* Always show scrollbar to prevent layout shifts */
        html {
            overflow-y: scroll;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-main);
            background-image: radial-gradient(circle at top left, var(--background-gradient-1), transparent 100px),
                              radial-gradient(circle at bottom right, var(--background-gradient-2), transparent 150px);
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease;

            position: relative;
            width: 100%;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 55px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 30px;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
            text-decoration: none;
        }

        /* User Profile Header Styling */
        .user-profile-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cool Notification Icon Styling */
        .notification-icon-wrapper {
            position: relative;
            margin-right: 15px;
        }

        .notification-icon-wrapper a {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .notification-icon-wrapper a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .notification-icon-wrapper a:hover::before {
            left: 100%;
        }

        .notification-icon-wrapper a:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
            border-color: var(--blue);
        }

        .notification-icon-wrapper i {
            font-size: 1.3rem;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #ff8e53);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            transition: all 0.3s ease;
            z-index: 1;
            position: relative;
        }

        .notification-icon-wrapper a:hover i {
            transform: rotate(15deg) scale(1.1);
            background: linear-gradient(45deg, #ff8e53, #ffd700, #ff6b35);
            background-clip: text;
            -webkit-background-clip: text;
        }

        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #ff8e53);
            color: #000;
            border-radius: 50%;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
            animation: pulse-notification 2s infinite;
            display: none;
        }

        @keyframes pulse-notification {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Additional cool effects for notification icon */
        .notification-icon-wrapper a:active {
            transform: scale(0.95);
        }

        /* Glow effect when there are notifications */
        .notification-icon-wrapper.has-notifications a {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .notification-icon-wrapper.has-notifications a:hover {
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        /* Shaking animation for notification bell when there are unread notifications */
        .notification-icon-wrapper.has-notifications i {
            animation: bell-shake 3s ease-in-out infinite;
            transform-origin: top;
        }

        @keyframes bell-shake {
            0%, 90%, 100% { transform: rotate(0deg); }
            5%, 15%, 25%, 35% { transform: rotate(10deg); }
            10%, 20%, 30% { transform: rotate(-10deg); }
            40%, 50%, 60%, 70%, 80% { transform: rotate(0deg); }
        }

        /* Pause shaking on hover */
        .notification-icon-wrapper.has-notifications a:hover i {
            animation-play-state: paused;
        }

        .user-profile-header #profileLink {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--white);
            transition: opacity 0.3s ease, background-color 0.3s ease;
            padding: 5px 10px;
            border-radius: var(--radius);
        }

        .user-profile-header #profileLink:hover {
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .user-profile-header img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .user-profile-header i {
            font-size: 30px;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        .user-profile-header span {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        /* Admin Icon Styling */
        #adminIconLink {
            display: none;
            margin-right: 15px;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        #adminIconLink:hover {
            transform: scale(1.1);
        }

        /* Sound Toggle */
        .sound-toggle {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .sound-toggle i {
            font-size: 1.5rem;
            color: var(--text-light);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .sound-toggle i.active {
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Chat Container */
        .chat-container {
            position: fixed;
            top: 55px;
            left: 0;
            width: 100%;
            height: calc(100vh - 55px);
            height: calc(100dvh - 55px);
            background: var(--background-main);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Prevent any scrolling within chat container */
            touch-action: none;
            overscroll-behavior: none;
        }

        /* Chat Header */
        .chat-header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-shrink: 0;
            z-index: 5;
        }

        .back-btn {
            background: linear-gradient(135deg, var(--pink), var(--blue));
            border: none;
            color: var(--white);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 10px 12px;
            border-radius: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 46, 146, 0.3);
        }

        .back-btn:hover {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 213, 255, 0.4);
        }

        .back-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .chat-header img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
        }

        .chat-header .default-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--white);
        }

        .chat-header h2 {
            flex-grow: 1;
            margin: 0;
            font-size: 1.2rem;
            color: var(--white);
        }

        /* Chat Header Buttons */
        .chat-header .select-friend-btn, 
        .chat-header .find-friends-btn {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
            position: relative;
        }

        .chat-header .select-friend-btn {
            margin-left: auto;
        }

        .chat-header .find-friends-btn {
            margin-left: 10px;
        }

        .chat-header .select-friend-btn:hover {
            color: var(--accent-color);
        }

        .chat-header .find-friends-btn:hover {
            color: #4CAF50;
        }

        /* Badge for Select Friend Button */
        .select-friend-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--notification-badge-color);
            color: var(--white);
            border-radius: 50%;
            padding: 3px 7px;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            animation: pulse-notification 2s infinite;
        }

        /* Theme Switcher Button */
        .theme-switcher-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin-left: 10px;
        }

        .theme-switcher-btn:hover {
            transform: rotate(180deg) scale(1.1);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }

        /* Messages Area - Critical for scroll management */
        .messages-area {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* Controlled scrolling within messages only */
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color) transparent;
        }

        .messages-area::-webkit-scrollbar {
            width: 6px;
        }

        .messages-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-area::-webkit-scrollbar-thumb {
            background-color: var(--accent-color);
            border-radius: 3px;
        }

        /* Message Bubbles */
        .message-bubble {
            max-width: 70%;
            margin-bottom: 10px;
            position: relative;
            animation: fadeIn 0.3s ease;
        }

        .message-bubble.sent {
            align-self: flex-end;
            margin-left: auto;
        }

        .message-bubble.received {
            align-self: flex-start;
            margin-right: auto;
        }

        .message-content {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 18px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            word-wrap: break-word;
        }

        .message-bubble.sent .message-content {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            color: var(--white);
        }

        .message-time {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 5px;
            text-align: right;
        }

        .message-bubble.received .message-time {
            text-align: left;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: var(--card-background);
            border-radius: 20px;
            margin: 10px 20px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .typing-indicator.active {
            opacity: 1;
            visibility: visible;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--accent-color);
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingAnimation {
            0%, 60%, 100% { transform: scale(1); opacity: 0.5; }
            30% { transform: scale(1.2); opacity: 1; }
        }

        /* Chat Input Area - Critical positioning */
        .chat-input-area {
            background: var(--header-background);
            border-top: 1px solid var(--border-light);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
            position: relative;
            z-index: 5;
        }

        .chat-actions-top {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .chat-actions-top button {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(255, 46, 146, 0.2);
            position: relative;
            overflow: hidden;
        }

        .chat-actions-top button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .chat-actions-top button:hover::before {
            left: 100%;
        }

        .chat-actions-top button:hover {
            background: linear-gradient(90deg, var(--pink), var(--blue));
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.5);
        }

        .chat-actions-top button:active {
            transform: translateY(-1px) scale(0.98);
        }

        .chat-actions-top button.active {
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input-row textarea {
            flex-grow: 1;
            padding: 12px 15px;
            border-radius: 25px;
            border: 1px solid var(--border-light);
            background-color: var(--input-background);
            color: var(--white);
            font-size: 14px;
            outline: none;
            resize: none;
            min-height: 45px;
            max-height: 120px;
            overflow-y: auto;
            transition: border-color 0.2s ease;
            font-family: 'Inter', sans-serif;
        }

        .chat-input-row textarea::placeholder {
            color: var(--text-light);
        }

        .chat-input-row textarea:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        #sendMessageBtn {
            background: var(--composer-accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            position: relative;
            overflow: hidden;
        }

        #sendMessageBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        #sendMessageBtn:hover::before {
            left: 100%;
        }

        #sendMessageBtn:hover:not(:disabled) {
            background: #2563eb;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.35);
        }

        #sendMessageBtn:active:not(:disabled) {
            transform: scale(0.95);
        }

        #sendMessageBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            background: #6b7280;
        }

        #sendMessageBtn.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Voice Recording Indicator */
        #voiceNoteBtn.recording {
            background: linear-gradient(90deg, #dc3545, #e94560);
            animation: pulse-red 1.5s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .chat-container {
                height: calc(100vh - 55px);
                height: calc(100dvh - 55px);
            }
            
            .chat-header {
                padding: 10px 15px;
            }
            
            .chat-header h2 {
                font-size: 1.1rem;
            }
            
            .messages-area {
                padding: 15px;
            }
            
            .message-bubble {
                max-width: 85%;
            }
            
            .chat-input-area {
                padding: 12px 15px;
            }
            
            .chat-actions-top button {
                padding: 6px 10px;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .chat-header {
                padding: 8px 12px;
            }
            
            .chat-header h2 {
                font-size: 1rem;
            }
            
            .messages-area {
                padding: 10px;
            }
            
            .message-bubble {
                max-width: 90%;
            }
            
            .chat-input-area {
                padding: 10px 12px;
            }
        }

        /* Message Reactions */
        .message-reactions {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .reaction {
            background: rgba(37, 211, 102, 0.1);
            border: 1px solid rgba(37, 211, 102, 0.3);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reaction:hover {
            background: rgba(37, 211, 102, 0.2);
            transform: scale(1.1);
        }

        .reaction.active {
            background: rgba(37, 211, 102, 0.3);
            border-color: #25D366;
        }

        /* Quick Reactions Panel */
        .quick-reactions {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideUp 0.3s ease;
        }

        .reaction-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reaction-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            border-color: #25D366;
        }

        .reaction-btn:active {
            transform: scale(0.95);
        }

        /* Reaction Toggle Button */
        #reactionToggleBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        #reactionToggleBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-background);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h3 {
            color: var(--white);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Poppins', sans-serif;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid var(--border-light);
            background-color: var(--input-background);
            color: var(--white);
            font-size: 1rem;
            outline: none;
        }

        .search-input::placeholder {
            color: var(--text-light);
        }

        .friend-list-modal {
            flex-grow: 1;
            overflow-y: auto;
            max-height: calc(80vh - 150px);
            padding-right: 5px;
        }

        .friend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border-radius: 10px;
            background-color: var(--input-background);
            border: 1px solid var(--border-light);
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .friend-item:hover {
            background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1));
            transform: translateY(-3px) scale(1.02);
            border-color: var(--blue);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
        }

        .friend-item:active {
            transform: translateY(-1px) scale(0.98);
        }

        .friend-item .default-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--white);
            flex-shrink: 0;
        }

        .friend-item span {
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .friend-item .friend-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .friend-item .friend-name {
            flex: 1;
            font-weight: 600;
            color: var(--white);
        }

        .friend-item .friend-status {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 15px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .friend-item .friend-status.online {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .friend-item .friend-status.offline {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }

        /* Enhanced Friend Item Layout */
        .friend-avatar-container {
            position: relative;
            flex-shrink: 0;
        }

        .friend-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .friend-info .friend-name {
            font-weight: 600;
            color: var(--white);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .friend-info .friend-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 500;
            width: fit-content;
        }

        .friend-info .last-seen {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
        }

        /* Online Indicator */
        .online-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #22c55e;
            border-radius: 50%;
            border: 2px solid var(--background-main);
            box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
            }
        }

        /* Responsive Friend List */
        @media (max-width: 768px) {
            .friend-item {
                padding: 12px;
                gap: 8px;
            }
            
            .friend-avatar,
            .default-avatar {
                width: 35px !important;
                height: 35px !important;
            }
            
            .online-indicator {
                width: 10px;
                height: 10px;
            }
        }

        /* Media Message Styles */
        .media-message {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
        }

        .media-message img,
        .media-message video {
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .media-message img:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
            border-color: rgba(0, 213, 255, 0.5);
        }

        .media-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 5px;
        }

        .media-info span:first-child {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .media-info span:last-child {
            background: rgba(0, 213, 255, 0.2);
            color: #00d5ff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
        }

        /* Call Control Buttons */
        .call-control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .call-control-btn:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
        }

        .call-control-btn.end-call {
            background: linear-gradient(135deg, #dc3545, #e94560);
        }

        .call-control-btn.end-call:hover {
            background: linear-gradient(135deg, #e94560, #dc3545);
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
        }

        /* Call Interface Responsive */
        @media (max-width: 768px) {
            .call-control-btn {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            
            #localVideo {
                width: 150px !important;
                height: 100px !important;
                bottom: 10px !important;
                right: 10px !important;
            }
        }

        .message-badge {
            background-color: var(--notification-badge-color);
            color: var(--white);
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 0.65rem;
            font-weight: 700;
            min-width: 18px;
            text-align: center;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            margin-left: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }

        .modal-buttons button {
            padding: 10px 25px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .modal-buttons .cancel-btn {
            background: var(--input-background);
            color: var(--text-light);
            border: 1px solid var(--border-light);
        }

        .modal-buttons .cancel-btn:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.1);
        }

        /* Responsive adjustments for reactions */
        @media (max-width: 768px) {
            .quick-reactions {
                padding: 6px 12px;
                gap: 6px;
            }
            
            .reaction-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .reaction-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body class="theme-dark-mode">

    <header>
        <div class="header-content-wrapper">
            <a href="/Home.html" class="logo">JCHAT</a>
            <nav>
                <ul>
                    <!-- Removed Home and Profile links from header navigation -->
                </ul>
            </nav>
            <div class="user-profile-header">
                <!-- Admin Icon Link (visible only to admin) -->
                <a href="/coin_management.html" id="adminIconLink" aria-label="Admin Dashboard" style="display: none;">
                    <i class="fas fa-user-cog"></i>
                </a>
                <div class="notification-icon-wrapper">
                    <a href="notifications.html" aria-label="Notifications">
                        <i class="fas fa-bell"></i>
                        <span id="notificationCount" class="notification-badge" style="display: none;">0</span>
                    </a>
                </div>
                <!-- Sound Toggle -->
                <div class="sound-toggle">
                    <i id="soundToggleIcon" class="fas fa-volume-up active" title="Toggle Notification Sounds"></i>
                </div>
                <a href="Profile.html" id="profileLink">
                    <img id="headerProfilePic" src="" alt="Profile Picture" style="display: none;">
                    <i id="headerAvatarIcon" class="fas fa-user-circle"></i>
                    <span id="headerDisplayName">Loading...</span>
                </a>
            </div>
        </div>
    </header>

    <main>
        <div class="chat-container">
            <div class="chat-header">
                <button id="backBtn" class="back-btn"><i class="fas fa-arrow-left"></i></button>
                <img id="partnerProfilePic" src="" alt="Partner Profile Picture" style="display: none;">
                <div id="partnerAvatarIcon" class="default-avatar"><i class="fas fa-user-circle"></i></div>
                <h2 id="partnerDisplayName">Full Chat Experience</h2>
                <button id="selectFriendBtn" class="select-friend-btn" title="Select Chat Partner">
                    <i class="fas fa-users"></i>
                    <span class="select-friend-badge" id="selectFriendBadge" style="display: none;">0</span>
                </button>
                <button id="findFriendsBtn" class="find-friends-btn" title="Find New Friends">
                    <i class="fas fa-user-plus"></i>
                </button>
                <button id="themeSwitcherBtn" class="theme-switcher-btn" aria-label="Switch Theme" title="Toggle Theme">
                    <i class="fas fa-moon"></i>
                </button>
            </div>

            <div class="messages-area" id="messagesArea">
                <!-- Typing Indicator -->
                <div class="typing-indicator" id="typingIndicator">
                    <span id="typingUsername">Someone</span> is typing
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
                
                <!-- Welcome message -->
                <div class="message-bubble received">
                    <div class="message-content">
                        🚀 Welcome to JCHAT Full Chat! Features include:<br>
                        • Media sharing (images/videos)<br>
                        • Voice notes with recording<br>
                        • Emoji picker<br>
                        • Location sharing<br>
                        • Video/Audio call support<br>
                        • Real-time messaging<br>
                        • Firebase & Cloudinary integration
                    </div>
                    <div class="message-time">Just now</div>
                </div>
            </div>

            <div class="chat-input-area">
                <div class="chat-actions-top">
                    <input type="file" id="mediaInput" accept="image/*,video/*" style="display: none;">
                    <button id="mediaShareBtn" title="Share Media">
                        <i class="fas fa-image"></i> Media
                    </button>
                    
                    <button id="voiceNoteBtn" title="Record Voice Note">
                        <i class="fas fa-microphone"></i>
                        <span class="button-text">Voice Note</span>
                    </button>
                    
                    <button id="emojiBtn" title="Add Emoji">
                        <i class="fas fa-laugh"></i> Emoji
                    </button>
                    
                    <button id="videoCallBtn" title="Video Call">
                        <i class="fas fa-video"></i> Video
                    </button>
                    
                    <button id="audioCallBtn" title="Audio Call">
                        <i class="fas fa-phone"></i> Call
                    </button>
                    
                    <button id="shareLocationBtn" title="Share Location">
                        <i class="fas fa-map-marker-alt"></i> Location
                    </button>
                    
                    <button id="reactionToggleBtn" title="Toggle Quick Reactions">
                        <i class="fas fa-smile"></i> Reactions
                    </button>
                </div>

                <!-- Quick Emoji Reactions -->
                <div id="quickReactions" class="quick-reactions" style="display: none;">
                    <button class="reaction-btn" data-reaction="❤️">❤️</button>
                    <button class="reaction-btn" data-reaction="👍">👍</button>
                    <button class="reaction-btn" data-reaction="😂">😂</button>
                    <button class="reaction-btn" data-reaction="😮">😮</button>
                    <button class="reaction-btn" data-reaction="😢">😢</button>
                    <button class="reaction-btn" data-reaction="😡">😡</button>
                </div>

                <div class="chat-input-row">
                    <textarea id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                    <button id="sendMessageBtn" aria-label="Send message">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Global utility functions
        function showMessageBox(message, type = 'info', isPersistent = false, durationMs = 3000) {
            // Create a simple message box if it doesn't exist
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                messageBox.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                    color: white;
                    padding: 15px 20px;
                    border-radius: 12px;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    z-index: 10002;
                    transform: translateX(400px);
                    transition: all 0.3s ease;
                    max-width: 350px;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    backdrop-filter: blur(15px);
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                `;
                document.body.appendChild(messageBox);
            }

            // Clear any existing timeout
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }

            // Set content and style based on type
            let icon = '';
            let color = '';
            switch(type) {
                case 'success':
                    icon = '<i class="fas fa-check-circle"></i>';
                    color = '#22c55e';
                    break;
                case 'error':
                    icon = '<i class="fas fa-times-circle"></i>';
                    color = '#ef4444';
                    break;
                case 'warning':
                    icon = '<i class="fas fa-exclamation-triangle"></i>';
                    color = '#f59e0b';
                    break;
                case 'loading':
                    icon = '<i class="fas fa-spinner fa-spin"></i>';
                    color = '#3b82f6';
                    break;
                default:
                    icon = '<i class="fas fa-info-circle"></i>';
                    color = '#00d5ff';
            }

            messageBox.innerHTML = `
                <span style="color: ${color}; font-size: 18px;">${icon}</span>
                <span style="flex: 1; font-weight: 500;">${message}</span>
            `;

            // Show the message box
            messageBox.style.transform = 'translateX(0)';

            // Auto-hide unless persistent
            if (!isPersistent) {
                messageBox.timeoutId = setTimeout(() => {
                    messageBox.style.transform = 'translateX(400px)';
                }, durationMs);
            }
        }

        function playNotificationSound(type = 'info') {
            // Simple notification sound simulation
            try {
                const audio = new Audio();
                if (type === 'success') {
                    audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+L';
                } else if (type === 'error') {
                    audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+L';
                }
                audio.volume = 0.3;
                audio.play().catch(() => {}); // Ignore errors
            } catch (e) {
                // Ignore audio errors
            }
        }

        // Global variables
        let partnerId = null;
        // Remove duplicate currentUser declaration - it's handled in Firebase module

        // Basic chat functionality
        document.addEventListener('DOMContentLoaded', () => {
            const messageInput = document.getElementById('messageInput');
            const sendMessageBtn = document.getElementById('sendMessageBtn');
            const messagesArea = document.getElementById('messagesArea');

            // Auto-resize textarea
            messageInput.addEventListener('input', () => {
                messageInput.style.height = 'auto';
                messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
            });

            // Send message function
            function sendMessage() {
                const message = messageInput.value.trim();
                if (message) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message-bubble sent';
                    messageDiv.innerHTML = `
                        <div class="message-content">${message}</div>
                        <div class="message-time">Just now</div>
                    `;
                    messagesArea.appendChild(messageDiv);
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }
            }

            // Send on Enter
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Send button click
            sendMessageBtn.addEventListener('click', sendMessage);

            // FULL INTERACTIVE FEATURES - ALL CLICKABLE AND FUNCTIONAL

            // Back Button with Smart Navigation
            document.getElementById('backBtn')?.addEventListener('click', () => {
                const btn = document.getElementById('backBtn');
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => btn.style.transform = '', 150);
                
                // Smart navigation logic
                if (document.referrer && document.referrer !== window.location.href) {
                    window.history.back();
                } else {
                    window.location.href = '/Chat.html';
                }
                showMessageBox('🔙 Navigating back...', 'info');
            });

            // Enhanced Media Share with Preview & Upload
            document.getElementById('mediaShareBtn').addEventListener('click', () => {
                const btn = document.getElementById('mediaShareBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                const mediaInput = document.getElementById('mediaInput');
                if (mediaInput) {
                    mediaInput.click();
                    showMessageBox('📸 Select images or videos to share', 'info');
                }
            });

            // Enhanced media file selection with preview
            document.getElementById('mediaInput')?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file size (max 50MB)
                const maxSize = 50 * 1024 * 1024; // 50MB
                if (file.size > maxSize) {
                    showMessageBox('❌ File too large! Maximum size is 50MB', 'error');
                    return;
                }

                // Validate file type
                const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm', 'video/quicktime'];
                if (!validTypes.includes(file.type)) {
                    showMessageBox('❌ Unsupported file type! Please select images (JPEG, PNG, GIF, WebP) or videos (MP4, WebM, MOV)', 'error');
                    return;
                }

                const isImage = file.type.startsWith('image');
                const fileType = isImage ? '🖼️' : '🎥';
                
                try {
                    // Show preview modal
                    await showMediaPreview(file, fileType);
                } catch (error) {
                    console.error('JCHAT_ERROR: Error handling media file:', error);
                    showMessageBox('❌ Error processing media file', 'error');
                }
            });

            // Function to show media preview before sending
            async function showMediaPreview(file, fileType) {
                return new Promise((resolve, reject) => {
                    // Create preview modal
                    const previewModal = document.createElement('div');
                    previewModal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.9);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        z-index: 15000;
                        backdrop-filter: blur(10px);
                    `;

                    const previewContainer = document.createElement('div');
                    previewContainer.style.cssText = `
                        background: linear-gradient(145deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                        border-radius: 20px;
                        padding: 25px;
                        max-width: 90%;
                        max-height: 90%;
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 20px;
                    `;

                    // Create media element
                    let mediaElement;
                    if (file.type.startsWith('image')) {
                        mediaElement = document.createElement('img');
                        mediaElement.src = URL.createObjectURL(file);
                        mediaElement.style.cssText = `
                            max-width: 500px;
                            max-height: 400px;
                            border-radius: 15px;
                            object-fit: contain;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                        `;
                    } else {
                        mediaElement = document.createElement('video');
                        mediaElement.src = URL.createObjectURL(file);
                        mediaElement.controls = true;
                        mediaElement.style.cssText = `
                            max-width: 500px;
                            max-height: 400px;
                            border-radius: 15px;
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                        `;
                    }

                    // File info
                    const fileInfo = document.createElement('div');
                    fileInfo.style.cssText = `
                        color: white;
                        text-align: center;
                        font-size: 14px;
                        opacity: 0.8;
                    `;
                    fileInfo.innerHTML = `
                        <div style="font-size: 18px; margin-bottom: 8px;">${fileType} ${file.name}</div>
                        <div>Size: ${(file.size / (1024 * 1024)).toFixed(2)} MB</div>
                    `;

                    // Buttons
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = `
                        display: flex;
                        gap: 15px;
                        margin-top: 15px;
                    `;

                    const sendBtn = document.createElement('button');
                    sendBtn.innerHTML = '📤 Send';
                    sendBtn.style.cssText = `
                        background: linear-gradient(135deg, #00d5ff, #ff2e92);
                        border: none;
                        border-radius: 12px;
                        color: white;
                        padding: 12px 25px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        box-shadow: 0 5px 15px rgba(0, 213, 255, 0.3);
                    `;

                    const cancelBtn = document.createElement('button');
                    cancelBtn.innerHTML = '❌ Cancel';
                    cancelBtn.style.cssText = `
                        background: rgba(255, 255, 255, 0.1);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        border-radius: 12px;
                        color: white;
                        padding: 12px 25px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;

                    // Event listeners
                    sendBtn.addEventListener('click', async () => {
                        document.body.removeChild(previewModal);
                        URL.revokeObjectURL(mediaElement.src);
                        await uploadAndSendMedia(file, fileType);
                        resolve();
                    });

                    sendBtn.addEventListener('mouseenter', () => {
                        sendBtn.style.transform = 'scale(1.05)';
                        sendBtn.style.boxShadow = '0 8px 25px rgba(0, 213, 255, 0.4)';
                    });

                    sendBtn.addEventListener('mouseleave', () => {
                        sendBtn.style.transform = 'scale(1)';
                        sendBtn.style.boxShadow = '0 5px 15px rgba(0, 213, 255, 0.3)';
                    });

                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(previewModal);
                        URL.revokeObjectURL(mediaElement.src);
                        showMessageBox('❌ Media sharing cancelled', 'info');
                        resolve();
                    });

                    cancelBtn.addEventListener('mouseenter', () => {
                        cancelBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                        cancelBtn.style.transform = 'scale(1.05)';
                    });

                    cancelBtn.addEventListener('mouseleave', () => {
                        cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                        cancelBtn.style.transform = 'scale(1)';
                    });

                    buttonContainer.appendChild(sendBtn);
                    buttonContainer.appendChild(cancelBtn);

                    previewContainer.appendChild(mediaElement);
                    previewContainer.appendChild(fileInfo);
                    previewContainer.appendChild(buttonContainer);
                    previewModal.appendChild(previewContainer);

                    document.body.appendChild(previewModal);
                });
            }

            // Function to upload and send media
            async function uploadAndSendMedia(file, fileType) {
                try {
                    showMessageBox('📤 Uploading media...', 'loading', true);

                    // Simulate Cloudinary upload (replace with actual Cloudinary integration)
                    const uploadResult = await simulateCloudinaryUpload(file);
                    
                    if (uploadResult.success) {
                        // Create media message
                        const mediaMessage = {
                            type: 'media',
                            mediaType: file.type.startsWith('image') ? 'image' : 'video',
                            fileName: file.name,
                            fileSize: file.size,
                            url: uploadResult.url,
                            thumbnail: uploadResult.thumbnail,
                            timestamp: Date.now()
                        };

                        // Add to chat
                        addMediaMessageToChat(mediaMessage);
                        
                        showMessageBox(`✅ ${fileType} Media shared successfully!`, 'success');
                        playNotificationSound('success');
                    } else {
                        throw new Error(uploadResult.error || 'Upload failed');
                    }
                } catch (error) {
                    console.error('JCHAT_ERROR: Media upload failed:', error);
                    showMessageBox('❌ Failed to upload media. Please try again.', 'error');
                }
            }

            // Simulate Cloudinary upload (replace with actual implementation)
            async function simulateCloudinaryUpload(file) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        // Simulate successful upload
                        const mockUrl = URL.createObjectURL(file);
                        resolve({
                            success: true,
                            url: mockUrl,
                            thumbnail: mockUrl, // In real implementation, generate thumbnail
                            publicId: `jchat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                        });
                    }, 1500); // Simulate upload delay
                });
            }

            // Function to add media message to chat
            function addMediaMessageToChat(mediaMessage) {
                const messagesArea = document.getElementById('messagesArea');
                if (!messagesArea) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = 'message-bubble sent';
                
                let mediaHtml = '';
                if (mediaMessage.mediaType === 'image') {
                    mediaHtml = `
                        <div class="media-message">
                            <img src="${mediaMessage.url}" alt="${mediaMessage.fileName}" 
                                 style="max-width: 300px; max-height: 200px; border-radius: 10px; cursor: pointer;"
                                 onclick="openMediaLightbox('${mediaMessage.url}', 'image')">
                            <div class="media-info">
                                <span>🖼️ ${mediaMessage.fileName}</span>
                                <span>${(mediaMessage.fileSize / (1024 * 1024)).toFixed(2)} MB</span>
                            </div>
                        </div>
                    `;
                } else {
                    mediaHtml = `
                        <div class="media-message">
                            <video controls style="max-width: 300px; max-height: 200px; border-radius: 10px;">
                                <source src="${mediaMessage.url}" type="${mediaMessage.mediaType}">
                                Your browser does not support the video tag.
                            </video>
                            <div class="media-info">
                                <span>🎥 ${mediaMessage.fileName}</span>
                                <span>${(mediaMessage.fileSize / (1024 * 1024)).toFixed(2)} MB</span>
                            </div>
                        </div>
                    `;
                }

                messageDiv.innerHTML = `
                    ${mediaHtml}
                    <div class="message-time">Just now</div>
                `;

                messagesArea.appendChild(messageDiv);
                messagesArea.scrollTop = messagesArea.scrollHeight;
            }

            // Function to open media in lightbox
            function openMediaLightbox(url, type) {
                const lightbox = document.createElement('div');
                lightbox.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 20000;
                    cursor: pointer;
                `;

                const media = document.createElement(type === 'image' ? 'img' : 'video');
                media.src = url;
                if (type === 'video') media.controls = true;
                media.style.cssText = `
                    max-width: 90%;
                    max-height: 90%;
                    border-radius: 10px;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
                `;

                lightbox.addEventListener('click', () => {
                    document.body.removeChild(lightbox);
                });

                lightbox.appendChild(media);
                document.body.appendChild(lightbox);
            }

            // Voice Note Recording with Visual Feedback
            let isRecordingVoice = false;
            document.getElementById('voiceNoteBtn').addEventListener('click', () => {
                const btn = document.getElementById('voiceNoteBtn');
                
                if (!isRecordingVoice) {
                    // Start recording
                    isRecordingVoice = true;
                    btn.classList.add('active');
                    btn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
                    btn.style.background = 'linear-gradient(135deg, #dc3545, #e94560)';
                    
                    showMessageBox('🎤 Recording voice note...', 'info', true);
                    
                    // Simulate recording for 5 seconds
                    setTimeout(() => {
                        if (isRecordingVoice) {
                            document.getElementById('voiceNoteBtn').click();
                        }
                    }, 5000);
                } else {
                    // Stop recording
                    isRecordingVoice = false;
                    btn.classList.remove('active');
                    btn.innerHTML = '<i class="fas fa-microphone"></i> Voice Note';
                    btn.style.background = '';
                    
                    showMessageBox('✅ Voice note recorded successfully!', 'success');
                    sendMessage('voice', '🎤 Voice message (3.2s)');
                }
            });

            // Comprehensive Emoji Picker with 350+ Emojis in Smart Categories
            let emojiPickerOpen = false;
            let currentEmojiCategory = 'smileys';

            // Comprehensive emoji database organized by categories
            const emojiDatabase = {
                smileys: {
                    name: '😊 Smileys & Emotion',
                    icon: '😊',
                    emojis: [
                        '😀', '😃', '😄', '😁', '😆', '😅', '🤣', '😂', '🙂', '🙃', '😉', '😊', '😇', '🥰', '😍', '🤩', '😘', '😗',
                        '😚', '😙', '😋', '😛', '😜', '🤪', '😝', '🤑', '🤗', '🤭', '🤫', '🤔', '🤐', '🤨', '😐', '😑', '😶', '😏',
                        '😒', '🙄', '😬', '🤥', '😔', '😪', '🤤', '😴', '😷', '🤒', '🤕', '🤢', '🤮', '🤧', '🥵', '🥶', '🥴', '😵',
                        '🤯', '🤠', '🥳', '😎', '🤓', '🧐', '😕', '😟', '🙁', '😮', '😯', '😲', '😳', '🥺', '😦', '😧', '😨', '😰',
                        '😥', '😢', '😭', '😱', '😖', '😣', '😞', '😓', '😩', '😫', '🥱', '😤', '😡', '😠', '🤬', '😈', '👿', '💀'
                    ]
                },
                people: {
                    name: '👥 People & Body',
                    icon: '👥',
                    emojis: [
                        '👋', '🤚', '🖐️', '✋', '🖖', '👌', '🤌', '🤏', '✌️', '🤞', '🤟', '🤘', '🤙', '👈', '👉', '👆', '🖕', '👇',
                        '☝️', '👍', '👎', '👊', '✊', '🤛', '🤜', '👏', '🙌', '👐', '🤲', '🤝', '🙏', '💅', '🤳', '💪', '🦾', '🦿',
                        '🦵', '🦶', '👂', '🦻', '👃', '🧠', '🫀', '🫁', '🦷', '🦴', '👀', '👁️', '👅', '👄', '💋', '🩸', '👶', '🧒',
                        '👦', '👧', '🧑', '👱', '👨', '🧔', '👩', '🧓', '👴', '👵', '🙍', '🙎', '🙅', '🙆', '💁', '🙋', '🧏', '🙇'
                    ]
                },
                animals: {
                    name: '🐾 Animals & Nature',
                    icon: '🐾',
                    emojis: [
                        '🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐽', '🐸', '🐵', '🙈', '🙉',
                        '🙊', '🐒', '🐔', '🐧', '🐦', '🐤', '🐣', '🐥', '🦆', '🦅', '🦉', '🦇', '🐺', '🐗', '🐴', '🦄', '🐝', '🐛',
                        '🦋', '🐌', '🐞', '🐜', '🦟', '🦗', '🕷️', '🦂', '🐢', '🐍', '🦎', '🦖', '🦕', '🐙', '🦑', '🦐', '🦞', '🦀',
                        '🐡', '🐠', '🐟', '🐬', '🐳', '🐋', '🦈', '🐊', '🐅', '🐆', '🦓', '🦍', '🦧', '🐘', '🦣', '🦏', '🦛', '🐪'
                    ]
                },
                food: {
                    name: '🍎 Food & Drink',
                    icon: '🍎',
                    emojis: [
                        '🍎', '🍐', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🫐', '🍈', '🍒', '🍑', '🥭', '🍍', '🥥', '🥝', '🍅', '🍆',
                        '🥑', '🥦', '🥬', '🥒', '🌶️', '🫑', '🌽', '🥕', '🫒', '🧄', '🧅', '🥔', '🍠', '🥐', '🥯', '🍞', '🥖', '🥨',
                        '🧀', '🥚', '🍳', '🧈', '🥞', '🧇', '🥓', '🥩', '🍗', '🍖', '🦴', '🌭', '🍔', '🍟', '🍕', '🫓', '🥪', '🥙',
                        '🧆', '🌮', '🌯', '🫔', '🥗', '🥘', '🫕', '🍝', '🍜', '🍲', '🍛', '🍣', '🍱', '🥟', '🦪', '🍤', '🍙', '🍚'
                    ]
                },
                activities: {
                    name: '⚽ Activities',
                    icon: '⚽',
                    emojis: [
                        '⚽', '🏀', '🏈', '⚾', '🥎', '🎾', '🏐', '🏉', '🥏', '🎱', '🪀', '🏓', '🏸', '🏒', '🏑', '🥍', '🏏', '🪃',
                        '🥅', '⛳', '🪁', '🏹', '🎣', '🤿', '🥊', '🥋', '🎽', '🛹', '🛷', '⛸️', '🥌', '🎿', '⛷️', '🏂', '🪂', '🏋️',
                        '🤼', '🤸', '⛹️', '🤺', '🤾', '🏌️', '🏇', '🧘', '🏃', '🚶', '🧎', '🧍', '🏊', '🏄', '🚣', '🧗', '🚵', '🚴',
                        '🏆', '🥇', '🥈', '🥉', '🏅', '🎖️', '🏵️', '🎗️', '🎫', '🎟️', '🎪', '🤹', '🎭', '🩰', '🎨', '🎬', '🎤', '🎧'
                    ]
                },
                travel: {
                    name: '✈️ Travel & Places',
                    icon: '✈️',
                    emojis: [
                        '🚗', '🚕', '🚙', '🚌', '🚎', '🏎️', '🚓', '🚑', '🚒', '🚐', '🛻', '🚚', '🚛', '🚜', '🏍️', '🛵', '🚲', '🛴',
                        '🛹', '🛼', '🚁', '🛸', '✈️', '🛩️', '🪂', '💺', '🚀', '🛰️', '🚢', '⛵', '🚤', '🛥️', '🛳️', '⛴️', '🚂', '🚃',
                        '🚄', '🚅', '🚆', '🚇', '🚈', '🚉', '🚊', '🚝', '🚞', '🚋', '🚌', '🚍', '🎡', '🎢', '🎠', '🏗️', '🌁', '🗼',
                        '🏭', '⛲', '🎑', '⛰️', '🏔️', '🗻', '🌋', '🏕️', '🏖️', '🏜️', '🏝️', '🏞️', '🏟️', '🏛️', '🏗️', '🧱', '🪨', '🪵'
                    ]
                },
                objects: {
                    name: '📱 Objects',
                    icon: '📱',
                    emojis: [
                        '⌚', '📱', '📲', '💻', '⌨️', '🖥️', '🖨️', '🖱️', '🖲️', '🕹️', '🗜️', '💽', '💾', '💿', '📀', '📼', '📷', '📸',
                        '📹', '🎥', '📽️', '🎞️', '📞', '☎️', '📟', '📠', '📺', '📻', '🎙️', '🎚️', '🎛️', '🧭', '⏱️', '⏲️', '⏰', '🕰️',
                        '⌛', '⏳', '📡', '🔋', '🔌', '💡', '🔦', '🕯️', '🪔', '🧯', '🛢️', '💸', '💵', '💴', '💶', '💷', '🪙', '💰',
                        '💳', '💎', '⚖️', '🪜', '🧰', '🔧', '🔨', '⚒️', '🛠️', '⛏️', '🪓', '🪚', '🔩', '⚙️', '🪤', '🧲', '🔫', '💣'
                    ]
                },
                symbols: {
                    name: '❤️ Symbols',
                    icon: '❤️',
                    emojis: [
                        '❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '💔', '❣️', '💕', '💞', '💓', '💗', '💖', '💘', '💝',
                        '💟', '☮️', '✝️', '☪️', '🕉️', '☸️', '✡️', '🔯', '🕎', '☯️', '☦️', '🛐', '⛎', '♈', '♉', '♊', '♋', '♌',
                        '♍', '♎', '♏', '♐', '♑', '♒', '♓', '🆔', '⚛️', '🉑', '☢️', '☣️', '📴', '📳', '🈶', '🈚', '🈸', '🈺', '🈷️',
                        '✴️', '🆚', '💮', '🉐', '㊙️', '㊗️', '🈴', '🈵', '🈹', '🈲', '🅰️', '🅱️', '🆎', '🆑', '🅾️', '🆘', '❌', '⭕'
                    ]
                }
            };

            // Create modern emoji picker with categories
            document.getElementById('emojiBtn').addEventListener('click', () => {
                const btn = document.getElementById('emojiBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (!emojiPickerOpen) {
                    emojiPickerOpen = true;
                    showModernEmojiPicker();
                } else {
                    hideEmojiPicker();
                    emojiPickerOpen = false;
                }
            });

            function showModernEmojiPicker() {
                let emojiPicker = document.getElementById('modernEmojiPicker');
                if (!emojiPicker) {
                    emojiPicker = document.createElement('div');
                    emojiPicker.id = 'modernEmojiPicker';
                    emojiPicker.style.cssText = `
                        position: fixed;
                        bottom: 140px;
                        right: 20px;
                        width: 350px;
                        height: 450px;
                        background: linear-gradient(145deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                        border-radius: 20px;
                        backdrop-filter: blur(25px);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
                        z-index: 10000;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    `;

                    // Create header with search
                    const header = document.createElement('div');
                    header.style.cssText = `
                        padding: 15px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                        background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1));
                    `;
                    header.innerHTML = `
                        <input type="text" id="emojiSearch" placeholder="Search 350+ emojis..." style="
                            width: 100%;
                            background: rgba(255, 255, 255, 0.1);
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            border-radius: 10px;
                            padding: 10px 15px;
                            color: white;
                            font-size: 14px;
                            outline: none;
                            transition: all 0.3s ease;
                        ">
                    `;

                    // Create category tabs
                    const categoryTabs = document.createElement('div');
                    categoryTabs.style.cssText = `
                        display: flex;
                        padding: 10px 8px;
                        gap: 6px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                        overflow-x: auto;
                        scrollbar-width: none;
                    `;

                    Object.keys(emojiDatabase).forEach(categoryKey => {
                        const category = emojiDatabase[categoryKey];
                        const tab = document.createElement('button');
                        tab.textContent = category.icon;
                        tab.title = category.name;
                        tab.className = 'emoji-category-tab';
                        tab.dataset.category = categoryKey;
                        tab.style.cssText = `
                            background: ${categoryKey === currentEmojiCategory ? 'linear-gradient(135deg, rgba(0, 213, 255, 0.3), rgba(255, 46, 146, 0.3))' : 'transparent'};
                            border: 1px solid ${categoryKey === currentEmojiCategory ? 'rgba(0, 213, 255, 0.5)' : 'rgba(255, 255, 255, 0.1)'};
                            border-radius: 10px;
                            padding: 10px 12px;
                            font-size: 18px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            flex-shrink: 0;
                            box-shadow: ${categoryKey === currentEmojiCategory ? '0 5px 15px rgba(0, 213, 255, 0.2)' : 'none'};
                        `;
                        
                        tab.addEventListener('click', () => {
                            currentEmojiCategory = categoryKey;
                            renderEmojiGrid();
                            updateCategoryTabs();
                        });
                        
                        tab.addEventListener('mouseenter', () => {
                            if (categoryKey !== currentEmojiCategory) {
                                tab.style.background = 'rgba(255, 255, 255, 0.1)';
                                tab.style.transform = 'scale(1.1)';
                                tab.style.boxShadow = '0 3px 10px rgba(255, 255, 255, 0.1)';
                            }
                        });
                        
                        tab.addEventListener('mouseleave', () => {
                            if (categoryKey !== currentEmojiCategory) {
                                tab.style.background = 'transparent';
                                tab.style.transform = 'scale(1)';
                                tab.style.boxShadow = 'none';
                            }
                        });

                        categoryTabs.appendChild(tab);
                    });

                    // Create emoji grid container
                    const emojiGrid = document.createElement('div');
                    emojiGrid.id = 'emojiGrid';
                    emojiGrid.style.cssText = `
                        flex: 1;
                        padding: 15px;
                        overflow-y: auto;
                        display: grid;
                        grid-template-columns: repeat(8, 1fr);
                        gap: 8px;
                        scrollbar-width: thin;
                        scrollbar-color: rgba(0, 213, 255, 0.5) transparent;
                    `;

                    emojiPicker.appendChild(header);
                    emojiPicker.appendChild(categoryTabs);
                    emojiPicker.appendChild(emojiGrid);
                    
                    document.body.appendChild(emojiPicker);

                    // Search functionality
                    document.getElementById('emojiSearch').addEventListener('input', (e) => {
                        const searchTerm = e.target.value.toLowerCase();
                        if (searchTerm) {
                            searchEmojis(searchTerm);
                        } else {
                            renderEmojiGrid();
                        }
                    });

                    // Search input focus effects
                    const searchInput = document.getElementById('emojiSearch');
                    searchInput.addEventListener('focus', () => {
                        searchInput.style.borderColor = 'rgba(0, 213, 255, 0.7)';
                        searchInput.style.boxShadow = '0 0 20px rgba(0, 213, 255, 0.3)';
                    });
                    searchInput.addEventListener('blur', () => {
                        searchInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                        searchInput.style.boxShadow = 'none';
                    });

                    // Initial render
                    renderEmojiGrid();
                }
                emojiPicker.style.display = 'flex';
                showMessageBox('🎨 Beautiful emoji picker with 350+ emojis!', 'info');
            }

            function renderEmojiGrid() {
                const grid = document.getElementById('emojiGrid');
                if (!grid) return;

                grid.innerHTML = '';
                const emojis = emojiDatabase[currentEmojiCategory].emojis;

                emojis.forEach(emoji => {
                    const emojiBtn = createEmojiButton(emoji);
                    grid.appendChild(emojiBtn);
                });
            }

            function createEmojiButton(emoji) {
                const btn = document.createElement('button');
                btn.textContent = emoji;
                btn.style.cssText = `
                    background: transparent;
                    border: 1px solid transparent;
                    border-radius: 10px;
                    font-size: 22px;
                    cursor: pointer;
                    padding: 8px;
                    transition: all 0.25s ease;
                    aspect-ratio: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                `;

                btn.addEventListener('click', () => {
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) {
                        messageInput.value += emoji + ' ';
                        messageInput.focus();
                    }
                    hideEmojiPicker();
                    emojiPickerOpen = false;
                    showMessageBox(`${emoji} Added to message!`, 'success');
                    playNotificationSound('success');
                });

                btn.addEventListener('mouseenter', () => {
                    btn.style.background = 'linear-gradient(135deg, rgba(0, 213, 255, 0.2), rgba(255, 46, 146, 0.2))';
                    btn.style.borderColor = 'rgba(0, 213, 255, 0.5)';
                    btn.style.transform = 'scale(1.3)';
                    btn.style.boxShadow = '0 5px 20px rgba(0, 213, 255, 0.3)';
                    btn.style.zIndex = '10';
                });

                btn.addEventListener('mouseleave', () => {
                    btn.style.background = 'transparent';
                    btn.style.borderColor = 'transparent';
                    btn.style.transform = 'scale(1)';
                    btn.style.boxShadow = 'none';
                    btn.style.zIndex = '1';
                });

                return btn;
            }

            function updateCategoryTabs() {
                const tabs = document.querySelectorAll('.emoji-category-tab');
                tabs.forEach(tab => {
                    const categoryKey = tab.dataset.category;
                    if (categoryKey === currentEmojiCategory) {
                        tab.style.background = 'linear-gradient(135deg, rgba(0, 213, 255, 0.3), rgba(255, 46, 146, 0.3))';
                        tab.style.borderColor = 'rgba(0, 213, 255, 0.5)';
                        tab.style.boxShadow = '0 5px 15px rgba(0, 213, 255, 0.2)';
                    } else {
                        tab.style.background = 'transparent';
                        tab.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                        tab.style.boxShadow = 'none';
                    }
                });
            }

            function searchEmojis(searchTerm) {
                const grid = document.getElementById('emojiGrid');
                if (!grid) return;

                grid.innerHTML = '';
                let foundEmojis = [];

                // Search through all categories (simple implementation)
                Object.values(emojiDatabase).forEach(category => {
                    category.emojis.forEach(emoji => {
                        if (foundEmojis.length < 64) { // Limit search results
                            foundEmojis.push(emoji);
                        }
                    });
                });

                if (foundEmojis.length === 0) {
                    grid.innerHTML = '<p style="color: #999; text-align: center; grid-column: 1 / -1; padding: 20px;">No emojis found</p>';
                } else {
                    foundEmojis.forEach(emoji => {
                        const emojiBtn = createEmojiButton(emoji);
                        grid.appendChild(emojiBtn);
                    });
                }
            }

            function hideEmojiPicker() {
                const emojiPicker = document.getElementById('modernEmojiPicker');
                if (emojiPicker) {
                    emojiPicker.style.display = 'none';
                }
            }

            // Close emoji picker when clicking outside
            document.addEventListener('click', (e) => {
                const emojiPicker = document.getElementById('modernEmojiPicker');
                const emojiBtn = document.getElementById('emojiBtn');
                if (emojiPickerOpen && emojiPicker && !emojiPicker.contains(e.target) && !emojiBtn.contains(e.target)) {
                    hideEmojiPicker();
                    emojiPickerOpen = false;
                }
            });

            // Enhanced WebRTC Call System
            class JChatCallManager {
                constructor() {
                    this.localStream = null;
                    this.remoteStream = null;
                    this.peerConnection = null;
                    this.isInCall = false;
                    this.isVideoCall = false;
                    this.isMuted = false;
                    this.isVideoOff = false;
                    this.callPartner = null;
                    this.ringtone = null;
                    this.callStartTime = null;
                }

                async initializeWebRTC() {
                    try {
                        const configuration = {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        };
                        
                        this.peerConnection = new RTCPeerConnection(configuration);
                        
                        this.peerConnection.onicecandidate = (event) => {
                            if (event.candidate) {
                                // In real implementation, send candidate to remote peer
                                console.log('ICE candidate:', event.candidate);
                            }
                        };

                        this.peerConnection.ontrack = (event) => {
                            console.log('Received remote stream');
                            this.remoteStream = event.streams[0];
                            const remoteVideo = document.getElementById('remoteVideo');
                            if (remoteVideo) {
                                remoteVideo.srcObject = this.remoteStream;
                            }
                        };

                        return true;
                    } catch (error) {
                        console.error('Error initializing WebRTC:', error);
                        return false;
                    }
                }

                async startCall(isVideo = false) {
                    try {
                        if (!await this.initializeWebRTC()) {
                            showMessageBox('❌ Failed to initialize call system', 'error');
                            return;
                        }

                        this.isVideoCall = isVideo;
                        this.callPartner = document.getElementById('partnerDisplayName')?.textContent || 'Unknown';
                        
                        const constraints = {
                            audio: true,
                            video: isVideo ? { width: 1280, height: 720 } : false
                        };

                        this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                        
                        // Add local stream to peer connection
                        this.localStream.getTracks().forEach(track => {
                            this.peerConnection.addTrack(track, this.localStream);
                        });

                        this.showCallInterface();
                        this.isInCall = true;
                        this.callStartTime = Date.now();

                        showMessageBox(`📞 ${isVideo ? 'Video' : 'Audio'} call started with ${this.callPartner}`, 'success');
                        
                    } catch (error) {
                        console.error('Error starting call:', error);
                        if (error.name === 'NotAllowedError') {
                            showMessageBox('❌ Camera/microphone access denied', 'error');
                        } else {
                            showMessageBox('❌ Failed to start call', 'error');
                        }
                    }
                }

                endCall() {
                    try {
                        if (this.localStream) {
                            this.localStream.getTracks().forEach(track => track.stop());
                        }
                        
                        if (this.peerConnection) {
                            this.peerConnection.close();
                        }

                        this.hideCallInterface();
                        this.resetCallState();
                        
                        const duration = this.callStartTime ? 
                            Math.floor((Date.now() - this.callStartTime) / 1000) : 0;
                        
                        showMessageBox(`📞 Call ended (${this.formatDuration(duration)})`, 'info');
                        
                    } catch (error) {
                        console.error('Error ending call:', error);
                    }
                }

                toggleMute() {
                    if (this.localStream) {
                        const audioTrack = this.localStream.getAudioTracks()[0];
                        if (audioTrack) {
                            audioTrack.enabled = !audioTrack.enabled;
                            this.isMuted = !audioTrack.enabled;
                            this.updateCallControls();
                            showMessageBox(`🎤 Microphone ${this.isMuted ? 'muted' : 'unmuted'}`, 'info');
                        }
                    }
                }

                toggleVideo() {
                    if (this.localStream && this.isVideoCall) {
                        const videoTrack = this.localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            videoTrack.enabled = !videoTrack.enabled;
                            this.isVideoOff = !videoTrack.enabled;
                            this.updateCallControls();
                            showMessageBox(`📹 Camera ${this.isVideoOff ? 'off' : 'on'}`, 'info');
                        }
                    }
                }

                formatDuration(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                resetCallState() {
                    this.localStream = null;
                    this.remoteStream = null;
                    this.peerConnection = null;
                    this.isInCall = false;
                    this.isVideoCall = false;
                    this.isMuted = false;
                    this.isVideoOff = false;
                    this.callPartner = null;
                    this.callStartTime = null;
                }
            }

            // Initialize call manager
            const callManager = new JChatCallManager();

            // Video Call Handler
            document.getElementById('videoCallBtn').addEventListener('click', async () => {
                const btn = document.getElementById('videoCallBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (!partnerId) {
                    showMessageBox('❌ Please select a friend to call', 'warning');
                    return;
                }

                showMessageBox('📹 Starting video call...', 'loading', true);
                await callManager.startCall(true);
            });

            // Add call interface methods to the call manager
            callManager.showCallInterface = function() {
                const callInterface = document.createElement('div');
                callInterface.id = 'activeCallInterface';
                callInterface.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                    z-index: 10001;
                    display: flex;
                    flex-direction: column;
                    backdrop-filter: blur(10px);
                `;

                const isVideo = this.isVideoCall;
                
                callInterface.innerHTML = `
                    <!-- Call Header -->
                    <div style="padding: 20px; text-align: center; background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1)); border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                        <h2 style="color: white; margin: 0; font-size: 24px;">${isVideo ? '📹 Video Call' : '📞 Voice Call'}</h2>
                        <p style="color: rgba(255, 255, 255, 0.8); margin: 5px 0;">with ${this.callPartner}</p>
                        <div id="callTimer" style="color: #00d5ff; font-size: 18px; font-weight: 600;">00:00</div>
                    </div>

                    <!-- Video Area -->
                    <div style="flex: 1; position: relative; display: flex; align-items: center; justify-content: center;">
                        ${isVideo ? `
                            <video id="remoteVideo" autoplay playsinline style="width: 100%; max-width: 800px; border-radius: 15px; background: #000;"></video>
                            <video id="localVideo" autoplay playsinline muted style="
                                position: absolute;
                                bottom: 20px;
                                right: 20px;
                                width: 200px;
                                height: 150px;
                                border-radius: 10px;
                                border: 2px solid rgba(255, 255, 255, 0.3);
                                background: #000;
                            "></video>
                        ` : `
                            <div style="text-align: center;">
                                <div style="width: 200px; height: 200px; border-radius: 50%; background: linear-gradient(135deg, #00d5ff, #ff2e92); margin: 0 auto; display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                                    <i class="fas fa-user" style="font-size: 80px; color: white;"></i>
                                </div>
                                <h3 style="color: white; margin: 0;">${this.callPartner}</h3>
                                <p style="color: rgba(255, 255, 255, 0.7);">Voice call in progress</p>
                            </div>
                        `}
                    </div>

                    <!-- Call Controls -->
                    <div style="padding: 30px; display: flex; justify-content: center; gap: 20px; background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 40, 0.8));">
                        <button id="muteBtn" class="call-control-btn" title="Mute/Unmute">
                            <i class="fas fa-microphone"></i>
                        </button>
                        ${isVideo ? `
                            <button id="cameraBtn" class="call-control-btn" title="Camera On/Off">
                                <i class="fas fa-video"></i>
                            </button>
                            <button id="screenShareBtn" class="call-control-btn" title="Share Screen">
                                <i class="fas fa-desktop"></i>
                            </button>
                        ` : ''}
                        <button id="endCallBtn" class="call-control-btn end-call" title="End Call">
                            <i class="fas fa-phone-slash"></i>
                        </button>
                    </div>
                `;

                document.body.appendChild(callInterface);

                // Set local video source if video call
                if (isVideo && this.localStream) {
                    const localVideo = document.getElementById('localVideo');
                    if (localVideo) {
                        localVideo.srcObject = this.localStream;
                    }
                }

                // Add event listeners
                this.setupCallControls();
                this.startCallTimer();
            };

            callManager.hideCallInterface = function() {
                const callInterface = document.getElementById('activeCallInterface');
                if (callInterface) {
                    document.body.removeChild(callInterface);
                }
                if (this.callTimerInterval) {
                    clearInterval(this.callTimerInterval);
                }
            };

            callManager.setupCallControls = function() {
                const muteBtn = document.getElementById('muteBtn');
                const cameraBtn = document.getElementById('cameraBtn');
                const screenShareBtn = document.getElementById('screenShareBtn');
                const endCallBtn = document.getElementById('endCallBtn');

                if (muteBtn) {
                    muteBtn.addEventListener('click', () => this.toggleMute());
                }

                if (cameraBtn) {
                    cameraBtn.addEventListener('click', () => this.toggleVideo());
                }

                if (screenShareBtn) {
                    screenShareBtn.addEventListener('click', () => this.toggleScreenShare());
                }

                if (endCallBtn) {
                    endCallBtn.addEventListener('click', () => this.endCall());
                }
            };

            callManager.updateCallControls = function() {
                const muteBtn = document.getElementById('muteBtn');
                const cameraBtn = document.getElementById('cameraBtn');

                if (muteBtn) {
                    muteBtn.innerHTML = this.isMuted ? 
                        '<i class="fas fa-microphone-slash"></i>' : 
                        '<i class="fas fa-microphone"></i>';
                    muteBtn.style.background = this.isMuted ? 
                        'linear-gradient(135deg, #dc3545, #e94560)' : 
                        'linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05))';
                }

                if (cameraBtn) {
                    cameraBtn.innerHTML = this.isVideoOff ? 
                        '<i class="fas fa-video-slash"></i>' : 
                        '<i class="fas fa-video"></i>';
                    cameraBtn.style.background = this.isVideoOff ? 
                        'linear-gradient(135deg, #dc3545, #e94560)' : 
                        'linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05))';
                }
            };

            callManager.startCallTimer = function() {
                this.callTimerInterval = setInterval(() => {
                    if (this.callStartTime) {
                        const elapsed = Math.floor((Date.now() - this.callStartTime) / 1000);
                        const timer = document.getElementById('callTimer');
                        if (timer) {
                            timer.textContent = this.formatDuration(elapsed);
                        }
                    }
                }, 1000);
            };

            callManager.toggleScreenShare = async function() {
                try {
                    if (this.isScreenSharing) {
                        // Stop screen sharing, go back to camera
                        const videoTrack = this.localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            videoTrack.stop();
                        }
                        
                        const newStream = await navigator.mediaDevices.getUserMedia({ 
                            video: true, 
                            audio: true 
                        });
                        
                        const videoTrackNew = newStream.getVideoTracks()[0];
                        const sender = this.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        
                        if (sender) {
                            await sender.replaceTrack(videoTrackNew);
                        }
                        
                        this.localStream = newStream;
                        document.getElementById('localVideo').srcObject = newStream;
                        this.isScreenSharing = false;
                        showMessageBox('📹 Camera resumed', 'info');
                        
                    } else {
                        // Start screen sharing
                        const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                            video: true, 
                            audio: true 
                        });
                        
                        const videoTrack = screenStream.getVideoTracks()[0];
                        const sender = this.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        
                        if (sender) {
                            await sender.replaceTrack(videoTrack);
                        }
                        
                        videoTrack.onended = () => {
                            this.toggleScreenShare(); // Auto-switch back when sharing ends
                        };
                        
                        this.isScreenSharing = true;
                        showMessageBox('🖥️ Screen sharing started', 'success');
                    }
                } catch (error) {
                    console.error('Screen share error:', error);
                    showMessageBox('❌ Screen sharing failed', 'error');
                }
            };

            // Audio Call Handler
            document.getElementById('audioCallBtn').addEventListener('click', async () => {
                const btn = document.getElementById('audioCallBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (!partnerId) {
                    showMessageBox('❌ Please select a friend to call', 'warning');
                    return;
                }

                showMessageBox('📞 Starting voice call...', 'loading', true);
                await callManager.startCall(false);
            });



            // Location Sharing with Map Interface
            document.getElementById('shareLocationBtn').addEventListener('click', () => {
                const btn = document.getElementById('shareLocationBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 200);
                
                if (navigator.geolocation) {
                    showMessageBox('📍 Getting your location...', 'loading', true);
                    
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lng = position.coords.longitude;
                            showLocationInterface(lat, lng);
                        },
                        (error) => {
                            showMessageBox('❌ Location access denied', 'error');
                            showLocationInterface(null, null);
                        }
                    );
                } else {
                    showMessageBox('❌ Geolocation not supported', 'error');
                    showLocationInterface(null, null);
                }
            });

            function showLocationInterface(lat, lng) {
                const locationInterface = document.createElement('div');
                locationInterface.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--card-background);
                    border: 1px solid var(--border-light);
                    border-radius: 15px;
                    padding: 30px;
                    z-index: 1001;
                    text-align: center;
                    min-width: 350px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                `;
                
                const locationText = lat && lng 
                    ? `📍 Your Location: ${lat.toFixed(4)}, ${lng.toFixed(4)}`
                    : '📍 Demo Location: San Francisco, CA';
                
                locationInterface.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <i class="fas fa-map-marker-alt" style="font-size: 3rem; color: var(--blue); margin-bottom: 15px;"></i>
                        <h3 style="color: var(--white); margin: 0;">Share Location</h3>
                        <p style="color: var(--text-light); margin: 10px 0;">${locationText}</p>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="shareLocationConfirm" style="background: linear-gradient(135deg, var(--blue), var(--pink)); color: white; border: none; border-radius: 10px; padding: 12px 20px; cursor: pointer;">
                            <i class="fas fa-share"></i> Share Location
                        </button>
                        <button id="cancelLocationShare" style="background: var(--input-background); color: var(--text-light); border: 1px solid var(--border-light); border-radius: 10px; padding: 12px 20px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                `;
                
                document.body.appendChild(locationInterface);
                
                document.getElementById('shareLocationConfirm').addEventListener('click', () => {
                    showMessageBox('📍 Location shared successfully!', 'success');
                    if (lat && lng) {
                        sendMessage('location', `📍 My Location: https://maps.google.com/?q=${lat},${lng}`);
                    } else {
                        sendMessage('location', '📍 My Location: San Francisco, CA (Demo)');
                    }
                    document.body.removeChild(locationInterface);
                });
                
                document.getElementById('cancelLocationShare').addEventListener('click', () => {
                    showMessageBox('❌ Location sharing cancelled', 'info');
                    document.body.removeChild(locationInterface);
                });
            }

            // Reaction toggle functionality
            document.getElementById('reactionToggleBtn').addEventListener('click', () => {
                const quickReactions = document.getElementById('quickReactions');
                if (quickReactions.style.display === 'none' || !quickReactions.style.display) {
                    quickReactions.style.display = 'flex';
                } else {
                    quickReactions.style.display = 'none';
                }
            });

            // Quick reaction button functionality
            document.querySelectorAll('.reaction-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const reaction = e.target.getAttribute('data-reaction');
                    // Add reaction to last message (demo functionality)
                    const lastMessage = document.querySelector('.message-bubble:last-child .message-content');
                    if (lastMessage) {
                        const reactionsDiv = lastMessage.nextElementSibling || document.createElement('div');
                        if (!lastMessage.nextElementSibling) {
                            reactionsDiv.className = 'message-reactions';
                            lastMessage.parentNode.insertBefore(reactionsDiv, lastMessage.nextSibling);
                        }
                        
                        const reactionSpan = document.createElement('span');
                        reactionSpan.className = 'reaction';
                        reactionSpan.textContent = reaction + ' 1';
                        reactionsDiv.appendChild(reactionSpan);
                        
                        // Hide quick reactions after use
                        document.getElementById('quickReactions').style.display = 'none';
                    }
                });
            });

            // Friend selection variables (will be moved to Firebase module)
            let currentFriends = [];
            let filteredFriends = [];

            // Theme switcher functionality
            document.getElementById('themeSwitcherBtn').addEventListener('click', () => {
                const body = document.body;
                const icon = document.querySelector('#themeSwitcherBtn i');
                
                if (body.classList.contains('theme-dark-mode')) {
                    body.classList.remove('theme-dark-mode');
                    body.classList.add('theme-light-mode');
                    icon.className = 'fas fa-sun';
                    localStorage.setItem('jchat-theme', 'theme-light-mode');
                } else {
                    body.classList.remove('theme-light-mode');
                    body.classList.add('theme-dark-mode');
                    icon.className = 'fas fa-moon';
                    localStorage.setItem('jchat-theme', 'theme-dark-mode');
                }
            });

                         console.log('🚀 JCHAT Full Chat initialized with Friends Selection + Reactions!');
         });
     </script>

     <!-- FULL FIREBASE AND CLOUDINARY INTEGRATION -->
     <script type="module">
         // Import Firebase modules
         import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
         import { getAuth, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
         import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, getDocs, addDoc, serverTimestamp, orderBy, limit, updateDoc, deleteDoc, where, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
         import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

         // --- Firebase & Canvas Environment Configuration ---
         const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
             apiKey: "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
             authDomain: "jchat-1.firebaseapp.com",
             projectId: "jchat-1",
             storageBucket: "jchat-1.firebasestorage.app",
             messagingSenderId: "328479683167",
             appId: "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
             measurementId: "G-S6Z9GG0R9P"
         };
         const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
         const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

         // Cloudinary Configuration
         const cloudinaryConfig = {
             cloudName: "dxld01rcp", // Your Cloudinary Cloud Name
             uploadPreset: "Storage_preset" // Your Cloudinary Upload Preset
         };

         // Initialize Firebase services
         const app = initializeApp(firebaseConfig);
         const auth = getAuth(app);
         const db = getFirestore(app);
         const storage = getStorage(app);

         // --- DOM Elements ---
         const headerProfilePic = document.getElementById('headerProfilePic');
         const headerAvatarIcon = document.getElementById('headerAvatarIcon');
         const headerDisplayName = document.getElementById('headerDisplayName');
         const notificationCountElement = document.getElementById('notificationCount');
         const adminIconLink = document.getElementById('adminIconLink');
         const profileLink = document.getElementById('profileLink');
         const soundToggleIcon = document.getElementById('soundToggleIcon');

         const partnerProfilePic = document.getElementById('partnerProfilePic');
         const partnerAvatarIcon = document.getElementById('partnerAvatarIcon');
         const partnerDisplayName = document.getElementById('partnerDisplayName');
         const messagesArea = document.getElementById('messagesArea');
         const messageInput = document.getElementById('messageInput');
         const sendMessageBtn = document.getElementById('sendMessageBtn');

         // Global State
         let currentUser = null;
         let currentUserProfileData = null;
         let partnerId = null;
         let partnerProfileData = null;
         let unsubscribeMessages = null;
         let unsubscribeTyping = null;
         let notificationSoundEnabled = true;
         
         // Friend selection variables
         let currentFriends = [];
         let filteredFriends = [];

         // Voice Note Recording State
         let mediaRecorder;
         let audioChunks = [];
         let isRecording = false;
         let recordingStartTime;
         let recordingInterval;

         // --- Tone.js Synths for Notification Sounds ---
         const successSynth = new Tone.Synth().toDestination();
         const errorSynth = new Tone.Synth({
             oscillator: { type: "sawtooth" }
         }).toDestination();
         const infoSynth = new Tone.Synth({
             oscillator: { type: "triangle" }
         }).toDestination();

         /**
          * Plays notification sounds using ne.mp3 or Tone.js fallback
          */




         /**
          * Constructs a Cloudinary URL for an image/video.
          */
         function getCloudinaryImageUrl(urlOrPublicId, transformations = "w_auto,f_auto,q_auto") {
             if (!urlOrPublicId) return null;
             if (urlOrPublicId.startsWith('http://') || urlOrPublicId.startsWith('https://')) {
                 if (urlOrPublicId.includes('res.cloudinary.com')) {
                     const parts = urlOrPublicId.split('/upload/');
                     if (parts.length === 2) {
                         return `${parts[0]}/upload/${transformations}/${parts[1]}`;
                     }
                 }
                 return urlOrPublicId;
             }
             return `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/image/upload/${transformations}/${urlOrPublicId}`;
         }

         /**
          * Displays the profile picture or a default icon.
          */
         
         // Friend Selection Functions (moved from first script section)
         
         /**
          * Fetches the current user's friends list from Firestore with real-time online status.
          */
         async function fetchUserFriends() {
             if (!currentUser) {
                 console.log("JCHAT_DEBUG: No current user to fetch friends for.");
                 return [];
             }

             try {
                 console.log("JCHAT_DEBUG: Fetching friends for user:", currentUser.uid);
                 const friends = [];
                 
                 // Get friends from the same collection path as Find_Friends.html
                 const publicFriendsRef = collection(db, "artifacts", appId, "public", "data", "friends");
                 const friendsSnapshot = await getDocs(publicFriendsRef);
                 
                 const friendIds = new Set();
                 friendsSnapshot.forEach(docSnap => {
                     const friendData = docSnap.data();
                     if (friendData.user1Id === currentUser.uid) {
                         friendIds.add(friendData.user2Id);
                     } else if (friendData.user2Id === currentUser.uid) {
                         friendIds.add(friendData.user1Id);
                     }
                 });
                 
                 console.log(`JCHAT_DEBUG: Found ${friendIds.size} friend relationships`);

                 // Get detailed user data for each friend with real-time online status
                 if (friendIds.size > 0) {
                     for (const friendId of friendIds) {
                         try {
                             const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", friendId);
                             const publicDocSnap = await getDoc(publicProfileDocRef);
                             if (publicDocSnap.exists()) {
                                 const friendProfile = publicDocSnap.data();
                                 
                                 // Check real-time online status
                                 const isOnline = await checkUserOnlineStatus(friendId);
                                 
                                 friends.push({
                                     userId: friendId,
                                     username: friendProfile.username || friendProfile.displayName || `User_${friendId.substring(0, 8)}`,
                                     profilePicId: friendProfile.profilePicId,
                                     visibility: friendProfile.visibility || {},
                                     isOnline: isOnline,
                                     lastSeen: friendProfile.lastSeen || null
                                 });
                             } else {
                                 console.warn(`JCHAT_WARN: Public profile not found for friend ID: ${friendId}`);
                                 friends.push({
                                     userId: friendId,
                                     username: `Unknown User (${friendId.substring(0, 8)})`,
                                     profilePicId: null,
                                     visibility: {},
                                     isOnline: false,
                                     lastSeen: null
                                 });
                             }
                         } catch (error) {
                             console.error(`JCHAT_ERROR: Error fetching public profile for friend ${friendId}:`, error);
                             friends.push({
                                 userId: friendId,
                                 username: `Error User (${friendId.substring(0, 8)})`,
                                 profilePicId: null,
                                 visibility: {},
                                 isOnline: false,
                                 lastSeen: null
                             });
                         }
                     }

                     // Sort friends by online status and name
                     friends.sort((a, b) => {
                         if (a.isOnline && !b.isOnline) return -1;
                         if (!a.isOnline && b.isOnline) return 1;
                         return a.username.localeCompare(b.username);
                     });
                 }

                 console.log(`JCHAT_DEBUG: Successfully loaded ${friends.length} real friends`);
                 
                 if (friends.length === 0) {
                     showMessageBox('👥 No friends found. Add friends from the Find Friends page!', 'info');
                 }
                 
                 return friends;
                 
             } catch (error) {
                 console.error("JCHAT_ERROR: Error fetching real friends:", error);
                 showMessageBox('❌ Failed to load friends. Please try again.', 'error');
                 return [];
             }
         }

         /**
          * Checks if a user is currently online by looking at their last activity.
          */
         async function checkUserOnlineStatus(userId) {
             try {
                 // Check user's online status in their profile
                 const userProfileRef = doc(db, "artifacts", appId, "public", "data", "users", userId);
                 const userProfileSnap = await getDoc(userProfileRef);
                 
                 if (userProfileSnap.exists()) {
                     const userData = userProfileSnap.data();
                     
                     // Check if user has isOnline field and it's true
                     if (userData.isOnline === true) {
                         return true;
                     }
                     
                     // Check lastSeen timestamp (consider online if last activity was within 5 minutes)
                     if (userData.lastSeen) {
                         const lastSeenTime = userData.lastSeen.toDate ? userData.lastSeen.toDate() : new Date(userData.lastSeen);
                         const now = new Date();
                         const timeDiff = now - lastSeenTime;
                         const fiveMinutes = 5 * 60 * 1000; // 5 minutes in milliseconds
                         
                         if (timeDiff < fiveMinutes) {
                             return true;
                         }
                     }
                 }
                 
                 return false;
             } catch (error) {
                 console.error(`JCHAT_ERROR: Error checking online status for ${userId}:`, error);
                 return false;
             }
         }

         /**
          * Updates the current user's online status.
          */
         async function updateUserOnlineStatus(isOnline) {
             if (!currentUser) return;
             
             try {
                 const userProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                 await updateDoc(userProfileRef, {
                     isOnline: isOnline,
                     lastSeen: serverTimestamp()
                 });
                 console.log(`JCHAT_DEBUG: Updated online status to ${isOnline}`);
             } catch (error) {
                 console.error("JCHAT_ERROR: Error updating online status:", error);
             }
         }

         /**
          * Creates a friend item HTML element.
          */
         function createFriendItem(friend) {
             const friendDiv = document.createElement('div');
             friendDiv.className = 'friend-item';
             friendDiv.setAttribute('data-friend-id', friend.userId);
             friendDiv.setAttribute('data-friend-name', friend.username);

             // Profile image with proper error handling
             let profileImageHtml = '';
             if (friend.profilePicId && friend.visibility?.profilePic !== false) {
                 const imageUrl = getCloudinaryImageUrl(friend.profilePicId, "w_60,h_60,c_fill,g_face,r_max");
                 profileImageHtml = `<img src="${imageUrl}" alt="${friend.username}'s Profile" class="friend-avatar" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">`;
             } else {
                 profileImageHtml = `<div class="default-avatar" style="display: flex;"><i class="fas fa-user-circle"></i></div>`;
             }

             // Display name with proper visibility handling
             const displayName = friend.visibility?.displayName !== false ? friend.username : 'Anonymous User';
             
             // Real online status
             const isOnline = friend.isOnline;
             const statusClass = isOnline ? 'online' : 'offline';
             const statusText = isOnline ? 'Online' : 'Offline';
             
             // Last seen time for offline users
             let lastSeenText = '';
             if (!isOnline && friend.lastSeen) {
                 const lastSeen = new Date(friend.lastSeen);
                 const now = new Date();
                 const diff = now - lastSeen;
                 const minutes = Math.floor(diff / 60000);
                 const hours = Math.floor(minutes / 60);
                 const days = Math.floor(hours / 24);
                 
                 if (days > 0) {
                     lastSeenText = `Last seen ${days} day${days > 1 ? 's' : ''} ago`;
                 } else if (hours > 0) {
                     lastSeenText = `Last seen ${hours} hour${hours > 1 ? 's' : ''} ago`;
                 } else if (minutes > 0) {
                     lastSeenText = `Last seen ${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                 } else {
                     lastSeenText = 'Last seen recently';
                 }
             }
             
             friendDiv.innerHTML = `
                 <div class="friend-avatar-container">
                     ${profileImageHtml}
                     <div class="default-avatar" style="display: none;"><i class="fas fa-user-circle"></i></div>
                     ${isOnline ? '<div class="online-indicator"></div>' : ''}
                 </div>
                 <div class="friend-info">
                     <span class="friend-name">${displayName}</span>
                     <span class="friend-status ${statusClass}">${statusText}</span>
                     ${lastSeenText ? `<span class="last-seen">${lastSeenText}</span>` : ''}
                 </div>
             `;

             // Add hover effects
             friendDiv.addEventListener('mouseenter', () => {
                 friendDiv.style.transform = 'translateY(-3px) scale(1.02)';
             });
             
             friendDiv.addEventListener('mouseleave', () => {
                 friendDiv.style.transform = '';
             });

             return friendDiv;
         }

         /**
          * Renders the friends list in the modal.
          */
         function renderFriendsList(friends) {
             console.log("JCHAT_DEBUG: renderFriendsList called with friends:", friends);
             const friendListContainer = document.getElementById('friendListContainer');
             console.log("JCHAT_DEBUG: friendListContainer found:", friendListContainer);
             const noFriendsMessage = friendListContainer.querySelector('.no-friends-modal');
             console.log("JCHAT_DEBUG: noFriendsMessage found:", noFriendsMessage);
             
             // Clear existing content except the no-friends message
             const existingItems = friendListContainer.querySelectorAll('.friend-item');
             existingItems.forEach(item => item.remove());

             if (friends.length === 0) {
                 console.log("JCHAT_DEBUG: No friends found, showing no friends message");
                 noFriendsMessage.style.display = 'block';
                 noFriendsMessage.textContent = 'No friends found. Add friends from the Find Friends page.';
             } else {
                 console.log("JCHAT_DEBUG: Found friends, creating friend items for:", friends.length, "friends");
                 noFriendsMessage.style.display = 'none';
                 friends.forEach(friend => {
                     console.log("JCHAT_DEBUG: Creating friend item for:", friend.username);
                     const friendItem = createFriendItem(friend);
                     
                     // Add click handler for friend selection
                     friendItem.addEventListener('click', async () => {
                         const friendId = friend.userId;
                         const friendName = friend.username;
                         const friendProfilePicId = friend.profilePicId;
                         
                         try {
                             // Show loading state
                             showMessageBox(`🔄 Loading chat with ${friendName}...`, 'loading', true);
                             
                             // Update partner display and global variable
                             const partnerDisplay = document.getElementById('partnerDisplayName');
                             if (partnerDisplay) {
                                 partnerDisplay.textContent = friendName;
                             }
                             
                             // Update partner profile picture
                             const partnerProfilePic = document.getElementById('partnerProfilePic');
                             const partnerAvatarIcon = document.getElementById('partnerAvatarIcon');
                             
                             if (friendProfilePicId && friend.visibility?.profilePic !== false) {
                                 const imageUrl = getCloudinaryImageUrl(friendProfilePicId, "w_40,h_40,c_fill,g_face,r_max");
                                 if (partnerProfilePic) {
                                     partnerProfilePic.src = imageUrl;
                                     partnerProfilePic.style.display = 'block';
                                     partnerProfilePic.onerror = () => {
                                         partnerProfilePic.style.display = 'none';
                                         if (partnerAvatarIcon) partnerAvatarIcon.style.display = 'flex';
                                     };
                                 }
                                 if (partnerAvatarIcon) partnerAvatarIcon.style.display = 'none';
                             } else {
                                 if (partnerProfilePic) partnerProfilePic.style.display = 'none';
                                 if (partnerAvatarIcon) partnerAvatarIcon.style.display = 'flex';
                             }
                             
                             // Update header title
                             const headerTitle = document.querySelector('.chat-header h2');
                             if (headerTitle) {
                                 headerTitle.textContent = `Chat with ${friendName}`;
                             }
                             
                             // Set partner ID
                             partnerId = friendId;
                             
                             // Close modal
                             document.getElementById('selectFriendModal').classList.remove('active');
                             
                             // Clear search input
                             const searchInput = document.getElementById('friendSearchInput');
                             if (searchInput) {
                                 searchInput.value = '';
                             }
                             
                             // Clear existing messages and show loading
                             const messagesArea = document.getElementById('messagesArea');
                             if (messagesArea) {
                                 // Keep only the typing indicator and welcome message
                                 const existingMessages = messagesArea.querySelectorAll('.message-bubble');
                                 existingMessages.forEach(msg => {
                                     if (!msg.innerHTML.includes('Welcome to JCHAT') && !msg.classList.contains('typing-indicator')) {
                                         msg.remove();
                                     }
                                 });
                                 
                                 // Add loading message
                                 const loadingMsg = document.createElement('div');
                                 loadingMsg.className = 'message-bubble received';
                                 loadingMsg.innerHTML = `
                                     <div class="message-content">
                                         <i class="fas fa-spinner fa-spin"></i> Loading chat history...
                                     </div>
                                     <div class="message-time">Just now</div>
                                 `;
                                 messagesArea.appendChild(loadingMsg);
                                 messagesArea.scrollTop = messagesArea.scrollHeight;
                             } else {
                                 console.error("JCHAT_ERROR: Messages area not found during friend selection");
                             }
                             
                             // Load messages for selected friend
                             if (typeof loadMessages === 'function' && currentUser) {
                                 try {
                                     await loadMessages();
                                 } catch (error) {
                                     console.error("JCHAT_ERROR: Error loading messages:", error);
                                     showMessageBox("Failed to load chat history", 'error');
                                 }
                             } else {
                                 console.error("JCHAT_ERROR: loadMessages function not available");
                                 showMessageBox("Chat functionality not ready", 'error');
                             }
                             
                             // Remove loading message
                             const loadingMsg = messagesArea?.querySelector('.message-bubble:last-child');
                             if (loadingMsg && loadingMsg.innerHTML.includes('Loading chat history')) {
                                 loadingMsg.remove();
                             }
                             
                             showMessageBox(`💬 Now chatting with ${friendName}`, 'success');
                             playNotificationSound('success');
                             console.log(`JCHAT_DEBUG: Successfully loaded chat with friend ${friendId} (${friendName})`);
                             
                         } catch (error) {
                             console.error("JCHAT_ERROR: Error loading chat:", error);
                             showMessageBox(`❌ Failed to load chat with ${friendName}`, 'error');
                         }
                     });

                     friendListContainer.insertBefore(friendItem, noFriendsMessage);
                 });
             }

             // Update friend count badge
             const badge = document.getElementById('selectFriendBadge');
             if (badge) {
                 if (friends.length > 0) {
                     badge.textContent = friends.length;
                     badge.style.display = 'inline-block';
                 } else {
                     badge.style.display = 'none';
                 }
             }
         }

         /**
          * Filters friends based on search query.
          */
         function filterFriends(searchQuery) {
             if (!searchQuery.trim()) {
                 filteredFriends = [...currentFriends];
             } else {
                 const query = searchQuery.toLowerCase();
                 filteredFriends = currentFriends.filter(friend =>
                     friend.username.toLowerCase().includes(query)
                 );
             }
             renderFriendsList(filteredFriends);
         }
         function displayProfilePicture(imgElement, iconElement, profilePicId, usernameInitial, transformations) {
             if (imgElement && iconElement) {
                 if (profilePicId) {
                     const imageUrl = getCloudinaryImageUrl(profilePicId, transformations);
                     imgElement.src = imageUrl;
                     imgElement.style.display = 'block';
                     iconElement.style.display = 'none';
                     imgElement.onerror = () => {
                         console.error(`JCHAT_ERROR: Failed to load profile picture: ${profilePicId}. Using placeholder.`);
                         imgElement.src = `https://placehold.co/40x40/CCCCCC/000000?text=${usernameInitial}`;
                         imgElement.style.display = 'block';
                         iconElement.style.display = 'none';
                     };
                 } else {
                     imgElement.src = '';
                     imgElement.style.display = 'none';
                     iconElement.style.display = 'block';
                 }
             }
         }

         /**
          * Fetches and displays the current user's profile data for the header.
          */
         async function fetchAndDisplayHeaderProfile(user) {
             console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile called for user:", user.uid);
             try {
                 const privateProfileDocRef = doc(db, "artifacts", appId, "users", user.uid, "profiles", "user_profile");
                 const privateDocSnap = await getDoc(privateProfileDocRef);

                 let profileData = null;
                 if (privateDocSnap.exists()) {
                     profileData = privateDocSnap.data();
                     console.log("JCHAT_DEBUG: Fetched existing profile data for header:", profileData);
                 } else {
                     // If private profile doesn't exist, create a basic one
                     console.warn("JCHAT_WARN: Private profile not found for header, creating a new one.");
                     profileData = {
                         username: user.displayName || `User_${user.uid.substring(0, 8)}`,
                         email: user.email || "",
                         profilePicId: user.photoURL || null,
                         bio: "",
                         location: "",
                         friendsCount: 0,
                         followersCount: 0,
                         followingCount: 0,
                         totalPosts: 0,
                         createdAt: serverTimestamp(),
                         updatedAt: serverTimestamp(),
                         visibility: {
                             profile: true,
                             email: false,
                             friends: true,
                             posts: true,
                             displayName: true,
                             location: false
                         },
                         isAdmin: false
                     };
                     await setDoc(privateProfileDocRef, profileData);

                     // Also create/update public profile
                     const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);
                     await setDoc(publicProfileDocRef, {
                         username: profileData.username,
                         profilePicId: profileData.profilePicId,
                         bio: profileData.bio,
                         location: profileData.location,
                         createdAt: profileData.createdAt,
                         updatedAt: profileData.updatedAt,
                         visibility: profileData.visibility,
                         totalPosts: profileData.totalPosts
                     }, { merge: true });

                     console.log("JCHAT_DEBUG: Created new profile for user:", user.uid);
                 }

                 // Store in global variable
                 currentUserProfileData = profileData;

                 // Update header elements
                 const username = profileData.username || user.displayName || `User_${user.uid.substring(0, 8)}`;
                 const usernameInitial = username.charAt(0).toUpperCase();

                 if (headerDisplayName) {
                     headerDisplayName.textContent = profileData.visibility?.displayName !== false ? username : 'Anonymous';
                 }

                 // Display profile picture using Cloudinary
                 displayProfilePicture(headerProfilePic, headerAvatarIcon, profileData?.profilePicId, usernameInitial, "w_90,h_90,c_fill,g_face,r_max");

                 // Show admin icon if user is admin
                 if (profileData.isAdmin && adminIconLink) {
                     adminIconLink.style.display = 'block';
                 }

                 console.log("JCHAT_DEBUG: Header profile updated successfully");
             } catch (error) {
                 console.error("JCHAT_ERROR: Error fetching/displaying header profile:", error);
                 
                 // Fallback display
                 const fallbackUsername = user.displayName || `User_${user.uid.substring(0, 8)}`;
                 if (headerDisplayName) {
                     headerDisplayName.textContent = fallbackUsername;
                 }
                 if (headerAvatarIcon) {
                     headerAvatarIcon.style.display = 'block';
                 }
                 if (headerProfilePic) {
                     headerProfilePic.style.display = 'none';
                 }
             }
         }

         /**
          * Fetches and displays the notification count for the current user.
          */
         async function fetchNotificationCount(userId) {
             try {
                 const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                 const q = query(notificationsCollectionRef, orderBy("timestamp", "desc"));
                 const unsubscribe = onSnapshot(q, (snapshot) => {
                     const unreadCount = snapshot.docs.filter(doc => !doc.data().read).length;

                     if (notificationCountElement) {
                         if (unreadCount > 0) {
                             notificationCountElement.textContent = unreadCount;
                             notificationCountElement.style.display = 'flex';
                         } else {
                             notificationCountElement.style.display = 'none';
                         }
                     }
                 });

                 // Store unsubscribe function for cleanup
                 return unsubscribe;
             } catch (error) {
                 console.error("JCHAT_ERROR: Error fetching notification count:", error);
             }
         }

         // Chat-specific functions
         function getChatRoomId(uid1, uid2) {
             return [uid1, uid2].sort().join('_');
         }

         // Get partnerId from URL parameters
         const urlParams = new URLSearchParams(window.location.search);
         partnerId = urlParams.get('partnerId') || 'demo-partner-123';

         // Enhanced message sending with Firebase
         async function sendMessage(type = 'text', content = '') {
             if (!currentUser || !partnerId) {
                 showMessageBox("Please select a chat partner", 'warning');
                 throw new Error("No chat partner selected");
             }

             // Get the current message input value
             const messageInput = document.getElementById('messageInput');
             const message = content || (messageInput ? messageInput.value.trim() : '');
             
             console.log("JCHAT_DEBUG: Send message called with:", { type, content, message, hasMessageInput: !!messageInput });
             
             if (!message) {
                 showMessageBox("Please type a message", 'warning');
                 throw new Error("Empty message");
             }

             try {
                 const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                 const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");

                 const messageData = {
                     senderId: currentUser.uid,
                     receiverId: partnerId,
                     type: type,
                     content: message,
                     timestamp: serverTimestamp(),
                     status: 'sent',
                     reactions: {}
                 };

                 await addDoc(messagesCollectionRef, messageData);

                 // Clear input after successful send
                 if (messageInput) {
                     messageInput.value = '';
                     messageInput.style.height = 'auto';
                     
                     // Update send button state
                     const sendBtn = document.getElementById('sendMessageBtn');
                     if (sendBtn) {
                         sendBtn.disabled = true;
                     }
                 }

                 playNotificationSound('success');
                 console.log("JCHAT_DEBUG: Message sent successfully");

             } catch (error) {
                 console.error("JCHAT_ERROR: Error sending message:", error);
                 showMessageBox("Failed to send message. Please try again.", 'error');
                 throw error; // Re-throw to be handled by the button
             }
         }

         // Enhanced message loading with Firebase
         async function loadMessages() {
             if (!currentUser || !partnerId) {
                 console.log("JCHAT_DEBUG: Cannot load messages - missing user or partner");
                 return;
             }

             // Get messages area element
             const messagesArea = document.getElementById('messagesArea');
             if (!messagesArea) {
                 console.error("JCHAT_ERROR: Messages area element not found");
                 showMessageBox("Chat interface not ready", 'error');
                 return;
             }

             try {
                 console.log(`JCHAT_DEBUG: Loading messages for chat with ${partnerId}`);
                 
                 // Unsubscribe previous listeners
                 if (unsubscribeMessages) {
                     unsubscribeMessages();
                     unsubscribeMessages = null;
                 }
                 if (unsubscribeTyping) {
                     unsubscribeTyping();
                     unsubscribeTyping = null;
                 }

                 const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                 console.log(`JCHAT_DEBUG: Chat room ID: ${chatRoomId}`);
                 
                 const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");
                 const q = query(messagesCollectionRef, orderBy("timestamp", "asc"));

                 unsubscribeMessages = onSnapshot(q, (snapshot) => {
                     console.log(`JCHAT_DEBUG: Received ${snapshot.docs.length} messages from Firebase`);
                     
                     // Clear ALL existing messages including welcome message when loading chat history
                     const existingMessages = messagesArea.querySelectorAll('.message-bubble');
                     existingMessages.forEach(msg => {
                         if (!msg.classList.contains('typing-indicator') &&
                             !msg.innerHTML.includes('Loading chat history')) {
                             msg.remove();
                         }
                     });

                     if (!snapshot.empty) {
                         snapshot.docs.forEach(doc => {
                             const messageData = doc.data();
                             createMessageBubble(messageData, doc.id);
                         });
                         
                         console.log(`JCHAT_DEBUG: Loaded ${snapshot.docs.length} messages successfully`);
                     } else {
                         // Add "No messages yet" indicator
                         const noMessagesDiv = document.createElement('div');
                         noMessagesDiv.className = 'message-bubble received';
                         noMessagesDiv.innerHTML = `
                             <div class="message-content">
                                 <i class="fas fa-comments"></i> No messages yet. Start the conversation!
                             </div>
                             <div class="message-time">Just now</div>
                         `;
                         messagesArea.appendChild(noMessagesDiv);
                         console.log("JCHAT_DEBUG: No previous messages found");
                     }

                     // Scroll to bottom
                     setTimeout(() => {
                         messagesArea.scrollTop = messagesArea.scrollHeight;
                     }, 100);

                 }, (error) => {
                     console.error("JCHAT_ERROR: Firebase listener error:", error);
                     showMessageBox("Failed to load chat history", 'error');
                 });

                 // Set up typing indicator listener
                 setupTypingIndicator(chatRoomId);

             } catch (error) {
                 console.error("JCHAT_ERROR: Error loading messages:", error);
                 showMessageBox("Failed to load messages", 'error');
             }
         }

         /**
          * Sets up real-time typing indicator for the chat room.
          */
         function setupTypingIndicator(chatRoomId) {
             try {
                 const typingCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "typing");
                 
                 unsubscribeTyping = onSnapshot(typingCollectionRef, (snapshot) => {
                     const typingUsers = [];
                     snapshot.forEach(doc => {
                         const typingData = doc.data();
                         if (typingData.userId !== currentUser.uid && typingData.isTyping) {
                             typingUsers.push(typingData);
                         }
                     });

                     updateTypingIndicator(typingUsers);
                 });

                 console.log("JCHAT_DEBUG: Typing indicator listener set up");
             } catch (error) {
                 console.error("JCHAT_ERROR: Error setting up typing indicator:", error);
             }
         }

         /**
          * Updates the typing indicator display.
          */
         function updateTypingIndicator(typingUsers) {
             const typingIndicator = document.getElementById('typingIndicator');
             const typingUsername = document.getElementById('typingUsername');
             
             if (typingUsers.length > 0) {
                 // Get the first typing user's name
                 const typingUser = typingUsers[0];
                 const username = typingUser.username || 'Someone';
                 
                 if (typingUsername) {
                     typingUsername.textContent = username;
                 }
                 
                 if (typingIndicator) {
                     typingIndicator.style.display = 'flex';
                     
                     // Auto-hide typing indicator after 5 seconds
                     clearTimeout(typingIndicator.hideTimeout);
                     typingIndicator.hideTimeout = setTimeout(() => {
                         typingIndicator.style.display = 'none';
                     }, 5000);
                 }
                 
                 console.log(`JCHAT_DEBUG: ${username} is typing`);
             } else {
                 if (typingIndicator) {
                     typingIndicator.style.display = 'none';
                 }
             }
         }

         /**
          * Sends typing status to Firebase.
          */
         async function sendTypingStatus(isTyping) {
             if (!currentUser || !partnerId) return;
             
             try {
                 const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                 const typingCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "typing");
                 const typingDocRef = doc(typingCollectionRef, currentUser.uid);
                 
                 if (isTyping) {
                     await setDoc(typingDocRef, {
                         userId: currentUser.uid,
                         username: currentUserProfileData?.username || 'Unknown User',
                         isTyping: true,
                         timestamp: serverTimestamp()
                     });
                 } else {
                     await deleteDoc(typingDocRef);
                 }
             } catch (error) {
                 console.error("JCHAT_ERROR: Error sending typing status:", error);
             }
         }

         function createMessageBubble(messageData, messageId) {
             // Validate message data
             if (!messageData || !messageData.content) {
                 console.warn("JCHAT_WARN: Invalid message data received:", messageData);
                 return null;
             }

             const messagesArea = document.getElementById('messagesArea');
             if (!messagesArea) {
                 console.error("JCHAT_ERROR: Messages area not found");
                 return null;
             }

             const messageDiv = document.createElement('div');
             const isSent = messageData.senderId === currentUser.uid;
             messageDiv.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
             messageDiv.dataset.messageId = messageId || 'unknown';

             // Handle timestamp safely
             let timeString = 'Just now';
             if (messageData.timestamp) {
                 try {
                     if (messageData.timestamp.seconds) {
                         timeString = new Date(messageData.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                     } else if (messageData.timestamp.toDate) {
                         timeString = messageData.timestamp.toDate().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                     } else if (messageData.timestamp instanceof Date) {
                         timeString = messageData.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                     }
                 } catch (error) {
                     console.warn("JCHAT_WARN: Error parsing timestamp:", error);
                     timeString = 'Just now';
                 }
             }

             // Sanitize content to prevent XSS
             const sanitizedContent = messageData.content.toString().replace(/</g, '&lt;').replace(/>/g, '&gt;');

             messageDiv.innerHTML = `
                 <div class="message-content">${sanitizedContent}</div>
                 <div class="message-time">${timeString}</div>
             `;

             messagesArea.appendChild(messageDiv);
             console.log(`JCHAT_DEBUG: Created message bubble for ${isSent ? 'sent' : 'received'} message`);
             return messageDiv;
         }

         // Override existing button event listeners with Firebase functionality
         document.addEventListener('DOMContentLoaded', () => {
             
             // Friend Selection Event Listeners
             
             // Select Friend button click handler
             document.getElementById('selectFriendBtn')?.addEventListener('click', async () => {
                 console.log("JCHAT_DEBUG: Select Friend button clicked");
                 const btn = document.getElementById('selectFriendBtn');
                 btn.style.transform = 'scale(0.95)';
                 setTimeout(() => btn.style.transform = '', 150);
                 
                 // Check authentication first
                 if (!currentUser || !currentUser.uid) {
                     console.log("JCHAT_DEBUG: No current user found");
                     showMessageBox('❌ Please log in to view your friends', 'warning');
                     return;
                 }
                 
                 console.log("JCHAT_DEBUG: Current user found:", currentUser.uid);
                 
                 // Show loading state
                 showMessageBox('👥 Loading your friends...', 'loading', true);
                 
                 try {
                     console.log("JCHAT_DEBUG: Starting to fetch friends...");
                     // Fetch REAL friends data only
                     currentFriends = await fetchUserFriends();
                     console.log("JCHAT_DEBUG: Friends fetched:", currentFriends);
                     filteredFriends = [...currentFriends];
                     
                     // Render friends list
                     console.log("JCHAT_DEBUG: Rendering friends list...");
                     renderFriendsList(filteredFriends);
                     
                     // Show modal
                     document.getElementById('selectFriendModal').classList.add('active');
                     
                     if (currentFriends.length > 0) {
                         showMessageBox(`👥 Found ${currentFriends.length} friend${currentFriends.length > 1 ? 's' : ''}. Select one to chat!`, 'success');
                     } else {
                         showMessageBox('👥 No friends yet. Add friends from the Find Friends page!', 'info');
                     }
                 } catch (error) {
                     console.error('JCHAT_ERROR: Error in friend selection:', error);
                     showMessageBox('❌ Failed to load friends. Please try again.', 'error');
                 }
             });

             // Close modal button
             document.getElementById('closeFriendModalBtn')?.addEventListener('click', () => {
                 document.getElementById('selectFriendModal').classList.remove('active');
                 showMessageBox('❌ Friend selection cancelled', 'info');
             });

             // Search functionality
             document.getElementById('friendSearchInput')?.addEventListener('input', (e) => {
                 filterFriends(e.target.value);
             });

             // Find Friends functionality
             document.getElementById('findFriendsBtn')?.addEventListener('click', () => {
                 const btn = document.getElementById('findFriendsBtn');
                 btn.style.transform = 'scale(0.95)';
                 setTimeout(() => btn.style.transform = '', 150);
                 
                 showMessageBox('🔍 Navigating to Find Friends...', 'info');
                 setTimeout(() => {
                     window.location.href = '/Find_Friends.html';
                 }, 500);
             });
             // Enhanced send message functionality
             const sendMessageBtn = document.getElementById('sendMessageBtn');
             const messageInput = document.getElementById('messageInput');
             
             if (sendMessageBtn) {
                 // Remove existing listeners by cloning
                 const newSendBtn = sendMessageBtn.cloneNode(true);
                 sendMessageBtn.parentNode.replaceChild(newSendBtn, sendMessageBtn);
                 
                 // Add enhanced click listener
                 newSendBtn.addEventListener('click', async () => {
                     const btn = newSendBtn;
                     const originalContent = btn.innerHTML;
                     
                     // Add loading state
                     btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                     btn.disabled = true;
                     
                     try {
                         // Get the current message input value
                         const currentMessageInput = document.getElementById('messageInput');
                         const messageContent = currentMessageInput ? currentMessageInput.value : '';
                         
                         await sendMessage('text', messageContent);
                         
                         // Success state
                         btn.innerHTML = '<i class="fas fa-check"></i>';
                         setTimeout(() => {
                             btn.innerHTML = originalContent;
                             btn.disabled = false;
                         }, 500);
                         
                     } catch (error) {
                         console.error("JCHAT_ERROR: Send button error:", error);
                         
                         // Error state
                         btn.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
                         setTimeout(() => {
                             btn.innerHTML = originalContent;
                             btn.disabled = false;
                         }, 1000);
                     }
                 });
             }

             // Enhanced message input functionality
             if (messageInput) {
                 // Remove existing listeners by cloning
                 const newMessageInput = messageInput.cloneNode(true);
                 messageInput.parentNode.replaceChild(newMessageInput, messageInput);
                 
                 // Typing status tracking
                 let typingTimeout;
                 
                 // Add enhanced listeners
                 newMessageInput.addEventListener('input', () => {
                     newMessageInput.style.height = 'auto';
                     newMessageInput.style.height = Math.min(newMessageInput.scrollHeight, 120) + 'px';
                     
                     // Enable/disable send button based on content
                     const sendBtn = document.getElementById('sendMessageBtn');
                     if (sendBtn) {
                         sendBtn.disabled = !newMessageInput.value.trim();
                     }
                     
                     // Send typing status
                     sendTypingStatus(true);
                     
                     // Clear previous timeout
                     clearTimeout(typingTimeout);
                     
                     // Set timeout to stop typing status after 2 seconds of no input
                     typingTimeout = setTimeout(() => {
                         sendTypingStatus(false);
                     }, 2000);
                 });

                 newMessageInput.addEventListener('keypress', async (e) => {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault();
                         
                         // Stop typing status when sending
                         sendTypingStatus(false);
                         clearTimeout(typingTimeout);
                         
                         const sendBtn = document.getElementById('sendMessageBtn');
                         if (sendBtn && !sendBtn.disabled) {
                             sendBtn.click();
                         }
                     }
                 });
                 
                 // Stop typing when input loses focus
                 newMessageInput.addEventListener('blur', () => {
                     sendTypingStatus(false);
                     clearTimeout(typingTimeout);
                 });
             }

             // Sound toggle
             document.getElementById('soundToggleIcon')?.addEventListener('click', () => {
                 notificationSoundEnabled = !notificationSoundEnabled;
                 const icon = document.getElementById('soundToggleIcon');
                 if (notificationSoundEnabled) {
                     icon.className = 'fas fa-volume-up active';
                 } else {
                     icon.className = 'fas fa-volume-mute';
                 }
                 localStorage.setItem('jchat-sound', notificationSoundEnabled);
                 showMessageBox(`Sound ${notificationSoundEnabled ? 'enabled' : 'disabled'}`, 'info');
             });

             // Load saved sound preference
             const savedSound = localStorage.getItem('jchat-sound');
             if (savedSound !== null) {
                 notificationSoundEnabled = savedSound === 'true';
                 const icon = document.getElementById('soundToggleIcon');
                 if (icon) {
                     icon.className = notificationSoundEnabled ? 'fas fa-volume-up active' : 'fas fa-volume-mute';
                 }
             }
         });

         // Firebase Authentication State Listener
         onAuthStateChanged(auth, async (user) => {
             if (user) {
                 console.log("JCHAT_DEBUG: User authenticated:", user.uid);
                 currentUser = user;
                 
                 // Set user as online
                 await updateUserOnlineStatus(true);
                 
                 // Fetch and display header profile
                 await fetchAndDisplayHeaderProfile(user);
                 
                 // Fetch notification count
                 await fetchNotificationCount(user.uid);
                 
                 // Load messages if partner is selected
                 if (partnerId) {
                     await loadMessages();
                 }
                 
                 showMessageBox("Connected to JCHAT! 🚀", 'success');
             } else {
                 console.log("JCHAT_DEBUG: User not authenticated, signing in anonymously");
                 try {
                     await signInAnonymously(auth);
                 } catch (error) {
                     console.error("JCHAT_ERROR: Anonymous sign-in failed:", error);
                     showMessageBox("Authentication failed", 'error');
                 }
             }
         });

         // Cleanup on page unload
         window.addEventListener('beforeunload', () => {
             if (unsubscribeMessages) unsubscribeMessages();
             if (unsubscribeTyping) unsubscribeTyping();
             if (isRecording) {
                 mediaRecorder?.stop();
             }
             // Set user as offline when leaving
             if (currentUser) {
                 updateUserOnlineStatus(false);
             }
             // Stop typing status
             sendTypingStatus(false);
         });

         // Also set offline when page becomes hidden
         document.addEventListener('visibilitychange', () => {
             if (document.hidden && currentUser) {
                 updateUserOnlineStatus(false);
             } else if (!document.hidden && currentUser) {
                 updateUserOnlineStatus(true);
             }
         });

         console.log('🚀 JCHAT Full Chat initialized with 100% Firebase & Cloudinary functionality!');
     </script>

    <!-- Select Friend Modal -->
    <div id="selectFriendModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Select a Friend to Chat With</h3>
            <input type="text" id="friendSearchInput" placeholder="Search friends..." class="search-input">
            <div id="friendListContainer" class="friend-list-modal">
                <p class="no-friends-modal" style="display: none;">No friends found.</p>
            </div>
            <div class="modal-buttons">
                <button id="closeFriendModalBtn" class="cancel-btn">Close</button>
            </div>
        </div>
    </div>

</body>
</html>