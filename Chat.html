<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Private Chat</title>

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://*.firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --glass-black: rgba(10, 10, 10, .75);
            --glass-blue: rgba(0, 213, 255, .15);
            --radius: 20px;
            --transition: .3s ease;

            /* These variables will be overridden by theme classes */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* New variables for consistent theming */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #bbbbbb;
            --notification-badge-color: #ff2e92;
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff; /* A bright cyan */
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;

            /* New Green for Play Button */
            --play-button-green: linear-gradient(90deg, #4CAF50, #8BC34A); /* Green gradient */
            --play-button-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
        }

        /* --- Theme Definitions (Light and Dark Mode) --- */
        /* Light Mode */
        body.theme-light-mode {
            --background-main: #f0f2f5; /* Light gray background */
            --background-gradient-1: #e0e2e5; /* Subtle lighter gradient */
            --background-gradient-2: #d0d2d5; /* Subtle darker gradient */
            --white: #333; /* Dark text for readability */
            --text-light: #666; /* Lighter dark text */
            --card-background: rgba(255, 255, 255, 0.95); /* Near white cards */
            --header-background: rgba(255, 255, 255, 0.98); /* Near white header */
            --border-light: rgba(0, 0, 0, 0.1); /* Light borders */
            --input-background: rgba(0, 0, 0, 0.05); /* Light input background */
            --button-background: linear-gradient(90deg, #6dd5ed, #2193b0); /* Blue gradient */
            --button-shadow: 0 4px 15px rgba(109, 213, 237, 0.4), 0 4px 15px rgba(33, 147, 176, 0.4);

            /* New variables override for light mode */
            --background-color-primary: #f0f2f5;
            --background-color-secondary: #e0e2e5;
            --header-background-color: #ffffff;
            --footer-background-color: #ffffff;
            --content-background-color: #f7f9fb;
            --card-background-color: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --text-color-light: #999999;
            --accent-color: #007bff;
            --accent-color-dark: #0056b3;
            --border-color: #e0e0e0;
            --input-background-color: #f0f0f0;
            --button-background: #e9ecef;
            --button-hover-background: #dee2e6;
            --active-item-background: rgba(0, 123, 255, 0.1);
            --notification-badge-color: #dc3545;
            --status-online: #28a745;
            --status-offline: #6c757d;
            --status-away: #ffc107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;

            --play-button-green: linear-gradient(90deg, #28a745, #218838);
            --play-button-shadow: 0 4px 10px rgba(40, 167, 69, 0.4);
        }

        /* Dark Mode */
        body.theme-dark-mode {
            --background-main: #1a1a2e; /* Deep purple-dark blue */
            --background-gradient-1: #16213e; /* Slightly lighter deep blue */
            --background-gradient-2: #0f3460; /* Darker blue */
            --white: #e0e0e0; /* Off-white text */
            --text-light: #a0a0a0; /* Grayish text */
            --card-background: rgba(25, 25, 40, 0.7); /* Darker, less transparent cards */
            --header-background: linear-gradient(135deg, rgba(10, 10, 20, .85), rgba(10, 10, 20, .75)); /* Original dark header */
            --border-light: rgba(255, 255, 255, 0.08); /* Subtle white borders */
            --input-background: rgba(255, 255, 255, 0.08);
            --button-background: linear-gradient(90deg, #e94560, #ba2f49); /* Reddish gradient */
            --button-shadow: 0 4px 15px rgba(233, 69, 96, 0.4), 0 4px 15px rgba(186, 47, 73, 0.4);

            /* New variables override for dark mode */
            --background-color-primary: #121212;
            --background-color-secondary: #1e1e1e;
            --header-background-color: #2c2c2c;
            --footer-background-color: #2c2c2c;
            --content-background-color: #242424;
            --card-background-color: #2c2c2c;
            --text-color-primary: #ffffff;
            --text-color-secondary: #bbbbbb;
            --accent-color: #bb86fc;
            --accent-color-dark: #9a67ea;
            --border-color: #444444;
            --input-background-color: #383838;
            --button-background: #383838;
            --button-hover-background: #505050;
            --active-item-background: rgba(187, 134, 252, 0.2);
            --notification-badge-color: #cf6679;
            --delete-button-color: #f44336;
            --warning-color: #ffeb3b;
        }

        /* Glass Mode specific variables */
        body.theme-glass-mode {
            --background-main: rgba(10, 10, 10, 0.75);
            background-image: url('https://source.unsplash.com/random/1920x1080?abstract,blur') !important;
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            backdrop-filter: blur(10px);
            --card-background: rgba(25, 25, 40, 0.7);
            --white: #e0e0e0; /* text-color */
            --text-light: rgba(255, 255, 255, 0.7);
            --input-background: rgba(255, 255, 255, 0.05);
            --border-light: rgba(255, 255, 255, 0.1); /* glass-border-color */
            --button-background: linear-gradient(90deg, var(--pink), var(--blue));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5); /* Inner shadow for glass effect */

            /* New variables override for glass mode */
            --background-color-primary: rgba(10, 10, 10, 0.75);
            --background-color-secondary: rgba(10, 10, 10, 0.6);
            --header-background-color: rgba(10, 10, 10, 0.85);
            --footer-background-color: rgba(10, 10, 10, 0.85);
            --content-background-color: rgba(10, 10, 10, 0.75);
            --card-background-color: rgba(25, 25, 40, 0.7);
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: rgba(255, 255, 255, 0.1);
            --input-background-color: rgba(255, 255, 255, 0.05);
            --button-background: rgba(0, 213, 255, 0.15); /* Glassy button */
            --button-hover-background: rgba(0, 213, 255, 0.25);
            --active-item-background: rgba(0, 213, 255, 0.1);
        }

        /* Sunset Theme */
        body.theme-sunset-mode {
            background: linear-gradient(to top, #ff7e5f, #feb47b) !important;
            --background-main: linear-gradient(to top, #ff7e5f, #feb47b);
            --card-background: rgba(255, 255, 255, 0.15); /* Slightly transparent white for contrast */
            --white: #fff; /* White text for readability */
            --text-light: rgba(255, 255, 255, 0.8);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.3);
            --button-background: linear-gradient(90deg, #fd746c, #ff9068); /* Sunset gradient */
            --button-shadow: 0 4px 15px rgba(253, 116, 108, 0.4), 0 4px 15px rgba(255, 144, 104, 0.4);

            /* New variables override for sunset mode */
            --background-color-primary: #ff7e5f;
            --background-color-secondary: #feb47b;
            --header-background-color: rgba(255, 126, 95, 0.9);
            --footer-background-color: rgba(255, 126, 95, 0.9);
            --content-background-color: rgba(255, 126, 95, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.15);
            --text-color-primary: #fff;
            --text-color-secondary: rgba(255, 255, 255, 0.8);
            --accent-color: #ffd700;
            --accent-color-dark: #ccaa00;
            --border-color: rgba(255, 255, 255, 0.3);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: rgba(255, 255, 255, 0.2);
            --button-hover-background: rgba(255, 255, 255, 0.3);
            --active-item-background: rgba(255, 215, 0, 0.1);
        }

        /* Always show scrollbar to prevent layout shifts */
        html {
            overflow-y: scroll;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden; /* Prevent horizontal scroll */
            padding-bottom: 40px; /* Adjusted padding as bottom nav is removed */
            background-color: var(--background-main);
            background-image: radial-gradient(circle at top left, var(--background-gradient-1), transparent 100px),
                              radial-gradient(circle at bottom right, var(--background-gradient-2), transparent 150px);
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease; /* Smooth theme transition */
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 55px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 30px;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
            text-decoration: none;
        }

        /* Header Navigation (Removed as per user request) */
        header nav ul {
            display: none; /* Explicitly hide navigation */
        }

        /* User Profile Header Styling */
        .user-profile-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cool Notification Icon Styling */
        .notification-icon-wrapper {
            position: relative;
            margin-right: 15px;
        }

        .notification-icon-wrapper a {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .notification-icon-wrapper a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .notification-icon-wrapper a:hover::before {
            left: 100%;
        }

        .notification-icon-wrapper a:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 213, 255, 0.3);
            border-color: var(--blue);
        }

        .notification-icon-wrapper i {
            font-size: 1.3rem;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #ff8e53);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            transition: all 0.3s ease;
            z-index: 1;
            position: relative;
        }

        .notification-icon-wrapper a:hover i {
            transform: rotate(15deg) scale(1.1);
            background: linear-gradient(45deg, #ff8e53, #ffd700, #ff6b35);
            background-clip: text;
            -webkit-background-clip: text;
        }

        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(45deg, #ffd700, #ff6b35, #ff8e53);
            color: #000;
            border-radius: 50%;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 800;
            min-width: 22px;
            height: 22px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--background-main);
            animation: pulse-notification 2s infinite;
            z-index: 2;
        }

        @keyframes pulse-notification {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .notification-badge:empty {
            display: none;
        }

        /* Additional cool effects for notification icon */
        .notification-icon-wrapper a:active {
            transform: scale(0.95);
        }

        /* Glow effect when there are notifications */
        .notification-icon-wrapper.has-notifications a {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .notification-icon-wrapper.has-notifications a:hover {
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        /* Shaking animation for notification bell when there are unread notifications */
        .notification-icon-wrapper.has-notifications i {
            animation: bell-shake 3s ease-in-out infinite;
            transform-origin: top;
        }

        @keyframes bell-shake {
            0%, 90%, 100% { transform: rotate(0deg); }
            5%, 15%, 25%, 35% { transform: rotate(10deg); }
            10%, 20%, 30% { transform: rotate(-10deg); }
            40%, 50%, 60%, 70%, 80% { transform: rotate(0deg); }
        }

        /* Pause shaking on hover */
        .notification-icon-wrapper.has-notifications a:hover i {
            animation-play-state: paused;
        }

        .user-profile-header #profileLink {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--white);
            transition: opacity 0.3s ease, background-color 0.3s ease;
            padding: 5px 10px;
            border-radius: var(--radius);
        }

        .user-profile-header #profileLink:hover {
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .user-profile-header img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color); /* Used accent-color for consistency */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .user-profile-header i {
            font-size: 30px;
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        .user-profile-header span {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
            /* Apply gradient to names */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        /* Admin Icon Styling */
        #adminIconLink {
            display: none; /* Hidden by default */
            margin-right: 15px; /* Space it out from other icons */
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        #adminIconLink:hover {
            transform: scale(1.1);
        }

        /* Sound Toggle */
        .sound-toggle {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .sound-toggle i {
            font-size: 1.5rem;
            color: var(--text-light);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .sound-toggle i.active {
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Main Content Area */
        main {
            flex-grow: 1;
            padding: 40px 0;
            padding-top: 55px; /* Adjust for fixed header */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top */
            text-align: center;
        }

        .content-wrapper {
            width: 100%;
            max-width: 800px; /* Adjust as needed */
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        /* Chat Specific Styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 800px;
            height: calc(100vh - 120px); /* Adjust height to fit screen, considering header and input */
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            overflow: hidden; /* Hide scrollbars for the container */
        }

        .chat-header {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            gap: 15px;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .chat-header .back-btn {
            background: none;
            border: none;
            color: var(--white);
            font-size: 1.5rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .chat-header .back-btn:hover {
            transform: translateX(-5px);
        }

        .chat-header img, .chat-header .default-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .chat-header .default-avatar {
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--white);
        }

        .chat-header .default-avatar i {
            background-image: linear-gradient(90deg, var(--pink), var(--blue));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        .chat-header h2 {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--white);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
            text-align: left;
        }

                    .chat-header .select-friend-btn, .chat-header .find-friends-btn, .chat-header .call-btn {
                background: none;
                border: none;
                color: var(--text-light);
                font-size: 1.5rem;
                cursor: pointer;
                transition: color 0.3s ease;
                position: relative; /* For the badge positioning */
            }

        .chat-header .select-friend-btn {
            margin-left: auto; /* Push to the right */
        }

        .chat-header .find-friends-btn {
            margin-left: 10px; /* Space between buttons */
        }

        .chat-header .select-friend-btn:hover {
            color: var(--accent-color);
        }

        .chat-header .find-friends-btn:hover {
            color: #4CAF50;
        }

        /* Badge for Select Friend Button */
        .select-friend-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--notification-badge-color); /* Reuse notification color */
            color: var(--white);
            border-radius: 50%;
            padding: 3px 7px;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2; /* Above the button icon */
        }
        .messages-display {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            scroll-behavior: smooth; /* Smooth scrolling to new messages */
        }

        .message-bubble {
            display: flex;
            max-width: 80%;
            flex-direction: column; /* Stack content and info */
            position: relative; /* For options positioning */
        }

        .message-bubble.sent {
            margin-left: auto;
            align-items: flex-end; /* Align content to the right */
        }

        .message-bubble.received {
            margin-right: auto;
            align-items: flex-start; /* Align content to the left */
        }

        .message-content {
            padding: 10px 15px;
            border-radius: 15px;
            font-size: 0.95rem;
            word-wrap: break-word; /* Ensure long words break */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            max-width: 100%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .message-bubble.sent .message-content {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border-bottom-right-radius: 0;
        }

        .message-bubble.received .message-content {
            background-color: var(--input-background);
            color: var(--white);
            border: 1px solid var(--border-light);
            border-bottom-left-radius: 0;
        }

        .message-info {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 5px;
            text-align: right; /* For sent messages */
        }

        .message-bubble.received .message-info {
            text-align: left; /* For received messages */
        }

        .message-content img, .message-content video {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin-top: 5px;
        }

        /* Audio Player Specific Styles - Very Tiny Small */
        .message-content .audio-player-wrapper {
            display: flex;
            align-items: center; /* Align items vertically in the center */
            gap: 8px; /* Space between play button, progress, and time */
            width: 200px; /* Fixed small width for the entire audio player */
            padding: 5px; /* Small padding inside wrapper */
            background-color: rgba(255, 255, 255, 0.05); /* Subtle background for the player */
            border-radius: 10px;
        }

        .audio-player-wrapper .play-pause-btn {
            background: var(--play-button-green); /* Beautiful green gradient */
            color: var(--white);
            border: none;
            border-radius: 50%; /* Circular button */
            width: 30px; /* Small size */
            height: 30px; /* Small size */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: var(--play-button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .audio-player-wrapper .play-pause-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.5);
        }

        .audio-player-wrapper .progress-container {
            flex-grow: 1; /* Allow progress bar to take available space */
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0; /* Allow content to shrink */
        }

        .audio-player-wrapper .progress-bar {
            width: 100%;
            height: 4px; /* Thin progress bar */
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            outline: none;
            margin: 0; /* Remove default margin */
            padding: 0; /* Remove default padding */
        }

        /* Style for WebKit browsers (Chrome, Safari) */
        .audio-player-wrapper .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px; /* Thumb size */
            height: 12px; /* Thumb size */
            border-radius: 50%;
            background: var(--accent-color); /* Highlight color for thumb */
            cursor: pointer;
            margin-top: -4px; /* Adjust thumb position */
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .audio-player-wrapper .progress-bar::-webkit-slider-runnable-track {
            background: linear-gradient(to right, var(--accent-color) var(--progress, 0%), rgba(255, 255, 255, 0.3) var(--progress, 0%));
            border-radius: 2px;
            height: 4px;
        }

        /* Style for Firefox */
        .audio-player-wrapper .progress-bar::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }
        .audio-player-wrapper .progress-bar::-moz-range-track {
            background: linear-gradient(to right, var(--accent-color) var(--progress, 0%), rgba(255, 255, 255, 0.3) var(--progress, 0%));
            border-radius: 2px;
            height: 4px;
        }

        .audio-player-wrapper .time-display {
            font-size: 0.7rem;
            color: var(--text-light);
            white-space: nowrap;
        }

        .message-content .audio-buttons {
            display: flex;
            justify-content: space-around;
            gap: 3px; /* Reduced gap between buttons */
            margin-top: 5px; /* Space between player and action buttons */
        }

        .message-content .audio-buttons button {
            background-color: rgba(255, 255, 255, 0.15);
            color: var(--white);
            border: none;
            border-radius: 5px; /* Smaller border radius */
            padding: 4px 6px; /* Reduced padding */
            font-size: 0.7rem; /* Smaller font size */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            gap: 3px; /* Reduced gap for icon and text */
            flex-grow: 1;
            justify-content: center;
        }

        .message-content .audio-buttons button:hover {
            background-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px);
        }

        .message-content .audio-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Voice Note Recording UI */
        #voiceNoteBtn {
            position: relative;
            overflow: hidden; /* Hide overflow for pulsing effect */
        }

        #voiceNoteBtn.recording {
            background: linear-gradient(90deg, #dc3545, #e94560); /* Red gradient for recording */
            box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            animation: pulse-red 1.5s infinite;
        }

        #voiceNoteBtn.recording .button-text {
            display: inline-block; /* Ensure text is visible */
            margin-left: 5px; /* Space for icon */
        }

        #voiceNoteBtn.recording .recording-timer {
            margin-left: 10px;
            font-weight: bold;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }


        /* Message Options */
        .message-options-btn {
            position: absolute;
            top: 5px;
            right: -25px; /* Adjust as needed */
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 0.9rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .message-bubble.sent .message-options-btn {
            left: -25px; /* For sent messages, place on the left */
            right: auto;
        }
        .message-bubble:hover .message-options-btn {
            opacity: 1;
        }

        .message-options-menu {
            position: absolute;
            top: 0; /* Aligned with the top of the message bubble */
            right: -80px; /* Position to the right of the bubble */
            background: var(--card-background-color);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            z-index: 5;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            min-width: 70px; /* Adjust width as needed */
        }
        .message-bubble.sent .message-options-menu {
            left: -80px; /* For sent messages, position to the left */
            right: auto;
        }
        .message-options-menu.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .message-options-menu button {
            background: none;
            border: none;
            color: var(--text-color-primary);
            padding: 8px 10px;
            text-align: left;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .message-options-menu button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .message-options-menu button:first-child { border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .message-options-menu button:last-child { border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; }
        .message-options-menu button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Message Editing State */
        .message-bubble.editing .message-content {
            background: var(--input-background);
            border: 1px solid var(--accent-color);
            padding: 10px;
            border-radius: 15px;
        }
        .message-bubble.editing .message-content textarea {
            width: 100%;
            background: none;
            border: none;
            outline: none;
            color: var(--white);
            font-size: 0.95rem;
            resize: none;
            min-height: 40px;
            max-height: 150px;
            overflow-y: auto;
        }
        .message-bubble.editing .edit-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end;
        }
        .message-bubble.editing .edit-actions button {
            padding: 8px 15px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .message-bubble.editing .edit-actions .save-btn {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            box-shadow: 0 4px 10px rgba(0, 213, 255, 0.3);
        }
        .message-bubble.editing .edit-actions .save-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 213, 255, 0.4);
        }
        .message-bubble.editing .edit-actions .cancel-btn {
            background: var(--input-background);
            color: var(--text-light);
            border: 1px solid var(--border-light);
        }
        .message-bubble.editing .edit-actions .cancel-btn:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.1);
        }


        .chat-input-area {
            display: flex;
            flex-direction: column; /* Stack buttons and input vertically */
            padding: 15px 20px;
            border-top: 1px solid var(--border-light);
            background: var(--header-background);
            gap: 10px;
            flex-shrink: 0; /* Prevent input area from shrinking */
        }

        /* Improve layout of feature buttons */
        .chat-actions-top { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
        .gated-btn { background: var(--button-background); color: var(--white); border: 1px solid var(--border-light); border-radius: 10px; padding: 8px 10px; display:flex; align-items:center; gap:6px; cursor: pointer; }
        .gated-btn i { font-size: 0.95rem; }
        .gated-btn .lock-badge { display:inline-flex; align-items:center; justify-content:center; margin-left: 2px; opacity: .9; }
        @media (max-width: 600px) {
            .gated-btn { padding: 6px 8px; font-size: 0.85rem; }
            .gated-btn i { font-size: 0.9rem; }
        }
        .chat-input-area .chat-actions-top button {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: 1px solid var(--border-light);
            border-radius: var(--radius);
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .chat-input-row {
            display: flex;
            gap: 8px;
            width: 100%;
            align-items: center;
            padding: 8px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .chat-input-area textarea {
            flex-grow: 1;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
            resize: none;
            min-height: 40px;
            max-height: 140px;
            overflow-y: auto;
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
            line-height: 1.5;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
        }

        .chat-input-area textarea::placeholder {
            color: #999999;
        }

        .chat-input-area textarea:focus {
            border-color: var(--composer-accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .chat-input-area #sendMessageBtn {
            background: var(--composer-accent);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            height: 40px;
            padding: 0 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-shrink: 0;
        }
        .chat-input-area #sendMessageBtn i { margin: 0; font-size: 16px; }

        .chat-input-area #sendMessageBtn:hover:not(:disabled) {
            background: #2563eb;
            box-shadow: 0 3px 10px rgba(59, 130, 246, 0.35);
        }

        .chat-input-area #sendMessageBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            background: #94a3b8;
        }

        /* Sticker picker improvements */
        #stickerPickerClose:hover {
            background: #e0e0e0 !important;
            transform: scale(1.1);
        }

        #stickerPicker {
            animation: slideUp 0.2s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(10px);
            }
        }

        /* Responsive design for mobile devices */
        @media (max-width: 768px) {
            .chat-input-row {
                gap: 8px;
                padding: 6px 8px;
                background: var(--bg-secondary);
            }
            
            .chat-input-area textarea {
                padding: 8px 10px;
                font-size: 14px;
                min-height: 38px;
            }
            
            .chat-input-area #sendMessageBtn {
                height: 38px;
                padding: 0 10px;
                font-size: 13px;
            }
            .chat-input-area #sendMessageBtn .send-text { display: none; }
            
            #stickerPicker {
                width: min(300px, 95vw) !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
            }
            
            #stickerGrid {
                grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)) !important;
                gap: 6px !important;
            }
        }

        @media (max-width: 480px) {
            #stickerPicker {
                width: 95vw !important;
                padding: 12px !important;
            }
            
            #stickerTabs {
                gap: 6px !important;
            }
            
            #stickerTabs button {
                padding: 6px 12px !important;
                font-size: 12px !important;
            }
        }

        /* Typing Indicator Styles */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            margin: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            width: fit-content;
            animation: fadeIn 0.3s ease;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 6px;
            height: 6px;
            background: #25D366;
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typingBounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Message Status Indicators */
        .message-status {
            display: flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
            font-size: 12px;
        }

        .status-sent { color: #999; }
        .status-delivered { color: #25D366; }
        .status-read { color: #25D366; }

        /* Emoji Reactions */
        .message-reactions {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .reaction {
            background: rgba(37, 211, 102, 0.1);
            border: 1px solid rgba(37, 211, 102, 0.3);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reaction:hover {
            background: rgba(37, 211, 102, 0.2);
            transform: scale(1.1);
        }

        .reaction.active {
            background: rgba(37, 211, 102, 0.3);
            border-color: #25D366;
        }

        /* Quick Reactions Panel */
        .quick-reactions {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideUp 0.3s ease;
        }

        .reaction-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reaction-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            border-color: #25D366;
        }

        .reaction-btn:active {
            transform: scale(0.95);
        }
        /* Reaction Toggle Button */
        #reactionToggleBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        #reactionToggleBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Theme Switcher */
        .theme-switcher-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .theme-switcher-btn:hover {
            transform: rotate(180deg) scale(1.1);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }

        /* Dark Theme Variables */
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --accent-color: #25D366;
            --composer-accent: #3b82f6;
            --border-color: #404040;
        }

        /* Light Theme Variables */
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --accent-color: #25D366;
            --border-color: #e0e0e0;
        }

        /* Refresh Indicator */
        .refresh-indicator {
            background: rgba(37, 211, 102, 0.1);
            border: 1px solid rgba(37, 211, 102, 0.3);
            border-radius: 20px;
            margin: 10px 20px;
            animation: fadeIn 0.3s ease;
        }

        /* Enhanced Responsive Design */
        @media (max-width: 768px) {
            .chat-container {
                height: 100vh;
                height: 100dvh; /* Dynamic viewport height for mobile */
            }
            
            .chat-header {
                padding: 8px 12px;
            }
            
            .chat-header h2 {
                font-size: 18px;
            }
            
            .chat-actions-top {
                gap: 6px;
                padding: 8px 12px;
            }
            
            .chat-actions-top button {
                padding: 8px 10px;
                font-size: 12px;
            }
            
            .quick-reactions {
                padding: 6px 12px;
                gap: 6px;
            }
            
            .reaction-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .chat-header {
                padding: 6px 8px;
            }
            
            .chat-header h2 {
                font-size: 16px;
            }
            
            .chat-actions-top button {
                padding: 6px 8px;
                font-size: 11px;
            }
            
            .reaction-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
            
            .typing-indicator {
                margin: 6px 12px;
                padding: 6px 12px;
            }
        }

        /* Enhanced Call Status Overlay */
        #callStatusOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
            color: var(--white);
            backdrop-filter: blur(10px);
        }
        #callStatusOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        #callStatusOverlay h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 20px;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            text-align: center;
        }
        #callStatusOverlay p {
            font-size: 1.4rem;
            margin-bottom: 30px;
            text-align: center;
            opacity: 0.9;
        }
        #callStatusOverlay .call-actions {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #callStatusOverlay .call-actions button {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: none;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 2rem;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        #callStatusOverlay .call-actions button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        #callStatusOverlay .call-actions button:hover::before {
            left: 100%;
        }
        #callStatusOverlay .call-actions button.end-call-btn {
            background: linear-gradient(45deg, #ff4757, #ff3742);
        }
        #callStatusOverlay .call-actions button.accept-call-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        #callStatusOverlay .call-actions button.reject-call-btn {
            background: linear-gradient(45deg, #6c757d, #5a6268);
        }
        #callStatusOverlay .call-actions button.mute-btn {
            background: linear-gradient(45deg, #ffc107, #e0a800);
        }
        #callStatusOverlay .call-actions button.video-toggle-btn {
            background: linear-gradient(45deg, #17a2b8, #138496);
        }
        #callStatusOverlay .call-actions button:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
        }
        #callStatusOverlay .call-actions button:active {
            transform: translateY(-4px) scale(0.98);
        }

        /* Video Call Interface */
        .video-call-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1003;
            display: none;
            flex-direction: column;
        }
        .video-call-container.active {
            display: flex;
        }
        .video-grid {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 20px;
            position: relative;
        }
        .video-item {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .video-item.fullscreen {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        .video-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 15px;
        }
        .video-item .video-label {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .video-item .connection-status {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            border: 2px solid white;
        }
        .video-item .connection-status.poor {
            background: #ffc107;
        }
        .video-item .connection-status.disconnected {
            background: #ff4757;
        }
        .video-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        .video-controls button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .video-controls button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .video-controls button.active {
            background: #4CAF50;
        }
        .video-controls button.muted {
            background: #ff4757;
        }
        .video-controls button.end-call {
            background: #ff4757;
        }
        .video-controls button.end-call:hover {
            background: #ff3742;
            transform: scale(1.1);
        }
        .call-timer {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .call-quality-indicator {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 5px;
        }
        .quality-bar {
            width: 4px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        .quality-bar.active {
            background: #4CAF50;
        }
        .quality-bar.poor {
            background: #ffc107;
        }
        .quality-bar.bad {
            background: #ff4757;
        }

        /* Voice Call Interface */
        .voice-call-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 1003;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .voice-call-container.active {
            display: flex;
        }
        .voice-call-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        .voice-call-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        .voice-call-avatar i {
            font-size: 4rem;
            color: rgba(255, 255, 255, 0.8);
        }
        .voice-call-avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: rotate 3s linear infinite;
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .voice-call-info {
            text-align: center;
            margin-bottom: 50px;
        }
        .voice-call-info h2 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
        }
        .voice-call-info p {
            font-size: 1.2rem;
            opacity: 0.8;
            color: white;
        }
        .voice-controls {
            display: flex;
            gap: 20px;
        }
        .voice-controls button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }
        .voice-controls button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .voice-controls button.active {
            background: #4CAF50;
        }
        .voice-controls button.muted {
            background: #ff4757;
        }
        .voice-controls button.end-call {
            background: #ff4757;
        }
        .voice-controls button.end-call:hover {
            background: #ff3742;
        }

        /* Call Loading Animation */
        .call-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .call-loading .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .call-loading .pulse {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
        }



            .notification-item {
                padding: 12px;
            }

            .notification-content {
                gap: 10px;
            }

            .notification-icon {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }

        /* Find Friends Modal Styling */
        .find-friends-modal {
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid var(--border-light);
            background: linear-gradient(135deg, var(--blue), var(--pink));
            border-radius: 20px 20px 0 0;
        }

        .modal-header h3 {
            color: white;
            margin: 0;
            font-size: 1.3rem;
            font-weight: 700;
        }

        .close-modal-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .search-container {
            position: relative;
            margin: 20px 25px;
        }

        .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-light);
            font-size: 1rem;
        }

        .search-container input {
            width: 100%;
            padding: 12px 15px 12px 45px;
            border: 1px solid var(--border-light);
            border-radius: 25px;
            background: var(--input-background);
            color: var(--white);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .search-container input:focus {
            outline: none;
            border-color: var(--blue);
            box-shadow: 0 0 10px rgba(0, 213, 255, 0.3);
        }

        .search-container input::placeholder {
            color: var(--text-light);
        }

        .user-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 25px 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .user-list::-webkit-scrollbar {
            width: 6px;
        }

        .user-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .user-list::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, var(--blue), var(--pink));
            border-radius: 3px;
        }

        .user-card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: inherit;
        }
        .user-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }
        .user-card img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--blue);
            flex-shrink: 0;
        }

        .user-card .default-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            flex-shrink: 0;
        }

        .user-card h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--white);
            flex-grow: 1;
        }

        .user-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .action-btn {
            padding: 8px 12px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            color: white;
            white-space: nowrap;
        }

        .action-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .add-friend-btn {
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
        }

        .add-friend-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4);
        }

        .cancel-request-btn {
            background: linear-gradient(45deg, #ffc107, #ff9800);
            box-shadow: 0 4px 10px rgba(255, 193, 7, 0.3);
        }

        .cancel-request-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 193, 7, 0.4);
        }

        .accept-request-btn {
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
        }

        .accept-request-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4);
        }

        .reject-request-btn {
            background: linear-gradient(45deg, #f44336, #e91e63);
            box-shadow: 0 4px 10px rgba(244, 67, 54, 0.3);
        }

        .reject-request-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(244, 67, 54, 0.4);
        }

        .unfriend-btn {
            background: linear-gradient(45deg, #f44336, #e91e63);
            box-shadow: 0 4px 10px rgba(244, 67, 54, 0.3);
        }

        .unfriend-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(244, 67, 54, 0.4);
        }

        .chat-btn {
            background: linear-gradient(45deg, var(--blue), var(--pink));
            box-shadow: 0 4px 10px rgba(0, 213, 255, 0.3);
        }

        .chat-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 213, 255, 0.4);
        }

        .loading-users-message, .no-users-message {
            text-align: center;
            color: var(--text-light);
            font-size: 1rem;
            margin: 20px 0;
        }

        .button-loader {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: none;
        }

        .action-btn.loading .button-loader {
            display: block;
        }

        .action-btn.loading .button-text {
            display: none;
        }


        /* Custom Message Box Styles */
        #messageBox {
            position: fixed;
            top: 50%; /* Center vertically */
            left: 50%;
            transform: translate(-50%, -50%); /* Center both horizontally and vertically */
            background-color: var(--card-background-color); /* Default background, will be overridden for success */
            color: var(--text-color-primary); /* Default text color */
            padding: 20px 30px; /* Increased padding for a more substantial box */
            border-radius: 15px; /* More rounded corners, slightly squarer */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4); /* Enhanced shadow */
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            min-width: 280px; /* Ensure a decent minimum width */
            max-width: 90%;
            text-align: center;
            flex-direction: column; /* Stack icon and text vertically */
            align-items: center;
            gap: 15px; /* Space between icon and text */
        }
        #messageBox.show {
            opacity: 1;
            display: flex;
        }
        /* Success message box specific styling */
        #messageBox.success {
            background-image: linear-gradient(45deg, var(--pink), var(--blue)); /* Pink and blue gradient */
            color: var(--white); /* White text for contrast on gradient */
            border: none; /* No border for gradient background */
            box-shadow: 0 8px 30px rgba(0, 213, 255, 0.5), 0 8px 30px rgba(255, 46, 146, 0.5); /* Glowing shadow */
        }
        #messageBox.error { border-left: 5px solid var(--delete-button-color); background-color: var(--card-background-color); color: var(--text-color-primary); }
        #messageBox.info { border-left: 5px solid var(--accent-color); background-color: var(--card-background-color); color: var(--text-color-primary); }
        #messageBox.warning { border-left: 5px solid var(--warning-color); background-color: var(--card-background-color); color: var(--text-color-primary); }

        #messageBox i {
            font-size: 2.5rem; /* Larger icon for prominence */
            margin-bottom: 5px; /* Space between icon and text */
            /* Apply gradient to message box icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }
        #messageBox.success i { color: var(--white); } /* White icon for success */
        #messageBox.error i { color: var(--delete-button-color); }
        #messageBox.info i { color: var(--accent-color); }
        #messageBox.warning i { color: var(--warning-color); }

        #messageBox span {
            font-size: 1.1rem; /* Slightly larger text */
            font-weight: 600;
        }

        @keyframes pulse-bg {
            0% { background-color: var(--accent-color); }
            50% { background-color: rgba(0, 213, 255, 0.7); }
            100% { background-color: var(--accent-color); }
        }
        #messageBox.loading-pulse { animation: pulse-bg 1.5s infinite ease-in-out; }

        /* Loader styles for buttons */
        .button-loader {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--white);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
            flex-shrink: 0; /* Prevent loader from shrinking */
        }
        .button-loader.active { display: block; }
        .button-text { display: block; }
        .loading .button-text { display: none; }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Confirmation Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: var(--card-background);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .modal-content h3 {
            color: var(--white);
            margin-top: 0;
            margin-bottom: 20px;
            font-family: 'Poppins', sans-serif;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        .modal-buttons button {
            padding: 10px 25px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .modal-buttons button.confirm-btn {
            background: linear-gradient(90deg, var(--pink), var(--blue));
            color: var(--white);
            box-shadow: 0 4px 10px rgba(0, 213, 255, 0.3);
        }
        .modal-buttons button.confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 213, 255, 0.4);
        }
        .modal-buttons button.cancel-btn {
            background: var(--input-background);
            color: var(--text-light);
            border: 1px solid var(--border-light);
        }
        .modal-buttons button.cancel-btn:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.1);
        }

        /* Friend Selection Modal Specific Styles */
        #selectFriendModal .modal-content {
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #selectFriendModal .search-input {
            width: 100%;
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid var(--border-light);
            background-color: var(--input-background);
            color: var(--white);
            font-size: 1rem;
            outline: none;
        }

        #selectFriendModal .search-input::placeholder {
            color: var(--text-light);
        }

        #selectFriendModal .friend-list-modal {
            flex-grow: 1;
            overflow-y: auto;
            max-height: calc(80vh - 150px); /* Adjust based on other elements in modal */
            padding-right: 5px; /* For scrollbar */
        }

        #selectFriendModal .friend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border-radius: 10px;
            background-color: var(--input-background);
            border: 1px solid var(--border-light);
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        #selectFriendModal .friend-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        #selectFriendModal .friend-item img,
        #selectFriendModal .friend-item .default-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            flex-shrink: 0;
        }

        #selectFriendModal .friend-item .default-avatar {
            background: linear-gradient(45deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--white);
        }

        #selectFriendModal .friend-item span {
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Badge for individual friend items in modal */
        #selectFriendModal .friend-item .message-badge {
            background-color: var(--notification-badge-color);
            color: var(--white);
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 0.65rem;
            font-weight: 700;
            min-width: 18px;
            text-align: center;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            margin-left: auto; /* Push to the right */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #selectFriendModal .loading-friends-modal,
        #selectFriendModal .no-friends-modal {
            text-align: center;
            color: var(--text-light);
            padding: 20px;
            font-style: italic;
        }


        /* Responsive Adjustments */
        @media (max-width: 600px) {
            header .header-content-wrapper {
                padding: 0 20px;
            }
            .logo {
                font-size: 1.6rem;
            }
            header nav ul {
                gap: 15px;
            }
            header nav ul li a {
                font-size: 1.1rem;
            }
            .user-profile-header #profileLink {
                padding: 5px;
            }
            .user-profile-header span {
                max-width: 90px;
            }
            .user-profile-header img {
                width: 30px;
                height: 30px;
            }
            .user-profile-header i {
                font-size: 25px;
            }
            .chat-container {
                height: calc(100vh - 100px); /* Adjust height for mobile */
            }
            .chat-header {
                padding: 10px 15px;
            }
            .chat-header h2 {
                font-size: 1.2rem;
            }
            .messages-display {
                padding: 15px;
            }
            .message-content {
                font-size: 0.9rem;
            }
            .message-options-btn {
                right: -20px;
                font-size: 0.8rem;
            }
            .message-bubble.sent .message-options-btn {
                left: -20px;
            }
            .message-options-menu {
                right: -70px;
                left: auto; /* Reset left for mobile */
            }
            .message-bubble.sent .message-options-menu {
                left: -70px;
                right: auto;
            }
            .message-options-menu button {
                font-size: 0.8rem;
                padding: 6px 8px;
            }
            .chat-input-area {
                padding: 10px 15px;
            }
            .chat-input-area textarea {
                font-size: 0.9rem;
            }
            .chat-input-area #sendMessageBtn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            .chat-actions-top button {
                font-size: 0.8rem;
                padding: 6px 8px;
            }
            body {
                padding-bottom: 40px; /* Reset padding for no bottom nav */
            }
        }

        /* Theme Switcher Button (small) */
        .theme-switcher-btn {
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.7), rgba(255, 46, 146, 0.7));
            color: var(--white);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-left: 8px;
        }
        .theme-switcher-btn:hover { transform: scale(1.05); }

        /* Unlock store responsive layout */
        #unlockStore { overflow: auto; }
        #unlockStore .unlock-card { max-width: 960px; margin: 32px auto; border-radius: 16px; background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); box-shadow: 0 20px 50px rgba(0,0,0,0.5); backdrop-filter: blur(10px); }
        #unlockStore .neon-glow { box-shadow: 0 0 20px rgba(0,213,255,0.3), 0 0 40px rgba(255,46,146,0.2), 0 0 80px rgba(0,213,255,0.15); border: 1px solid rgba(0,213,255,0.35); }
        #unlockStore .unlock-header { position: sticky; top: 0; background: linear-gradient(90deg, var(--blue), var(--pink)); border-bottom: 1px solid var(--border-light); z-index: 2; }
        #unlockStore .unlock-header h3 { color: #fff !important; }
        #unlockStore .unlock-body { display: grid; grid-template-columns: 1.2fr 0.8fr; max-height: calc(100vh - 120px); overflow: hidden; }
        #unlockStore .unlock-side { padding: 16px; border-right: 1px solid var(--border-light); max-height: calc(100vh - 120px); overflow: auto; }
        #unlockStore .unlock-right { padding: 16px; max-height: calc(100vh - 120px); overflow: auto; }
        #unlockStore .unlock-features-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:12px; }
        #unlockStore .unlock-features-grid .management-card { min-height: 160px; display:flex; flex-direction:column; gap:6px; transition: transform .2s ease, box-shadow .2s ease; }
        #unlockStore .unlock-features-grid .management-card:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(0,0,0,0.35); }
        #unlockStore .price-chip { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background: rgba(255,255,255,0.1); border:1px solid var(--border-light); color:var(--white); font-weight:700; }
        #unlockStore .step { display:flex; gap:10px; align-items:flex-start; }
        #unlockStore .step .num { width:22px; height:22px; border-radius:50%; background: linear-gradient(90deg, var(--blue), var(--pink)); display:flex; align-items:center; justify-content:center; font-size:.8rem; font-weight:800; }
        #unlockStore .receipt-preview { width:100%; max-height:180px; object-fit:contain; border-radius:10px; border:1px solid var(--border-light); display:none; }
        @media (max-width: 900px) {
            #unlockStore .unlock-body { grid-template-columns: 1fr; max-height: calc(100vh - 120px); }
            #unlockStore .unlock-side { border-right: none; border-bottom: 1px solid var(--border-light); }
            #unlockStore .unlock-card { margin: 20px auto; }
        }
        
        /* Unlock Store Feature Preview */
        #unlockStore .feature-preview { background: rgba(255,255,255,0.03); border: 1px solid var(--border-light); border-radius: 12px; padding: 10px; margin-bottom: 10px; }
        #unlockStore .feature-preview h4 { margin: 0 0 4px 0; color: var(--white); }
        #unlockStore .feature-preview p { margin: 0; color: var(--text-light); font-size: .95rem; }
        #unlockStore .section-title { margin: 12px 0 8px; color: var(--white); font-weight: 800; font-size: 1rem; }
        #unlockStore .info-card { margin:10px 0; padding:10px; border:1px dashed var(--border-light); border-radius:10px; }
        #unlockStore .upload-card { margin-top:12px; padding:10px; border:1px solid var(--border-light); border-radius:12px; background: rgba(255,255,255,0.03); }
        #unlockStore .dropzone { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px; border:2px dashed var(--border-light); border-radius:10px; cursor:pointer; }
        #unlockStore .dropzone:hover { background: rgba(255,255,255,0.04); }
        #unlockStore .file-name { color: var(--text-light); font-size: .9rem; margin-left: 6px; }

        /* Unlock Store layout fixes to prevent overflow clipping */
        #unlockStore { display:flex; align-items:center; justify-content:center; }
        #unlockStore .unlock-card { max-height: 90vh; display:flex; flex-direction:column; }
        #unlockStore .unlock-header { position: sticky; top: 0; z-index: 2; }
        #unlockStore .unlock-body { display: grid; grid-template-columns: 1.2fr 0.8fr; flex: 1; overflow: visible; }
        #unlockStore .unlock-side, #unlockStore .unlock-right { overflow: auto; min-height: 0; }
        @media (max-width: 900px) {
            #unlockStore .unlock-body { grid-template-columns: 1fr; }
        }

        /* Emoji picker and Reaction bar */
        #emojiPicker { display:none; position:fixed; bottom:84px; left:16px; width:280px; max-height:240px; overflow:auto; background:var(--card-background); border:1px solid var(--border-light); border-radius:12px; padding:8px; box-shadow:0 8px 20px rgba(0,0,0,0.4); z-index:900; }
        #emojiGrid { display:grid; grid-template-columns: repeat(8, 1fr); gap:6px; }
        #emojiGrid button { font-size:20px; padding:6px; border-radius:8px; background:transparent; border:1px solid var(--border-light); cursor:pointer; }
        #emojiGrid button:hover { background: rgba(255,255,255,0.05); }

        #reactionBar { display:none; position:fixed; background:var(--card-background); border:1px solid var(--border-light); border-radius:12px; padding:8px; box-shadow:0 6px 16px rgba(0,0,0,0.35); z-index:1200; max-height: 260px; width: 320px; overflow: auto; }
        #reactionBar .grid { display:grid; grid-template-columns: repeat(8, 1fr); gap:6px; }
        #reactionBar button { font-size:20px; padding:6px; border-radius:8px; border:1px solid var(--border-light); background:transparent; cursor:pointer; }
        #reactionBar button:hover { background: rgba(255,255,255,0.08); }
        .reactions-row { display:flex; gap:6px; align-items:center; margin-top:4px; flex-wrap:wrap; }
        .reaction-pill { display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border:1px solid var(--border-light); border-radius:999px; background: rgba(255,255,255,0.04); font-size: 0.9rem; }
+        /* Inline feature panels (toggles) */
+        .feature-panels { margin-top: 8px; display: grid; gap: 8px; }
+        .feature-panel { display: none; padding: 8px; border:1px solid var(--border-light); border-radius: 10px; background: rgba(255,255,255,0.03); }
+        .feature-panel h4 { margin: 0 0 6px 0; color: var(--white); font-size: 0.95rem; }
+        #stickersPanelGrid, #emojiPanelGrid { display:grid; grid-template-columns: repeat(8, 1fr); gap:6px; }
+        #emojiPanelGrid button { font-size:20px; padding:6px; border-radius:8px; background:transparent; border:1px solid var(--border-light); cursor:pointer; }
+        #emojiPanelGrid button:hover { background: rgba(255,255,255,0.05); }
+        #mediaPanelDrop { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px; border:2px dashed var(--border-light); border-radius:10px; cursor:pointer; }
+        #mediaPanelDrop:hover { background: rgba(255,255,255,0.04); }
     </style>
</head>
<body class="theme-dark-mode">

    <header>
        <div class="header-content-wrapper">
            <a href="/Home.html" class="logo">JCHAT</a>
            <nav>
                <ul>
                    <!-- Removed Home and Profile links from header navigation -->
                </ul>
            </nav>
            <div class="user-profile-header">
                <!-- Admin Icon Link (visible only to admin) -->
                <a href="/coin_management.html" id="adminIconLink" aria-label="Admin Dashboard" style="display: none;">
                    <i class="fas fa-user-cog"></i>
                </a>
                <div class="notification-icon-wrapper">
                    <a href="notifications.html" aria-label="Notifications">
                        <i class="fas fa-bell"></i>
                        <span id="notificationCount" class="notification-badge" style="display: none;">0</span>
                    </a>
                </div>
                <!-- Sound Toggle -->
                <div class="sound-toggle">
                    <i id="soundToggleIcon" class="fas fa-volume-up active" title="Toggle Notification Sounds"></i>
                </div>
                <a href="Profile.html" id="profileLink">
                    <img id="headerProfilePic" src="" alt="Profile Picture" style="display: none;">
                    <i id="headerAvatarIcon" class="fas fa-user-circle"></i>
                    <span id="headerDisplayName">Loading...</span>
                </a>
            </div>
        </div>
    </header>

    <main>
        <div class="chat-container">
            <div class="chat-header">
                <button class="back-btn" onclick="window.history.back()"><i class="fas fa-arrow-left"></i></button>
                <img id="partnerProfilePic" src="" alt="Partner Profile Picture" style="display: none;">
                <div id="partnerAvatarIcon" class="default-avatar"><i class="fas fa-user-circle"></i></div>
                <h2 id="partnerDisplayName">Loading...</h2>
                <button id="selectFriendBtn" class="select-friend-btn" title="Select Chat Partner">
                    <i class="fas fa-users"></i>
                    <span class="select-friend-badge" id="selectFriendBadge" style="display: none;">0</span>
                </button>
                <button id="findFriendsBtn" class="find-friends-btn" title="Find New Friends">
                    <i class="fas fa-user-plus"></i>
                </button>
                <button id="voiceCallBtn" class="call-btn" title="Start Voice Call">
                    <i class="fas fa-phone"></i>
                </button>
                <button id="videoCallBtn" class="call-btn" title="Start Video Call">
                    <i class="fas fa-video"></i>
                </button>
                <button id="themeSwitcherBtn" class="theme-switcher-btn" aria-label="Switch Theme" title="Toggle Theme">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
            <div class="messages-display" id="messagesDisplay">
                <!-- Messages will be loaded here dynamically -->
                <p id="loadingMessages" style="text-align: center; color: var(--text-light);">Loading messages...</p>
                <p id="noMessages" style="text-align: center; color: var(--text-light); display: none;">No messages yet. Start a conversation!</p>
                
                <!-- Typing Indicator -->
                <div id="typingIndicator" class="typing-indicator" style="display: none;">
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                    <span class="typing-text">typing...</span>
                </div>
            </div>
            <div class="chat-input-area">
                <div class="chat-actions-top">
                    <input type="file" id="mediaInput" accept="image/*,video/*" style="display: none;">
                    <button id="mediaShareBtn" title="Share Media"><i class="fas fa-image"></i> Media</button>
                    <button id="voiceNoteBtn" title="Record Voice Note">
                        <i class="fas fa-microphone"></i>
                        <span class="button-text">Voice Note</span>
                        <span class="recording-timer" style="display: none;">00:00</span>
                    </button>
                    <button id="stickersBtn" class="gated-btn" title="Stickers" style="position: relative;">
                        <i class="fas fa-face-smile"></i> Stickers <span class="lock-badge" style="display:none"><i class="fas fa-lock"></i></span>
                        
                    </button>
                    
                </div>

                <!-- Quick Emoji Reactions -->
                <div id="quickReactions" class="quick-reactions" style="display: none;">
                    <button class="reaction-btn" data-reaction=""></button>
                    <button class="reaction-btn" data-reaction=""></button>
                    <button class="reaction-btn" data-reaction=""></button>
                    <button class="reaction-btn" data-reaction=""></button>
                    <button class="reaction-btn" data-reaction=""></button>
                    <button class="reaction-btn" data-reaction=""></button>
                </div>

                <div class="chat-input-row">
                    <textarea id="messageInput" placeholder="Type a message" rows="1"></textarea>
                    <button id="sendMessageBtn" aria-label="Send message"><i class="fas fa-paper-plane"></i><span class="send-text">Send</span></button>
                </div>
            </div>
        </div>
    </main>

    <!-- Stickers Overlay (moved outside buttons to allow proper interactions) -->
    <div id="stickerPicker" style="display:none; position:fixed; bottom:80px; left:50%; transform:translateX(-50%); width:min(420px, 96vw); max-height:min(60vh, 520px); overflow:auto; background:#ffffff; border:1px solid #e0e0e0; border-radius:16px; padding:16px; box-shadow:0 8px 32px rgba(0,0,0,0.12); z-index:1200;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:16px; border-bottom:1px solid #f0f0f0; padding-bottom:12px;">
            <span style="font-weight:600; color:#1a1a1a; font-size:16px; font-family:'Segoe UI', sans-serif;"> Stickers</span>
            <div id="stickerPickerClose" role="button" tabindex="0" aria-label="Close stickers" style="background: #f5f5f5; border: none; color: #666; border-radius: 50%; width:32px; height:32px; cursor: pointer; display:flex; align-items:center; justify-content:center; transition:all 0.2s ease;" onmouseover="this.style.background='#e0e0e0'" onmouseout="this.style.background='#f5f5f5'"><i class="fas fa-times"></i></div>
        </div>
        <div class="sticker-tabs-row" style="display:flex; align-items:center; gap:6px; margin-bottom:12px;">
            <button id="tabsPrev" type="button" aria-label="Prev" style="flex:0 0 auto; background:#f5f5f5; border:1px solid #e0e0e0; color:#666; width:28px; height:28px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer;"></button>
            <div id="stickerTabs" style="display:flex; gap:8px; flex:1 1 auto; flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch; border-bottom:1px solid #f0f0f0; padding-bottom:8px; scrollbar-width:thin; scroll-snap-type:x mandatory;"></div>
            <button id="tabsNext" type="button" aria-label="Next" style="flex:0 0 auto; background:#f5f5f5; border:1px solid #e0e0e0; color:#666; width:28px; height:28px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer;"></button>
        </div>
        <div id="stickerGrid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(56px, 1fr)); gap:8px; padding:4px 0 0 0;"></div>
    </div>

    <!-- Custom Message Box -->
    <div id="messageBox"></div>

    <!-- Custom Confirmation Modal -->
    <div id="customConfirmModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="confirmModalMessage">Are you sure?</h3>
            <div class="modal-buttons">
                <button id="confirmNoBtn" class="cancel-btn">No</button>
                <button id="confirmYesBtn" class="confirm-btn">Yes</button>
            </div>
        </div>
    </div>

    <!-- Call Status Overlay -->
    <div id="callStatusOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2 id="callStatusTitle"></h2>
            <p id="callStatusMessage"></p>
            <div class="call-actions" id="callActions">
                <!-- Buttons dynamically added here -->
            </div>
        </div>
    </div>

    <!-- Video Call Interface -->
    <div id="videoCallContainer" class="video-call-container">
        <div class="video-grid">
            <div class="video-item" id="localVideoItem">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label">You</div>
                <div class="connection-status" id="localConnectionStatus"></div>
            </div>
            <div class="video-item" id="remoteVideoItem">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label" id="remoteVideoLabel">Partner</div>
                <div class="connection-status" id="remoteConnectionStatus"></div>
            </div>
        </div>
        <div class="call-timer" id="callTimer">00:00</div>
        <div class="call-quality-indicator" id="callQualityIndicator">
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
            <div class="quality-bar"></div>
        </div>
        <div class="video-controls">
            <button id="muteVideoBtn" title="Mute Audio">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="toggleVideoBtn" title="Toggle Video">
                <i class="fas fa-video"></i>
            </button>
            <button id="switchCameraBtn" title="Switch Camera">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button id="fullscreenBtn" title="Fullscreen">
                <i class="fas fa-expand"></i>
            </button>
            <button id="endVideoCallBtn" class="end-call" title="End Call">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>

    <!-- Voice Call Interface -->
    <div id="voiceCallContainer" class="voice-call-container">
        <div class="voice-call-avatar" id="voiceCallAvatar">
            <i class="fas fa-user-circle"></i>
        </div>
        <div class="voice-call-info">
            <h2 id="voiceCallPartnerName">Partner Name</h2>
            <p id="voiceCallStatus">Connecting...</p>
        </div>
        <div class="voice-controls">
            <button id="muteVoiceBtn" title="Mute">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="speakerBtn" title="Speaker">
                <i class="fas fa-volume-up"></i>
            </button>
            <button id="endVoiceCallBtn" class="end-call" title="End Call">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>



    <!-- Select Friend Modal -->
    <div id="selectFriendModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Select a Friend to Chat With</h3>
            <input type="text" id="friendSearchInput" placeholder="Search friends..." class="search-input">
            <div id="friendListContainer" class="friend-list-modal">
                <p class="loading-friends-modal">Loading friends...</p>
                <p class="no-friends-modal" style="display: none;">No friends found.</p>
            </div>
            <div class="modal-buttons">
                <button id="closeFriendModalBtn" class="cancel-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Find Friends Modal -->
    <div id="findFriendsModal" class="modal-overlay">
        <div class="modal-content find-friends-modal">
            <div class="modal-header">
                <h3>Find Friends</h3>
                <button class="close-modal-btn" onclick="closeFindFriendsModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="search-container">
                <i class="fas fa-search search-icon"></i>
                <input type="text" id="userSearchInput" placeholder="Search users by username...">
            </div>
            <div class="user-list" id="userList">
                <p class="loading-users-message" id="loadingUsersMessage">Loading users...</p>
                <p class="no-users-message" id="noUsersFoundMessage" style="display: none;">No users found.</p>
            </div>
        </div>
    </div>

    <!-- Unlock Feature Modal -->
    <div id="unlockModal" class="modal-overlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7); align-items:center; justify-content:center; z-index:1000;">
        <div class="modal-content" style="background: var(--card-background); border:1px solid var(--border-light); border-radius:16px; padding:16px; width:90%; max-width:460px;">
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                <h3 id="unlockTitle" style="margin:0; color:var(--white); font-family:Poppins, sans-serif;">Unlock</h3>
                <button id="unlockCloseBtn" style="background:transparent;border:none;color:var(--white);cursor:pointer"><i class="fas fa-times"></i></button>
            </div>
            <div style="color:var(--text-light); font-size:0.95rem; line-height:1.5;">
                <p id="unlockDescription" style="margin-top:0"></p>
                <div style="margin:10px 0; padding:10px; border:1px dashed var(--border-light); border-radius:10px;">
                    <div style="margin-bottom:6px; color:var(--text-light)">Step 1: Make a bank transfer using the details below. Use your Order ID as reference.</div>
                    <div><strong>Order ID:</strong> <span id="orderIdText"></span> <button id="copyOrderIdBtn" style="margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 4px 8px; cursor: pointer;"><i class="fas fa-copy"></i></button></div>
                    <div style="margin-top:6px"><strong>Amount:</strong> <span id="orderAmountText"></span></div>
                    <div style="margin-top:10px; display:grid; gap:10px;">
                        <div style="padding:8px; border:1px solid var(--border-light); border-radius:10px;">
                            <div style="display:flex;align-items:center;gap:8px;"><i class="fas fa-university" style="font-size:16px;color:#ffd700;"></i><span><strong>Bank:</strong> OPay</span></div>
                            <div><strong>Account Name:</strong> ELECHI JOSHUA</div>
                            <div><strong>Account Number:</strong> <span id="opayAcct">8111609765</span> <button id="copyOpayBtn" style="margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 3px 8px; cursor: pointer;">Copy</button></div>
                        </div>
                        <div style="padding:8px; border:1px solid var(--border-light); border-radius:10px;">
                            <div style="display:flex;align-items:center;gap:8px;"><i class="fas fa-university" style="font-size:16px;color:#ffd700;"></i><span><strong>Bank:</strong> Keystone Bank</span></div>
                            <div><strong>Account Name:</strong> ELECHI OSOUNDU JOSHUA</div>
                            <div><strong>Account Number:</strong> <span id="keystoneAcct">6042862356</span> <button id="copyKeystoneBtn" style="margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 3px 8px; cursor: pointer;">Copy</button></div>
                        </div>
                    </div>
                </div>
                <div style="display:flex; flex-direction:column; gap:8px; margin-top:10px;">
                    <label for="unlockReceiptInput" style="font-weight:600; color:var(--white)">Step 2: I've paid  upload receipt (image or PDF)</label>
                    <input id="unlockReceiptInput" type="file" accept="image/*,.pdf" />
                </div>
                <div id="unlockError" style="color:#ff6b6b; margin-top:8px; display:none"></div>
            </div>
            <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:14px;">
                <button id="unlockCancelBtn" class="modal-button cancel-button">Cancel</button>
                <button id="unlockSubmitBtn" class="modal-button save-button"><span class="button-text">Submit Receipt</span><div class="button-loader" style="margin-left:8px"></div></button>
            </div>
        </div>
    </div>



    <!-- Feature Unlock Full Panel -->
    <div id="unlockStore" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.85); backdrop-filter: blur(6px); z-index:1200;">
        <div class="unlock-card neon-glow" style="background:var(--card-background); border:1px solid var(--border-light); overflow:hidden;">
            <div class="unlock-header" style="display:flex; align-items:center; justify-content:space-between; padding:12px 16px;">
                <div style="display:flex; align-items:center; gap:10px;">
                    <i class="fas fa-gem" style="color:#ffd700;"></i>
                    <h3 style="margin:0; color:var(--white); font-family:Poppins, sans-serif;">Unlock Features</h3>
                </div>
                <button id="unlockStoreClose" style="background:transparent;border:1px solid var(--border-light);color:var(--white);border-radius:8px;padding:6px 10px;cursor:pointer;"><i class="fas fa-times"></i></button>
            </div>
            <div class="unlock-body">
                <div class="unlock-side">
                    <div class="unlock-features-grid">
                        <div class="management-card" data-feature="stickers">
                            <h4><i class="fas fa-face-smile"></i> Stickers Pack</h4>
                            <p>Express with static + animated stickers.</p>
                            <p><strong>1,500</strong></p>
                            <button class="admin-button choose-feature" data-feature="stickers"><span class="button-text">Select</span><div class="button-loader"></div></button>
                        </div>
                        <div class="management-card" data-feature="reactions">
                            <h4><i class="fas fa-bolt"></i> Reactions Pack</h4>
                            <p>Fire, 100, wow, sad, clap, and more.</p>
                            <p><strong>1,200</strong></p>
                            <button class="admin-button choose-feature" data-feature="reactions"><span class="button-text">Select</span><div class="button-loader"></div></button>
                        </div>
                        <div class="management-card" data-feature="effects">
                            <h4><i class="fas fa-wand-magic-sparkles"></i> Message Effects</h4>
                            <p>Send messages with special animations.</p>
                            <p><strong>1,000</strong></p>
                            <button class="admin-button choose-feature" data-feature="effects"><span class="button-text">Select</span><div class="button-loader"></div></button>
                        </div>
                        <div class="management-card" data-feature="quickReplies">
                            <h4><i class="fas fa-reply"></i> Quick Replies</h4>
                            <p>One-tap replies for speed.</p>
                            <p><strong>800</strong></p>
                            <button class="admin-button choose-feature" data-feature="quickReplies"><span class="button-text">Select</span><div class="button-loader"></div></button>
                        </div>
                        <div class="management-card" data-feature="mediaPro">
                            <h4><i class="fas fa-microphone"></i> Media Pro</h4>
                            <p>Longer voice notes + HD media.</p>
                            <p><strong>2,000</strong></p>
                            <button class="admin-button choose-feature" data-feature="mediaPro"><span class="button-text">Select</span><div class="button-loader"></div></button>
                        </div>
                    </div>
                </div>
                <div class="unlock-right">
                    <div id="featurePreview" class="feature-preview" style="display:none;">
                        <h4 id="featurePreviewTitle"></h4>
                        <p id="featurePreviewDesc"></p>
                    </div>
                    <div id="storeSelection" style="margin-bottom:12px; color:var(--text-light)">Select a feature to see amount and Order ID</div>
                    <div class="section-title">Selected Feature & Amount</div>
                    <div class="info-card">
                        <div><strong>Order ID:</strong> <span id="storeOrderId"></span> <button id="storeCopyOrder" style="margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 4px 8px; cursor: pointer;"><i class="fas fa-copy"></i></button></div>
                        <div style="margin-top:8px"><span class="price-chip"><i class="fas fa-tag"></i> <span id="storeAmount"></span></span></div>
                    </div>
                    <div class="section-title">Bank Accounts</div>
                    <div style="display:grid; gap:10px;">
                        <div style="padding:8px; border:1px solid var(--border-light); border-radius:10px;">
                            <div style="display:flex;align-items:center;gap:8px;"><i class="fas fa-university" style="font-size:16px;color:#ffd700;"></i><span><strong>Bank:</strong> OPay</span></div>
                            <div><strong>Account Name:</strong> ELECHI JOSHUA</div>
                            <div><strong>Account Number:</strong> <span id="storeOpay">8111609765</span> <button id="storeCopyOpay" style="margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 3px 8px; cursor: pointer;">Copy</button></div>
                        </div>
                        <div style="padding:8px; border:1px solid var(--border-light); border-radius:10px;">
                            <div style="display:flex;align-items:center;gap:8px;"><i class="fas fa-university" style="font-size:16px;color:#ffd700;"></i><span><strong>Bank:</strong> Keystone Bank</span></div>
                            <div><strong>Account Name:</strong> ELECHI OSOUNDU JOSHUA</div>
                            <div><strong>Account Number:</strong> <span id="storeKeystone">6042862356</span> <button id="storeCopyKeystone" style="margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 3px 8px; cursor: pointer;">Copy</button></div>
                        </div>
                    </div>
                    <div class="section-title">Payment Steps</div>
                    <div style="display:flex; flex-direction:column; gap:10px; padding:10px; border:1px solid var(--border-light); border-radius:12px; background: rgba(255,255,255,0.03);">
                        <div class="step"><div class="num">1</div><div><strong>Transfer</strong> the amount above to any of the bank accounts.</div></div>
                        <div class="step"><div class="num">2</div><div><strong>Use the Order ID</strong> as your transfer reference/memo.</div></div>
                        <div class="step"><div class="num">3</div><div><strong>Upload the receipt</strong> and submit for approval.</div></div>
                    </div>
                    <div class="section-title">Payment Receipt Upload</div>
                    <div class="upload-card">
                        <div id="storeReceiptDrop" class="dropzone">
                            <div>
                                <i class="fas fa-file-upload" style="color:#ffd700"></i>
                                <span>Click to choose or drop a file here</span>
                            </div>
                            <span id="storeReceiptName" class="file-name">No file chosen</span>
                        </div>
                        <input id="storeReceipt" type="file" accept="image/*,.pdf" style="display:none;" />
                        <img id="storeReceiptPreview" class="receipt-preview" alt="Receipt Preview" />
                    </div>
                    <div id="storeError" style="color:#ff6b6b; margin-top:8px; display:none"></div>
                    <div style="display:flex;gap:8px;margin-top:12px;">
                        <button id="storeSubmit" class="admin-button"><span class="button-text">Submit Receipt</span><div class="button-loader"></div></button>
                        <button id="storeCancel" class="admin-button secondary"><span class="button-text">Cancel</span><div class="button-loader"></div></button>
                    </div>
                    <div class="section-title">Send Receipt to Admin</div>
                    <div class="upload-card">
                        <div id="adminReceiptDrop" class="dropzone">
                            <div>
                                <i class="fas fa-paper-plane" style="color:#ffd700"></i>
                                <span>Click to choose or drop a file to send to Admin</span>
                            </div>
                            <span id="adminReceiptName" class="file-name">No file chosen</span>
                        </div>
                        <input id="adminReceipt" type="file" accept="image/*,.pdf" style="display:none;" />
                        <img id="adminReceiptPreview" class="receipt-preview" alt="Admin Receipt Preview" />
                        <div id="adminReceiptError" style="color:#ff6b6b; margin-top:8px; display:none"></div>
                        <div style="display:flex;gap:8px;margin-top:10px;">
                            <button id="adminReceiptSubmit" class="admin-button"><span class="button-text">Send to Admin</span><div class="button-loader"></div></button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Emoji picker -->
    <div id="emojiPicker">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:6px;">
            <span style="font-weight:700; color:var(--white)">Emoji</span>
            <button id="emojiPickerClose" style="background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 4px 8px; cursor: pointer;"><i class="fas fa-times"></i></button>
        </div>
        <div id="emojiGrid"></div>
    </div>
    <!-- Reaction bar -->
    <div id="reactionBar"></div>
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, getDocs, addDoc, serverTimestamp, orderBy, limit, updateDoc, deleteDoc, where, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

        // --- Firebase & Canvas Environment Configuration ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
            authDomain: "jchat-1.firebaseapp.com",
            projectId: "jchat-1",
            storageBucket: "jchat-1.firebasestorage.app",
            messagingSenderId: "328479683167",
            appId: "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
            measurementId: "G-S6Z9GG0R9P"
        };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Cloudinary Configuration (Note: Cloudinary is for direct uploads, Firebase Storage is also available)
        // For simplicity and consistency with previous files, I'll use Cloudinary for media uploads if the user's setup implies it.
        // If Firebase Storage is preferred, the upload functions would need to be adapted.
        const cloudinaryConfig = {
            cloudName: "dxld01rcp", // Your Cloudinary Cloud Name
            uploadPreset: "Storage_preset" // Your Cloudinary Upload Preset
        };

        // Initialize Firebase services
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app); // Initialize Firebase Storage

        // --- DOM Elements ---
        const headerProfilePic = document.getElementById('headerProfilePic');
        const headerAvatarIcon = document.getElementById('headerAvatarIcon');
        const headerDisplayName = document.getElementById('headerDisplayName');
        const notificationCountElement = document.getElementById('notificationCount');
        const messageBox = document.getElementById('messageBox');
        const adminIconLink = document.getElementById('adminIconLink');
        const profileLink = document.getElementById('profileLink');
        const soundToggleIcon = document.getElementById('soundToggleIcon');

        const partnerProfilePic = document.getElementById('partnerProfilePic');
        const partnerAvatarIcon = document.getElementById('partnerAvatarIcon');
        const partnerDisplayName = document.getElementById('partnerDisplayName');
        const messagesDisplay = document.getElementById('messagesDisplay');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const loadingMessages = document.getElementById('loadingMessages');
        const noMessages = document.getElementById('noMessages');

        // Wire send button and Enter key
        if (sendMessageBtn) {
            sendMessageBtn.addEventListener('click', () => sendMessage('text', messageInput.value));
        }
        if (messageInput) {
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage('text', messageInput.value);
                }
            });
        }

        // New elements for media/voice/calls
        const mediaInput = document.getElementById('mediaInput');
        const mediaShareBtn = document.getElementById('mediaShareBtn');
        const voiceNoteBtn = document.getElementById('voiceNoteBtn');
        const voiceNoteTimer = voiceNoteBtn.querySelector('.recording-timer'); // Get the timer span
        const voiceCallBtn = document.getElementById('voiceCallBtn');
        const videoCallBtn = document.getElementById('videoCallBtn');
        const callStatusOverlay = document.getElementById('callStatusOverlay');
        const callStatusTitle = document.getElementById('callStatusTitle');
        const callStatusMessage = document.getElementById('callStatusMessage');
        const callActions = document.getElementById('callActions');

        // Custom Confirmation Modal elements
        const customConfirmModal = document.getElementById('customConfirmModal');
        const confirmModalMessage = document.getElementById('confirmModalMessage');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');

        // Select Friend Modal elements
        const selectFriendBtn = document.getElementById('selectFriendBtn');
        const selectFriendBadge = document.getElementById('selectFriendBadge'); // New badge element
        const selectFriendModal = document.getElementById('selectFriendModal');
        const closeFriendModalBtn = document.getElementById('closeFriendModalBtn');
        const friendSearchInput = document.getElementById('friendSearchInput');
        const friendListContainer = document.getElementById('friendListContainer');
        const loadingFriendsModal = friendListContainer.querySelector('.loading-friends-modal');
        const noFriendsModal = friendListContainer.querySelector('.no-friends-modal');

        // --- Global State ---
        let isAuthReady = false; // Flag to indicate if auth state has been checked
        let currentUser = null; // The currently authenticated user (Firebase Auth object)
        let currentUserProfileData = null; // Store the current user's profile data
        let partnerId = null; // The ID of the chat partner
        let partnerProfileData = null; // Store the chat partner's profile data
        let unsubscribeMessages = null; // To store unsubscribe function for messages
        let unsubscribeCallStatus = null; // To store unsubscribe for call status
        let notificationSoundEnabled = true; // State for sound toggle

        // Voice Note Recording State
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime;
        let recordingInterval;

        // New global variables for managing unread counts and their listeners
        let unreadMessageCountsByFriendId = {}; // Stores {friendId: count}
        let totalUnreadMessages = 0;
        let unsubscribeAllFriendUnreadListeners = []; // Array to store unsubscribe functions for all nested listeners

        // --- Tone.js Synths for Notification Sounds ---
        const successSynth = new Tone.Synth().toDestination();
        const errorSynth = new Tone.Synth().toDestination();
        const infoSynth = new Tone.Synth().toDestination();
        const incomingCallSynth = new Tone.MembraneSynth().toDestination(); // For incoming calls

        // Set up basic sounds
        successSynth.oscillator.type = "sine";
        successSynth.envelope.attack = 0.01;
        successSynth.envelope.decay = 0.2;
        successSynth.envelope.sustain = 0.0;
        successSynth.envelope.release = 0.5;

        errorSynth.oscillator.type = "sawtooth";
        errorSynth.envelope.attack = 0.01;
        errorSynth.envelope.decay = 0.3;
        errorSynth.envelope.sustain = 0.0;
        errorSynth.envelope.release = 0.5;

        infoSynth.oscillator.type = "triangle";
        infoSynth.envelope.attack = 0.01;
        infoSynth.envelope.decay = 0.1;
        infoSynth.envelope.sustain = 0.0;
        infoSynth.envelope.release = 0.3;

        incomingCallSynth.envelope.attack = 0.001;
        incomingCallSynth.envelope.decay = 0.4;
        incomingCallSynth.envelope.sustain = 0.01;
        incomingCallSynth.envelope.release = 0.8;

        /**
         * Plays notification sounds using ne.mp3 or Tone.js fallback
         * @param {string} type - 'success', 'error', 'info', 'warning', 'friend_request', 'message', 'level_up', 'incoming_call'.
         */
        function playNotificationSound(type) {
            if (!notificationSoundEnabled) return;

            try {
                // Try to play ne.mp3 first
                const audio = new Audio('ne.mp3');
                audio.volume = 0.6;
                audio.play().catch(() => {
                    // Fallback to Tone.js if ne.mp3 fails
                    console.log("JCHAT_DEBUG: Using Tone.js fallback for notification sound");
                    
                    Tone.start(); // Ensure audio context is started
                    if (type === 'success') {
                        successSynth.triggerAttackRelease("C5", "8n");
                    } else if (type === 'error') {
                        errorSynth.triggerAttackRelease("C3", "8n");
                    } else if (type === 'info') {
                        infoSynth.triggerAttackRelease("E4", "16n");
                    } else if (type === 'warning') {
                        errorSynth.triggerAttackRelease("A3", "4n");
                    } else if (type === 'friend_request') {
                        infoSynth.triggerAttackRelease("D5", "8n");
                    } else if (type === 'message') {
                        infoSynth.triggerAttackRelease("E4", "8n");
                    } else if (type === 'level_up') {
                        successSynth.triggerAttackRelease("C6", "4n");
                    } else if (type === 'incoming_call') {
                        incomingCallSynth.triggerAttackRelease("C4", "2n");
                        incomingCallSynth.triggerAttackRelease("G4", "2n", "+0.5");
                    }
                });
            } catch (error) {
                console.error("JCHAT_ERROR: Error playing notification sound:", error);
            }
        }

        /**
         * Displays a temporary message box with a given message and type.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('success', 'error', 'info', 'loading', 'warning').
         * @param {boolean} [isPersistent=false] - If true, message stays until explicitly cleared or replaced.
         * @param {number} [durationMs=3000] - Duration in milliseconds for the message to display if not persistent.
         */
        function showMessageBox(message, type, isPersistent = false, durationMs = 3000) {
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }

            messageBox.innerHTML = `<i id="messageBoxIcon"></i><span id="messageBoxText"></span>`;
            const messageBoxIcon = document.getElementById('messageBoxIcon');
            const messageBoxText = document.getElementById('messageBoxText');

            messageBoxText.textContent = message;
            messageBox.className = 'message-box show ' + type; // Add type class for styling

            // Set icon based on type
            if (type === 'success') {
                messageBoxIcon.classList.add('fas', 'fa-check-circle');
            } else if (type === 'error') {
                messageBoxIcon.classList.add('fas', 'fa-times-circle');
            } else if (type === 'info') {
                messageBoxIcon.classList.add('fas', 'fa-info-circle');
            } else if (type === 'warning') {
                messageBoxIcon.classList.add('fas', 'fa-exclamation-triangle');
            } else if (type === 'loading') {
                 messageBoxIcon.classList.add('fas', 'fa-spinner', 'fa-spin'); // Spinner for loading
            } else {
                messageBoxIcon.className = ''; // No specific icon
            }

            if (type === 'loading') {
                messageBox.classList.add('loading-pulse');
            } else {
                messageBox.classList.remove('loading-pulse');
            }

            messageBox.style.display = 'flex';
            messageBox.style.opacity = '1';

            if (!isPersistent) {
                messageBox.timeoutId = setTimeout(() => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', function handler() {
                        messageBox.style.display = 'none';
                        messageBox.removeEventListener('transitionend', handler);
                        messageBox.classList.remove('loading-pulse');
                    }, { once: true });
                }, durationMs);
            }
        }

        /**
         * Toggles loading state for a button.
         * @param {HTMLElement} buttonElement - The button to toggle.
         * @param {boolean} isLoading - True to show loading, false to hide.
         */
        function toggleButtonLoading(buttonElement, isLoading) {
            if (!buttonElement) return;
            // Find the loader and text elements within the button
            const loader = buttonElement.querySelector('.button-loader');
            const text = buttonElement.querySelector('.button-text');

            if (isLoading) {
                buttonElement.disabled = true;
                buttonElement.classList.add('loading');
                if (loader) loader.classList.add('active');
                if (text) text.style.display = 'none';
            } else {
                buttonElement.disabled = false;
                buttonElement.classList.remove('loading');
                if (loader) loader.classList.remove('active');
                if (text) text.style.display = 'block';
            }
        }

        /**
         * Displays a custom confirmation modal.
         * @param {string} message - The message to display in the modal.
         * @returns {Promise<boolean>} Resolves with true if 'Yes' is clicked, false if 'No'.
         */
        function showCustomConfirm(message) {
            return new Promise((resolve) => {
                if (!customConfirmModal || !confirmModalMessage || !confirmYesBtn || !confirmNoBtn) {
                    console.error("JCHAT_ERROR: Custom confirmation modal elements not found.");
                    resolve(false); // Fallback to false if elements are missing
                    return;
                }

                confirmModalMessage.textContent = message;
                customConfirmModal.classList.add('active');

                const handleYes = () => {
                    customConfirmModal.classList.remove('active');
                    confirmYesBtn.removeEventListener('click', handleYes);
                    confirmNoBtn.removeEventListener('click', handleNo);
                    resolve(true);
                };

                const handleNo = () => {
                    customConfirmModal.classList.remove('active');
                    confirmYesBtn.removeEventListener('click', handleYes);
                    confirmNoBtn.removeEventListener('click', handleNo);
                    resolve(false);
                };

                confirmYesBtn.addEventListener('click', handleYes);
                confirmNoBtn.addEventListener('click', handleNo);
            });
        }

        /**
         * Converts seconds to a formatted time string (MM:SS).
         * @param {number} totalSeconds - The total number of seconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Constructs a Cloudinary URL for an image/video.
         * @param {string} urlOrPublicId - The full Cloudinary URL or the public ID of the image on Cloudinary.
         * @param {string} transformations - Optional Cloudinary transformations.
         * @returns {string|null} The full Cloudinary URL or null if urlOrPublicId is not provided.
         */
        function getCloudinaryImageUrl(urlOrPublicId, transformations = "w_auto,f_auto,q_auto") {
            if (!urlOrPublicId) return null;
            if (urlOrPublicId.startsWith('http://') || urlOrPublicId.startsWith('https://')) {
                if (urlOrPublicId.includes('res.cloudinary.com')) {
                    const parts = urlOrPublicId.split('/upload/');
                    if (parts.length === 2) {
                        return `${parts[0]}/upload/${transformations}/${parts[1]}`;
                    }
                }
                return urlOrPublicId;
            }
            return `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/image/upload/${transformations}/${urlOrPublicId}`;
        }

        /**
         * Displays the profile picture or a default icon.
         * @param {HTMLElement} imgElement - The <img> element to update.
         * @param {HTMLElement} iconElement - The <i> or <div> element to display if no image.
         * @param {string|null} profilePicId - The Cloudinary public ID or URL, or null.
         * @param {string} usernameInitial - Initial for placeholder.
         * @param {string} transformations - Cloudinary transformations.
         */
        function displayProfilePicture(imgElement, iconElement, profilePicId, usernameInitial, transformations) {
            if (imgElement && iconElement) {
                if (profilePicId) {
                    const imageUrl = getCloudinaryImageUrl(profilePicId, transformations);
                    imgElement.src = imageUrl;
                    imgElement.style.display = 'block';
                    iconElement.style.display = 'none';
                    imgElement.onerror = () => {
                        console.error(`JCHAT_ERROR: Failed to load profile picture: ${profilePicId}. Using placeholder.`);
                        imgElement.src = `https://placehold.co/40x40/CCCCCC/000000?text=${usernameInitial}`;
                        imgElement.style.display = 'block';
                        iconElement.style.display = 'none';
                    };
                } else {
                    imgElement.src = '';
                    imgElement.style.display = 'none';
                    iconElement.style.display = 'block';
                }
            }
        }

        /**
         * Fetches and displays the current user's profile data for the header.
         * This function runs on every page to ensure header is consistent.
         * @param {firebase.User} user - The authenticated Firebase user object.
         */
        async function fetchAndDisplayHeaderProfile(user) {
            console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile called for user:", user.uid);
            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", user.uid, "profiles", "user_profile");
                const privateDocSnap = await getDoc(privateProfileDocRef);

                let profileData = null;
                if (privateDocSnap.exists()) {
                    profileData = privateDocSnap.data();
                    console.log("JCHAT_DEBUG: Fetched existing profile data for header:", profileData);
                } else {
                    // If private profile doesn't exist, create a basic one
                    console.warn("JCHAT_WARN: Private profile not found for header, creating a new one.");
                    profileData = {
                        username: user.displayName || `User_${user.uid.substring(0, 8)}`,
                        email: user.email || "",
                        profilePicId: user.photoURL || null,
                        bio: "",
                        location: "",
                        friendsCount: 0,
                        followersCount: 0,
                        followingCount: 0,
                        createdAt: new Date(),
                        updatedAt: new Date(),
                        inspirationType: "motivational",
                        visibility: {
                            displayName: true, profilePic: true, bio: false, location: false,
                            emailPublic: false, lastOnline: false, allowFriendRequests: true, allowMessages: true,
                        },
                        totalPosts: 0,
                        jCoins: 0,
                        gas: 0,
                        level: 1,
                        currentXp: 0,
                        xpToNextLevel: 500,
                        walletUnlocked: false,
                        lastLoginBonusClaimed: null,
                        isAdmin: false
                    };
                    await setDoc(privateProfileDocRef, profileData);

                    // Also create/update public profile
                    const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);
                    await setDoc(publicProfileDocRef, {
                        username: profileData.username,
                        profilePicId: profileData.profilePicId,
                        bio: profileData.bio,
                        location: profileData.location,
                        createdAt: profileData.createdAt,
                        updatedAt: profileData.updatedAt,
                        visibility: profileData.visibility,
                        totalPosts: profileData.totalPosts
                    }, { merge: true });
                }

                currentUserProfileData = profileData;
                console.log("JCHAT_DEBUG: currentUserProfileData set:", currentUserProfileData);

                // Update header UI
                const usernameInitial = (profileData.username || "J").charAt(0).toUpperCase();
                displayProfilePicture(headerProfilePic, headerAvatarIcon, profileData?.profilePicId, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                headerDisplayName.textContent = profileData.username || "JCHAT User";

                // Safely set href for profileLink if it exists
                if (profileLink) {
                    profileLink.href = `Profile.html?userId=${user.uid}`;
                }

                // Show Admin Icon only if the current user is the ADMIN_UID
                const ADMIN_UID = 'cc96gdhCRPO72NFZtleRCujHvIq2';
                if (adminIconLink) {
                    if (user.uid === ADMIN_UID) {
                        adminIconLink.style.display = 'block';
                    } else {
                        adminIconLink.style.display = 'none';
                    }
                }

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching or creating profile for header:", error);
                const usernameInitial = (user.displayName || "J").charAt(0).toUpperCase();
                displayProfilePicture(headerProfilePic, headerAvatarIcon, user.photoURL, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                headerDisplayName.textContent = user.displayName || "JCHAT User";
                showMessageBox(`Error loading header profile: ${error.message}`, 'error');
            }
        }

        /**
         * Fetches and displays the notification count for the current user.
         * @param {string} userId - The UID of the current user.
         */
        async function fetchNotificationCount(userId) {
            try {
                const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                const q = query(notificationsCollectionRef, orderBy("timestamp", "desc")); // Order by timestamp
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const unreadCount = snapshot.docs.filter(doc => !doc.data().read).length;

                    if (notificationCountElement) {
                        if (unreadCount > 0) {
                            notificationCountElement.textContent = unreadCount;
                            notificationCountElement.style.display = 'flex';
                        } else {
                            notificationCountElement.style.display = 'none';
                        }
                    }
                });
                // Return the unsubscribe function to be called on page unload
                return unsubscribe;
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching notification count:", error);
                if (notificationCountElement) notificationCountElement.style.display = 'none';
                return () => {}; // Return a no-op function if an error occurs
            }
        }

        /**
         * Gets the chat room ID for two users.
         * Ensures the ID is always the same regardless of the order of UIDs.
         * @param {string} uid1
         * @param {string} uid2
         * @returns {string} The combined chat room ID.
         */
        function getChatRoomId(uid1, uid2) {
            return uid1 < uid2 ? `${uid1}_${uid2}` : `${uid2}_${uid1}`;
        }

        /**
         * Fetches and displays the chat partner's profile data.
         * @param {string} pId - The UID of the chat partner.
         */
        async function fetchPartnerProfile(pId) {
            if (!pId) {
                partnerDisplayName.textContent = "No Partner Selected";
                partnerProfilePic.style.display = 'none';
                partnerAvatarIcon.style.display = 'block';
                return;
            }

            try {
                const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", pId);
                const publicDocSnap = await getDoc(publicProfileDocRef);

                if (publicDocSnap.exists()) {
                    partnerProfileData = publicDocSnap.data();
                    const username = partnerProfileData.username || `User_${pId.substring(0, 8)}`;
                    const usernameInitial = username.charAt(0).toUpperCase();

                    partnerDisplayName.textContent = partnerProfileData.visibility?.displayName !== false ? username : 'Anonymous User';
                    displayProfilePicture(partnerProfilePic, partnerAvatarIcon, partnerProfileData?.profilePicId, usernameInitial, "w_90,h_90,c_fill,g_face,r_max");
                } else {
                    partnerDisplayName.textContent = "Unknown User";
                    partnerProfilePic.style.display = 'none';
                    partnerAvatarIcon.style.display = 'block';
                    showMessageBox("Chat partner profile not found.", 'warning');
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching partner profile:", error);
                partnerDisplayName.textContent = "Error Loading";
                partnerProfilePic.style.display = 'none';
                partnerAvatarIcon.style.display = 'block';
                showMessageBox(`Error loading partner profile: ${error.message}`, 'error');
            }
        }
        /**
         * Renders a single message bubble.
         * @param {Object} message - The message data.
         * @param {string} currentUserId - The UID of the current logged-in user.
         * @returns {HTMLElement} The message bubble element.
         */
        function createMessageBubble(message, currentUserId) {
            const messageBubble = document.createElement('div');
            messageBubble.classList.add('message-bubble');
            messageBubble.setAttribute('data-message-id', message.id); // Store message ID
            messageBubble.dataset.reactions = JSON.stringify(message.reactions || {});

            const isSentByCurrentUser = message.senderId === currentUserId;
            messageBubble.classList.add(isSentByCurrentUser ? 'sent' : 'received');

            const timestamp = message.timestamp?.toDate ? message.timestamp.toDate() : new Date(message.timestamp);
            const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            let contentHtml = '';
            // Backward-compat: normalize legacy messages without `type`
            if (!message.type) {
                if (message.mediaUrl || message.mediaType) {
                    const mt = (message.mediaType || '').toLowerCase();
                    if (mt.includes('video')) message.type = 'video';
                    else if (mt.includes('audio')) message.type = 'audio';
                    else message.type = 'image';
                } else if (typeof message.content === 'string') {
                    message.type = 'text';
                    message.text = message.content;
                }
            }
            if (message.type === 'text') {
                // XSS-safe text rendering
                const wrapper = document.createElement('div');
                wrapper.className = 'message-content';
                const textNode = document.createTextNode(message.text || message.content || '');
                wrapper.appendChild(textNode);
                if (message.edited) {
                    const edited = document.createElement('span');
                    edited.style.fontSize = '0.7em';
                    edited.style.opacity = '0.7';
                    edited.textContent = ' (edited)';
                    wrapper.appendChild(edited);
                }
                contentHtml = wrapper.outerHTML;
            } else if (message.type === 'image') {
                const imageUrl = getCloudinaryImageUrl(message.mediaUrl, "w_400,h_auto,c_limit");
                contentHtml = `<div class="message-content"><img src="${imageUrl}" alt="Image" onerror="this.onerror=null;this.src='https://placehold.co/200x150?text=Image+Error';"></div>`;
            } else if (message.type === 'video') {
                const videoUrl = getCloudinaryImageUrl(message.mediaUrl, "w_400,h_auto,c_limit");
                contentHtml = `<div class="message-content"><video controls src="${videoUrl}" onerror="this.onerror=null;this.src=''; console.error('Video load error');"></video></div>`;
            } else if (message.type === 'audio') {
                // Custom Audio Player Preview
                contentHtml = `
                    <div class="message-content">
                        <div class="audio-player-wrapper">
                            <button class="play-pause-btn"><i class="fas fa-play"></i></button>
                            <div class="progress-container">
                                <input type="range" class="progress-bar" value="0" min="0" max="100" step="0.1">
                                <span class="time-display">00:00 / 00:00</span>
                            </div>
                            <audio src="${message.mediaUrl || message.audioUrl || ''}" preload="none"></audio>
                        </div>
                        <div class="audio-buttons">
                            <button class="audio-forward-btn" data-audio-url="${message.mediaUrl || message.audioUrl || ''}" title="Forward Audio"><i class="fas fa-share"></i></button>
                            <button class="audio-download-btn" data-audio-url="${message.mediaUrl || message.audioUrl || ''}" data-filename="voice_note_${message.id}.webm" title="Download Audio"><i class="fas fa-download"></i></button>
                        </div>
                    </div>
                `;
            } else if (message.type === 'call_status') {
                messageBubble.classList.add('call-status-message'); // Add a specific class for styling call status
                contentHtml = `<div class="message-content" style="text-align: center; font-style: italic; color: var(--text-light); background: none; box-shadow: none; border: none;">${message.text}</div>`;
            } else {
                contentHtml = `<div class="message-content">Unsupported message type.</div>`;
            }

            messageBubble.innerHTML = contentHtml;

            // Add a small timestamp below the message bubble, unless it's a call status message
            if (message.type !== 'call_status') {
                const messageInfo = document.createElement('div');
                messageInfo.classList.add('message-info');
                messageInfo.textContent = timeString;
                messageBubble.appendChild(messageInfo);

                // Reactions row
                const reactionsRow = document.createElement('div');
                reactionsRow.className = 'reactions-row';
                updateReactionsRow(reactionsRow, message);
                messageBubble.appendChild(reactionsRow);
            }

            // Add message options (edit/delete) if sent by current user and not a call status message
            if (isSentByCurrentUser && message.type !== 'call_status') {
                const optionsBtn = document.createElement('button');
                optionsBtn.classList.add('message-options-btn');
                optionsBtn.innerHTML = '<i class="fas fa-ellipsis-h"></i>';
                messageBubble.appendChild(optionsBtn);

                const optionsMenu = document.createElement('div');
                optionsMenu.classList.add('message-options-menu');
                optionsMenu.innerHTML = `
                    <button class="edit-message-btn" ${message.type !== 'text' ? 'disabled' : ''}><i class="fas fa-edit"></i> Edit</button>
                    <button class="delete-message-btn"><i class="fas fa-trash-alt"></i> Delete</button>
                `;
                messageBubble.appendChild(optionsMenu);

                // Toggle options menu visibility
                optionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent bubble from closing immediately
                    optionsMenu.classList.toggle('active');
                });

                // Close options menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!optionsMenu.contains(e.target) && optionsMenu.classList.contains('active')) {
                        optionsMenu.classList.remove('active');
                    }
                });

                // Event listener for Edit button
                const editBtn = optionsMenu.querySelector('.edit-message-btn');
                if (editBtn) {
                    editBtn.addEventListener('click', () => {
                        optionsMenu.classList.remove('active'); // Close menu
                        editMessage(message.id, message.text, messageBubble, message.edited); // Pass original edited status
                    });
                }

                // Event listener for Delete button
                const deleteBtn = optionsMenu.querySelector('.delete-message-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', () => {
                        optionsMenu.classList.remove('active'); // Close menu
                        deleteMessage(message.id);
                    });
                }
            }

            // Add event listeners for custom audio player and buttons
            if (message.type === 'audio') {
                const audio = messageBubble.querySelector('audio');
                const playPauseBtn = messageBubble.querySelector('.play-pause-btn');
                const progressBar = messageBubble.querySelector('.progress-bar');
                const timeDisplay = messageBubble.querySelector('.time-display');
                const forwardBtn = messageBubble.querySelector('.audio-forward-btn');
                const downloadBtn = messageBubble.querySelector('.audio-download-btn');

                // Set initial volume
                audio.volume = 0.8;

                // Update time and progress bar
                audio.addEventListener('timeupdate', () => {
                    const progress = (audio.currentTime / audio.duration) * 100;
                    progressBar.value = progress;
                    progressBar.style.setProperty('--progress', `${progress}%`);
                    timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
                });

                // Update duration when metadata is loaded
                audio.addEventListener('loadedmetadata', () => {
                    if (!isNaN(audio.duration)) { // Ensure duration is a valid number
                        timeDisplay.textContent = `00:00 / ${formatTime(audio.duration)}`;
                        progressBar.max = audio.duration; // Set max for progress bar to actual duration
                    } else {
                        timeDisplay.textContent = `00:00 / --:--`;
                    }
                    progressBar.value = 0;
                    progressBar.style.setProperty('--progress', `0%`);
                });

                // Toggle play/pause
                playPauseBtn.addEventListener('click', () => {
                    if (audio.paused) {
                        audio.play();
                        playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        audio.pause();
                        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });

                // Reset button when audio ends
                audio.addEventListener('ended', () => {
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    audio.currentTime = 0; // Reset to start
                    progressBar.value = 0;
                    progressBar.style.setProperty('--progress', `0%`);
                    if (!isNaN(audio.duration)) {
                        timeDisplay.textContent = `00:00 / ${formatTime(audio.duration)}`;
                    } else {
                        timeDisplay.textContent = `00:00 / --:--`;
                    }
                });

                // Seek functionality
                progressBar.addEventListener('input', () => {
                    if (!isNaN(audio.duration) && audio.duration > 0) {
                        const seekTime = (progressBar.value / 100) * audio.duration; // Use 100 as max for range input
                        audio.currentTime = seekTime;
                    }
                });
                progressBar.addEventListener('change', () => { // For when user releases the thumb
                    if (!isNaN(audio.duration) && audio.duration > 0) {
                        const seekTime = (progressBar.value / 100) * audio.duration;
                        audio.currentTime = seekTime;
                    }
                });


                // Forward button
                if (forwardBtn) {
                    forwardBtn.addEventListener('click', () => {
                        const audioUrl = forwardBtn.getAttribute('data-audio-url');
                        copyToClipboard(audioUrl, "Audio URL copied for forwarding!");
                    });
                }

                // Download button
                if (downloadBtn) {
                    downloadBtn.addEventListener('click', () => {
                        const audioUrl = downloadBtn.getAttribute('data-audio-url');
                        const filename = downloadBtn.getAttribute('data-filename');
                        downloadFile(audioUrl, filename);
                    });
                }
            }

            return messageBubble;
        }

        /**
         * Copies text to the clipboard.
         * @param {string} text - The text to copy.
         * @param {string} successMessage - Message to show on success.
         */
        function copyToClipboard(text, successMessage = "Copied to clipboard!") {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showMessageBox(successMessage, 'success');
            } catch (err) {
                console.error('JCHAT_ERROR: Failed to copy text: ', err);
                showMessageBox('Failed to copy. Please try manually.', 'error');
            }
            document.body.removeChild(textarea);
        }

        /**
         * Downloads a file from a given URL.
         * @param {string} url - The URL of the file to download.
         * @param {string} filename - The desired filename for the downloaded file.
         */
        function downloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a); // Required for Firefox
            a.click();
            document.body.removeChild(a);
            showMessageBox(`Downloading ${filename}...`, 'info');
        }

        // Render inline reactions row below a message
        function updateReactionsRow(container, message) {
            if (!container) return;
            const counts = message?.reactions || {};
            container.innerHTML = '';
            Object.keys(counts).forEach(key => {
                if (!counts[key]) return;
                const pill = document.createElement('span');
                pill.className = 'reaction-pill';
                pill.innerHTML = `${key} <span>${counts[key]}</span>`;
                container.appendChild(pill);
            });
            container.style.display = container.children.length ? 'flex' : 'none';
        }

        // --- Unlock Preview + Entitlements (global, before any use) ---
        const UNLOCK_ALL_PREVIEW = false;
        let userEntitlements = {
            stickersUnlocked: false,
            reactionsUnlocked: false,
            effectsUnlocked: false,
            quickRepliesUnlocked: false,
            mediaTier: 'basic',
            packs: []
        };
        function isUnlocked(feature) {
            if (UNLOCK_ALL_PREVIEW) return true;
            switch (feature) {
                case 'stickers': return !!(userEntitlements.stickersUnlocked || (userEntitlements.packs || []).some(p => p.startsWith('stickers:')));
                case 'reactions': return !!(userEntitlements.reactionsUnlocked || (userEntitlements.packs || []).some(p => p.startsWith('reactions:')));
                case 'effects': return !!userEntitlements.effectsUnlocked;
                case 'quickReplies': return !!userEntitlements.quickRepliesUnlocked;
                case 'mediaPro': return userEntitlements.mediaTier === 'pro';
                default: return false;
            }
        }
        function setGatedUI() {
            const stickersBtn = document.getElementById('stickersBtn');
            if (stickersBtn) {
                // Always allow opening the stickers panel. Packs themselves will be partially locked (first 3 free)
                const badge = stickersBtn.querySelector('.lock-badge');
                if (badge) badge.style.display = 'none';
                stickersBtn.dataset.locked = '0';
                stickersBtn.style.opacity = '1';
            }
        }
        /**
         * Fetches and displays messages for the current chat.
         */
        async function fetchAndDisplayMessages() {
            if (!currentUser || !partnerId) {
                console.log("JCHAT_DEBUG: Cannot fetch messages: current user or partner ID missing.");
                // Ensure loading/no messages states are correctly handled
                if (loadingMessages) loadingMessages.style.display = 'none';
                if (noMessages) {
                    noMessages.style.display = 'block';
                    noMessages.textContent = "No chat partner selected. Please select a friend to start chatting.";
                }
                messagesDisplay.innerHTML = ''; // Clear existing messages
                return;
            }

            // Friendship gate: allow if either side has a friend doc (one-sided ok)
            try {
                const youToThem = await getDoc(doc(db, "artifacts", appId, "users", currentUser.uid, "friends", partnerId));
                const themToYou = await getDoc(doc(db, "artifacts", appId, "users", partnerId, "friends", currentUser.uid));
                const allowMessaging = UNLOCK_ALL_PREVIEW || youToThem.exists() || themToYou.exists();
                if (!allowMessaging) {
                    if (messageInput) messageInput.disabled = true;
                    if (sendMessageBtn) sendMessageBtn.disabled = true;
                    if (noMessages) {
                        noMessages.style.display = 'block';
                        noMessages.textContent = "You are not friends yet. Use Find Friends to send a request.";
                    }
                } else {
                    if (messageInput) messageInput.disabled = false;
                    if (sendMessageBtn) sendMessageBtn.disabled = false;
                    if (noMessages) noMessages.style.display = 'none';
                }
            } catch (e) {
                console.warn('JCHAT_WARN: Friendship check failed:', e?.message || e);
                if (UNLOCK_ALL_PREVIEW) {
                    if (messageInput) messageInput.disabled = false;
                    if (sendMessageBtn) sendMessageBtn.disabled = false;
                }
            }

            console.log("JCHAT_DEBUG: Fetching messages for chat between", currentUser.uid, "and", partnerId);
            // Ensure loading message is visible initially
            if (loadingMessages) loadingMessages.style.display = 'block';
            if (noMessages) noMessages.style.display = 'none';


            // Unsubscribe previous listener
            if (unsubscribeMessages) unsubscribeMessages();

            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");
            const q = query(messagesCollectionRef, orderBy("timestamp")); // Order by timestamp ascending

            unsubscribeMessages = onSnapshot(q, (snapshot) => {
                // Hide initial loading message once data starts coming
                if (loadingMessages) loadingMessages.style.display = 'none';

                if (snapshot.empty) {
                    if (noMessages) noMessages.style.display = 'block';
                } else {
                    if (noMessages) noMessages.style.display = 'none';

                    snapshot.docChanges().forEach(change => {
                        const messageData = { id: change.doc.id, ...change.doc.data() };
                        const existingBubble = messagesDisplay.querySelector(`[data-message-id="${messageData.id}"]`);

                        if (change.type === "added") {
                            if (!existingBubble) { // Only add if it doesn't already exist
                                messagesDisplay.appendChild(createMessageBubble(messageData, currentUser.uid));
                            }
                        } else if (change.type === "modified") {
                            if (existingBubble) {
                                const updatedBubble = createMessageBubble(messageData, currentUser.uid);
                                messagesDisplay.replaceChild(updatedBubble, existingBubble);
                            }
                        } else if (change.type === "removed") {
                            if (existingBubble) {
                                messagesDisplay.removeChild(existingBubble);
                            }
                        }
                    });
                    // Scroll to the bottom after new messages are loaded
                    messagesDisplay.scrollTop = messagesDisplay.scrollHeight;

                    // After messages are loaded, mark them as read for the current user
                    // Only update if there are messages and the latest message is from the partner
                    const latestMessage = snapshot.docs[snapshot.docs.length - 1];
                    if (latestMessage && latestMessage.data().senderId !== currentUser.uid) {
                        const latestMessageTimestamp = latestMessage.data().timestamp;
                        const chatMetadataDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "chat_metadata", partnerId);
                        // Use setDoc with merge:true to create/update the document
                        setDoc(chatMetadataDocRef, { lastReadMessageTimestamp: latestMessageTimestamp }, { merge: true })
                            .then(() => console.log("JCHAT_DEBUG: Chat metadata updated with last read timestamp."))
                            .catch(error => console.error("JCHAT_ERROR: Error updating chat metadata:", error));
                    }
                }
            }, (error) => {
                console.error("JCHAT_ERROR: Error fetching messages:", error);
                showMessageBox(`Error loading messages: ${error.message}`, 'error');
                playNotificationSound('error');
                if (loadingMessages) loadingMessages.style.display = 'none';
                if (noMessages) {
                    noMessages.style.display = 'block';
                    noMessages.textContent = "Failed to load messages. Please try again.";
                }
            });
        }

        /**
         * Sends a message to the chat partner.
         * @param {string} type - 'text', 'image', 'video', 'audio', 'call_status'.
         * @param {string} content - The message text or URL for media.
         */
        async function sendMessage(type, content) {
            if (!currentUser || !partnerId || !currentUserProfileData) {
                showMessageBox("You must be logged in and have a chat partner selected to send messages.", 'error');
                return;
            }

            // Prevent sending if not friends (one-sided friendship allowed)
            try {
                const youToThem = await getDoc(doc(db, "artifacts", appId, "users", currentUser.uid, "friends", partnerId));
                const themToYou = await getDoc(doc(db, "artifacts", appId, "users", partnerId, "friends", currentUser.uid));
                const allow = UNLOCK_ALL_PREVIEW || youToThem.exists() || themToYou.exists();
                if (!allow) {
                    showMessageBox("You are not connected yet. Use Find Friends to send a request.", 'info');
                    return;
                }
            } catch (e) {
                console.warn('JCHAT_WARN: Friendship re-check failed on send:', e?.message || e);
                if (!UNLOCK_ALL_PREVIEW) return;
            }

            if (type === 'text' && !content.trim()) {
                showMessageBox("Message cannot be empty.", 'warning');
                return;
            }
            if ((type === 'image' || type === 'video' || type === 'audio') && !content) {
                showMessageBox("Media content is missing.", 'warning');
                return;
            }

            // Show loading state for all message types
            toggleButtonLoading(sendMessageBtn, true);

            try {
                const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");

                const messageData = {
                    senderId: currentUser.uid,
                    receiverId: partnerId,
                    type: type,
                    timestamp: serverTimestamp(),
                    senderUsername: currentUserProfileData.username,
                    receiverUsername: partnerProfileData?.username || 'Unknown User'
                };

                if (type === 'text') {
                    messageData.text = content;
                } else if (type === 'image' || type === 'video' || type === 'audio') {
                    messageData.mediaUrl = content;
                } else if (type === 'call_status') {
                    messageData.text = content; // Call status messages use 'text' field
                }

                await addDoc(messagesCollectionRef, messageData);

                if (type === 'text') {
                    messageInput.value = ''; // Clear input field
                    messageInput.style.height = 'auto'; // Reset textarea height
                }

                // Send notification to the receiver for new messages (not call status)
                if (type !== 'call_status') {
                    const notificationRef = collection(db, "artifacts", appId, "users", partnerId, "notifications");
                    await addDoc(notificationRef, {
                        type: 'new_message',
                        message: `New ${type} from ${currentUserProfileData.username}!`,
                        senderId: currentUser.uid,
                        recipientId: partnerId,
                        timestamp: serverTimestamp(),
                        read: false,
                        senderUsername: currentUserProfileData.username // Include sender username for pop-up
                    });
                }

            } catch (error) {
                console.error("JCHAT_ERROR: Error sending message:", error);
                showMessageBox(`Failed to send message: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(sendMessageBtn, false);
            }
        }

        /**
         * Edits an existing message.
         * @param {string} messageId - The ID of the message to edit.
         * @param {string} currentText - The current text of the message.
         * @param {HTMLElement} messageBubbleElement - The DOM element of the message bubble.
         * @param {boolean} wasEdited - The original edited status of the message.
         */
        async function editMessage(messageId, currentText, messageBubbleElement, wasEdited) {
            if (!currentUser || !partnerId) {
                showMessageBox("Authentication error. Cannot edit message.", 'error');
                return;
            }

            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const messageDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages", messageId);

            // Hide options button and menu during editing
            const optionsBtn = messageBubbleElement.querySelector('.message-options-btn');
            const optionsMenu = messageBubbleElement.querySelector('.message-options-menu');
            if (optionsBtn) optionsBtn.style.display = 'none';
            if (optionsMenu) optionsMenu.classList.remove('active');

            // Replace message content with a textarea for editing
            const messageContentDiv = messageBubbleElement.querySelector('.message-content');
            if (!messageContentDiv) return;

            messageBubbleElement.classList.add('editing'); // Add editing class for styling
            messageContentDiv.innerHTML = `
                <textarea class="edit-message-textarea">${currentText}</textarea>
                <div class="edit-actions">
                    <button class="cancel-btn">Cancel</button>
                    <button class="save-btn">Save</button>
                </div>
            `;

            const textarea = messageContentDiv.querySelector('.edit-message-textarea');
            const saveBtn = messageContentDiv.querySelector('.save-btn');
            const cancelBtn = messageContentDiv.querySelector('.cancel-btn');

            // Auto-resize textarea
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
            textarea.focus();

            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            });

            saveBtn.addEventListener('click', async () => {
                const newText = textarea.value.trim();
                if (newText === currentText || newText === '') {
                    showMessageBox("No changes or empty message. Edit cancelled.", 'info');
                    // Revert without saving, preserving original edited status
                    messageBubbleElement.classList.remove('editing');
                    messageContentDiv.innerHTML = `${currentText}${wasEdited ? ' <span style="font-size: 0.7em; opacity: 0.7;">(edited)</span>' : ''}`;
                    if (optionsBtn) optionsBtn.style.display = 'block';
                    return;
                }

                toggleButtonLoading(saveBtn, true);
                showMessageBox("Saving changes...", 'loading', true);

                try {
                    await updateDoc(messageDocRef, {
                        text: newText,
                        edited: true,
                        timestamp: serverTimestamp() // Update timestamp to reflect edit time
                    });
                    showMessageBox("Message updated!", 'success');
                    playNotificationSound('success');
                } catch (error) {
                    console.error("JCHAT_ERROR: Error updating message:", error);
                    showMessageBox(`Failed to update message: ${error.message}`, 'error');
                    playNotificationSound('error');
                } finally {
                    toggleButtonLoading(saveBtn, false);
                    messageBubbleElement.classList.remove('editing');
                    // The onSnapshot listener will re-render the message with the updated content
                    if (optionsBtn) optionsBtn.style.display = 'block';
                }
            });

            cancelBtn.addEventListener('click', () => {
                messageBubbleElement.classList.remove('editing');
                messageContentDiv.innerHTML = `${currentText}${wasEdited ? ' <span style="font-size: 0.7em; opacity: 0.7;">(edited)</span>' : ''}`;
                showMessageBox("Message edit cancelled.", 'info');
                if (optionsBtn) optionsBtn.style.display = 'block';
            });
        }

        /**
         * Deletes a message.
         * @param {string} messageId - The ID of the message to delete.
         */
        async function deleteMessage(messageId) {
            if (!currentUser || !partnerId) {
                showMessageBox("Authentication error. Cannot delete message.", 'error');
                return;
            }

            const confirmed = await showCustomConfirm("Are you sure you want to delete this message? This action cannot be undone.");
            if (!confirmed) return;

            showMessageBox("Deleting message...", 'loading', true);
            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const messageDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages", messageId);

            try {
                await deleteDoc(messageDocRef);
                showMessageBox("Message deleted!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting message:", error);
                showMessageBox(`Failed to delete message: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }
        /**
         * Uploads a file to Cloudinary.
         * @param {File} file - The file to upload.
         * @returns {Promise<string>} Resolves with the Cloudinary URL.
         */
        async function uploadFileToCloudinary(file) {
            showMessageBox("Uploading media...", 'loading', true);
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', cloudinaryConfig.uploadPreset);

            try {
                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/auto/upload`, {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                if (data.secure_url) {
                    showMessageBox("Upload complete!", 'success');
                    return data.secure_url;
                } else {
                    throw new Error(data.error?.message || "Cloudinary upload failed.");
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Cloudinary upload error:", error);
                showMessageBox(`Upload failed: ${error.message}`, 'error');
                playNotificationSound('error');
                throw error;
            }
        }

        /**
         * Handles media file selection and upload.
         */
        async function handleMediaShare() {
            mediaInput.click(); // Trigger file input click
        }

        mediaInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const fileType = file.type.split('/')[0]; // 'image' or 'video'

            if (fileType !== 'image' && fileType !== 'video') {
                showMessageBox("Only image and video files are supported.", 'warning');
                return;
            }

            try {
                const mediaUrl = await uploadFileToCloudinary(file);
                await sendMessage(fileType, mediaUrl);
            } catch (error) {
                console.error("JCHAT_ERROR: Error sending media message:", error);
                // Message box already handled in uploadFileToCloudinary
            } finally {
                mediaInput.value = ''; // Clear file input
            }
        });
        /**
         * Starts recording a voice note.
         */
        async function startRecordingVoiceNote() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const audioFile = new File([audioBlob], `voice_note_${Date.now()}.webm`, { type: 'audio/webm' });

                    // Stop the timer and reset UI immediately after recording stops
                    clearInterval(recordingInterval);
                    voiceNoteTimer.style.display = 'none';
                    voiceNoteBtn.classList.remove('recording');
                    voiceNoteBtn.querySelector('.button-text').textContent = 'Voice Note';
                    voiceNoteBtn.disabled = true; // Disable until upload is complete

                    showMessageBox("Uploading voice note...", 'loading', true); // Show loading for upload
                    try {
                        const audioUrl = await uploadFileToCloudinary(audioFile);
                        await sendMessage('audio', audioUrl);
                    } catch (error) {
                        console.error("JCHAT_ERROR: Error sending voice note:", error);
                    } finally {
                        stream.getTracks().forEach(track => track.stop()); // Stop microphone
                        isRecording = false;
                        voiceNoteBtn.disabled = false; // Re-enable button
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                voiceNoteBtn.classList.add('recording');
                voiceNoteBtn.querySelector('.button-text').textContent = 'Stop Recording';
                voiceNoteTimer.textContent = '00:00';
                voiceNoteTimer.style.display = 'inline';

                // Update timer every second
                recordingInterval = setInterval(() => {
                    const elapsedTime = Math.floor((Date.now() - recordingStartTime) / 1000);
                    voiceNoteTimer.textContent = formatTime(elapsedTime);
                }, 1000);

                showMessageBox("Recording voice note...", 'info', true);
            } catch (error) {
                console.error("JCHAT_ERROR: Error accessing microphone:", error);
                showMessageBox(`Failed to access microphone: ${error.message}. Please grant permission.`, 'error');
                playNotificationSound('error');
                voiceNoteBtn.disabled = false;
            }
        }

        /**
         * Stops recording a voice note.
         */
        function stopRecordingVoiceNote() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                // UI updates for stopping are now handled in mediaRecorder.onstop
            }
        }

        voiceNoteBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecordingVoiceNote();
            } else {
                startRecordingVoiceNote();
            }
        });

        // --- WebRTC Call Functionality ---
        // Comprehensive voice and video call implementation using WebRTC

        // WebRTC Configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        // WebRTC State Management
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let isInitiator = false;
        let isCallActive = false;
        let callType = null;
        let callStartTime = null;
        let callTimer = null;
        let isMuted = false;
        let isVideoEnabled = true;
        let isSpeakerOn = false;
        let currentCamera = 'front';
        let availableCameras = [];



        // Find Friends System State Management
        let allUsersData = [];
        let currentUsersFriends = new Set();
        let sentRequests = new Set();
        let receivedRequests = new Set();
        let unsubscribeUsers = null;
        let unsubscribeFriendStatus = null;

        // DOM Elements for calls
        const videoCallContainer = document.getElementById('videoCallContainer');
        const voiceCallContainer = document.getElementById('voiceCallContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callTimerElement = document.getElementById('callTimer');
        const voiceCallPartnerName = document.getElementById('voiceCallPartnerName');
        const voiceCallStatus = document.getElementById('voiceCallStatus');
        const voiceCallAvatar = document.getElementById('voiceCallAvatar');
        const remoteVideoLabel = document.getElementById('remoteVideoLabel');

        // Call control buttons
        const muteVideoBtn = document.getElementById('muteVideoBtn');
        const toggleVideoBtn = document.getElementById('toggleVideoBtn');
        const switchCameraBtn = document.getElementById('switchCameraBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const endVideoCallBtn = document.getElementById('endVideoCallBtn');
        const muteVoiceBtn = document.getElementById('muteVoiceBtn');
        const speakerBtn = document.getElementById('speakerBtn');
        const endVoiceCallBtn = document.getElementById('endVoiceCallBtn');



        // Find Friends DOM Elements
        const findFriendsModal = document.getElementById('findFriendsModal');
        const findFriendsBtn = document.getElementById('findFriendsBtn');
        const userSearchInput = document.getElementById('userSearchInput');
        const userList = document.getElementById('userList');
        const loadingUsersMessage = document.getElementById('loadingUsersMessage');
        const noUsersFoundMessage = document.getElementById('noUsersFoundMessage');

        // --- Notification Badge Functions ---
        /**
         * Create a new notification (for badge display only)
         * @param {string} type - Type of notification (success, error, info, warning, friend_request, message, level_up)
         * @param {string} title - Notification title
         * @param {string} message - Notification message
         * @param {string} icon - Custom icon (optional)
         * @param {boolean} persistent - Whether to persist in notification center
         */
        function createNotification(type, title, message, icon = null, persistent = true) {
            // For now, just play notification sound
            if (notificationSoundEnabled) {
                playNotificationSound(type);
            }

            console.log("JCHAT_DEBUG: Notification created:", { type, title, message });
        }

        /**
         * Update notification badge count
         */
        function updateNotificationBadge(count = 0) {
            const badge = document.getElementById('notificationCount');
            const iconWrapper = document.querySelector('.notification-icon-wrapper');

            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : count;
                badge.style.display = 'flex';
                iconWrapper.classList.add('has-notifications');
            } else {
                badge.style.display = 'none';
                iconWrapper.classList.remove('has-notifications');
            }
        }

        // --- Find Friends System Functions ---
        /**
         * Initialize Find Friends functionality
         */
        function initializeFindFriends() {
            // Add event listeners
            if (findFriendsBtn) {
                findFriendsBtn.addEventListener('click', openFindFriendsModal);
            }
            if (userSearchInput) {
                userSearchInput.addEventListener('input', (e) => {
                    renderUserList(allUsersData, e.target.value);
                });
            }
        }

        /**
         * Open Find Friends modal
         */
        function openFindFriendsModal() {
            if (!currentUser) {
                showMessageBox("Please log in to find friends.", 'warning');
                return;
            }
            findFriendsModal.classList.add('active');
            loadAllUsers();
        }

        /**
         * Close Find Friends modal
         */
        function closeFindFriendsModal() {
            findFriendsModal.classList.remove('active');
            if (userSearchInput) {
                userSearchInput.value = '';
            }
            if (unsubscribeUsers) {
                unsubscribeUsers();
                unsubscribeUsers = null;
            }
            if (unsubscribeFriendStatus) {
                unsubscribeFriendStatus();
                unsubscribeFriendStatus = null;
            }
        }

        /**
         * Load all users for the Find Friends feature
         */
        async function loadAllUsers() {
            if (!currentUser) return;

            try {
                loadingUsersMessage.style.display = 'block';
                noUsersFoundMessage.style.display = 'none';

                // Get all public user profiles
                const publicUsersRef = collection(db, "artifacts", appId, "public", "data", "users");
                const usersSnapshot = await getDocs(publicUsersRef);
                
                const users = [];
                usersSnapshot.forEach(doc => {
                    if (doc.id !== currentUser.uid) {
                        users.push({
                            uid: doc.id,
                            ...doc.data()
                        });
                    }
                });

                allUsersData = users;
                await loadFriendStatuses();
                renderUserList(users, '');

            } catch (error) {
                console.error("JCHAT_ERROR: Error loading users:", error);
                showMessageBox("Failed to load users: " + error.message, 'error');
            } finally {
                loadingUsersMessage.style.display = 'none';
            }
        }

        /**
         * Load friend statuses for all users
         */
        async function loadFriendStatuses() {
            if (!currentUser) return;

            try {
                // Reset sets
                currentUsersFriends.clear();
                sentRequests.clear();
                receivedRequests.clear();

                // Get current user's friends
                const friendsRef = collection(db, "artifacts", appId, "users", currentUser.uid, "friends");
                const friendsSnapshot = await getDocs(friendsRef);
                friendsSnapshot.forEach(doc => {
                    currentUsersFriends.add(doc.id);
                });

                // Get sent friend requests
                const sentRequestsRef = collection(db, "artifacts", appId, "users", currentUser.uid, "friend_requests", "sent");
                const sentRequestsSnapshot = await getDocs(sentRequestsRef);
                sentRequestsSnapshot.forEach(doc => {
                    sentRequests.add(doc.id);
                });

                // Get received friend requests
                const receivedRequestsRef = collection(db, "artifacts", appId, "users", currentUser.uid, "friend_requests", "received");
                const receivedRequestsSnapshot = await getDocs(receivedRequestsRef);
                receivedRequestsSnapshot.forEach(doc => {
                    receivedRequests.add(doc.id);
                });

            } catch (error) {
                console.error("JCHAT_ERROR: Error loading friend statuses:", error);
            }
        }

        /**
         * Render user list with search filtering
         */
        function renderUserList(usersToRender, searchQuery) {
            if (!userList) return;

            userList.innerHTML = '';
            loadingUsersMessage.style.display = 'none';

            let filteredUsers = usersToRender;

            if (searchQuery) {
                const lowerCaseQuery = searchQuery.toLowerCase();
                filteredUsers = usersToRender.filter(user =>
                    (user.username && user.username.toLowerCase().includes(lowerCaseQuery))
                );
            }

            if (filteredUsers.length === 0) {
                noUsersFoundMessage.style.display = 'block';
                return;
            }

            noUsersFoundMessage.style.display = 'none';

            filteredUsers.forEach(user => {
                const userCard = createUserCard(user);
                userList.appendChild(userCard);
            });
        }

        /**
         * Create user card element
         */
        function createUserCard(userData) {
            const card = document.createElement('div');
            card.className = 'user-card';
            card.setAttribute('data-user-id', userData.uid);

            const userId = userData.uid;
            const username = userData.username || 'Anonymous User';
            const isFriend = currentUsersFriends.has(userId);
            const hasSentRequest = sentRequests.has(userId);
            const hasReceivedRequest = receivedRequests.has(userId);

            // Profile image
            let profileImageHtml = '';
            if (userData.profilePicId) {
                profileImageHtml = `<img src="${userData.profilePicId}" alt="${username}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">`;
            }
            profileImageHtml += `<div class="default-avatar" style="display: ${userData.profilePicId ? 'none' : 'flex'}"><i class="fas fa-user"></i></div>`;

            // Action buttons
            let actionButtonsHtml = '';
            if (isFriend) {
                actionButtonsHtml = `
                    <button class="action-btn chat-btn" onclick="startChatWithUser('${userId}')">
                        <span class="button-text"><i class="fas fa-comment"></i> Chat</span>
                        <div class="button-loader"></div>
                    </button>
                    <button class="action-btn unfriend-btn" onclick="unfriendUser('${userId}', this)">
                        <span class="button-text"><i class="fas fa-user-minus"></i> Unfriend</span>
                        <div class="button-loader"></div>
                    </button>
                `;
            } else if (hasSentRequest) {
                actionButtonsHtml = `
                    <button class="action-btn cancel-request-btn" onclick="cancelFriendRequest('${userId}', this)">
                        <span class="button-text"><i class="fas fa-times"></i> Cancel</span>
                        <div class="button-loader"></div>
                    </button>
                `;
            } else if (hasReceivedRequest) {
                actionButtonsHtml = `
                    <button class="action-btn accept-request-btn" onclick="acceptFriendRequest('${userId}', this)">
                        <span class="button-text"><i class="fas fa-check"></i> Accept</span>
                        <div class="button-loader"></div>
                    </button>
                    <button class="action-btn reject-request-btn" onclick="rejectFriendRequest('${userId}', this)">
                        <span class="button-text"><i class="fas fa-times"></i> Reject</span>
                        <div class="button-loader"></div>
                    </button>
                `;
            } else {
                actionButtonsHtml = `
                    <button class="action-btn add-friend-btn" onclick="sendFriendRequest('${userId}', this)">
                        <span class="button-text"><i class="fas fa-user-plus"></i> Add Friend</span>
                        <div class="button-loader"></div>
                    </button>
                `;
            }

            card.innerHTML = `
                ${profileImageHtml}
                <h3>${userData.visibility?.displayName !== false ? username : 'Anonymous User'}</h3>
                <div class="user-actions">
                    ${actionButtonsHtml}
                </div>
            `;

            return card;
        }
        /**
         * Send friend request
         */
        async function sendFriendRequest(userId, buttonElement) {
            if (!currentUser) return;

            try {
                toggleButtonLoading(buttonElement, true);

                const requestData = {
                    senderId: currentUser.uid,
                    receiverId: userId,
                    senderUsername: currentUserProfileData?.username || 'Unknown User',
                    receiverUsername: allUsersData.find(u => u.uid === userId)?.username || 'Unknown User',
                    status: 'pending',
                    timestamp: serverTimestamp()
                };

                // Add to sender's sent requests
                await addDoc(collection(db, "artifacts", appId, "users", currentUser.uid, "friend_requests", "sent"), {
                    ...requestData,
                    id: userId
                });

                // Add to receiver's received requests
                await addDoc(collection(db, "artifacts", appId, "users", userId, "friend_requests", "received"), {
                    ...requestData,
                    id: currentUser.uid
                });

                // Update local state
                sentRequests.add(userId);
                renderUserList(allUsersData, userSearchInput?.value || '');

                showMessageBox("Friend request sent!", 'success');
                createNotification('success', 'Friend Request Sent', `Friend request sent to ${requestData.receiverUsername}`, null, true);

            } catch (error) {
                console.error("JCHAT_ERROR: Error sending friend request:", error);
                showMessageBox("Failed to send friend request: " + error.message, 'error');
            } finally {
                toggleButtonLoading(buttonElement, false);
            }
        }

        /**
         * Cancel friend request
         */
        async function cancelFriendRequest(userId, buttonElement) {
            if (!currentUser) return;

            try {
                toggleButtonLoading(buttonElement, true);

                // Remove from sender's sent requests
                const sentRequestQuery = query(
                    collection(db, "artifacts", appId, "users", currentUser.uid, "friend_requests", "sent"),
                    where("receiverId", "==", userId)
                );
                const sentRequestSnapshot = await getDocs(sentRequestQuery);
                const batch = writeBatch(db);
                sentRequestSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });

                // Remove from receiver's received requests
                const receivedRequestQuery = query(
                    collection(db, "artifacts", appId, "users", userId, "friend_requests", "received"),
                    where("senderId", "==", currentUser.uid)
                );
                const receivedRequestSnapshot = await getDocs(receivedRequestQuery);
                receivedRequestSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });

                await batch.commit();

                // Update local state
                sentRequests.delete(userId);
                renderUserList(allUsersData, userSearchInput?.value || '');

                showMessageBox("Friend request cancelled!", 'info');
                createNotification('info', 'Friend Request Cancelled', 'Friend request has been cancelled', null, true);

            } catch (error) {
                console.error("JCHAT_ERROR: Error cancelling friend request:", error);
                showMessageBox("Failed to cancel friend request: " + error.message, 'error');
            } finally {
                toggleButtonLoading(buttonElement, false);
            }
        }

        /**
         * Accept friend request
         */
        async function acceptFriendRequest(userId, buttonElement) {
            if (!currentUser) return;

            try {
                toggleButtonLoading(buttonElement, true);

                const batch = writeBatch(db);

                // Add to both users' friends lists
                batch.set(doc(db, "artifacts", appId, "users", currentUser.uid, "friends", userId), {
                    friendId: userId,
                    addedAt: serverTimestamp()
                });

                batch.set(doc(db, "artifacts", appId, "users", userId, "friends", currentUser.uid), {
                    friendId: currentUser.uid,
                    addedAt: serverTimestamp()
                });

                // Remove the request from both users
                const receivedRequestQuery = query(
                    collection(db, "artifacts", appId, "users", currentUser.uid, "friend_requests", "received"),
                    where("senderId", "==", userId)
                );
                const receivedRequestSnapshot = await getDocs(receivedRequestQuery);
                receivedRequestSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });

                const sentRequestQuery = query(
                    collection(db, "artifacts", appId, "users", userId, "friend_requests", "sent"),
                    where("receiverId", "==", currentUser.uid)
                );
                const sentRequestSnapshot = await getDocs(sentRequestQuery);
                sentRequestSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });

                await batch.commit();

                // Update local state
                currentUsersFriends.add(userId);
                receivedRequests.delete(userId);
                renderUserList(allUsersData, userSearchInput?.value || '');

                showMessageBox("Friend request accepted!", 'success');
                createNotification('success', 'Friend Added', 'You are now friends!', null, true);

            } catch (error) {
                console.error("JCHAT_ERROR: Error accepting friend request:", error);
                showMessageBox("Failed to accept friend request: " + error.message, 'error');
            } finally {
                toggleButtonLoading(buttonElement, false);
            }
        }
        /**
         * Reject friend request
         */
        async function rejectFriendRequest(userId, buttonElement) {
            if (!currentUser) return;

            try {
                toggleButtonLoading(buttonElement, true);

                const batch = writeBatch(db);

                // Remove the request from both users
                const receivedRequestQuery = query(
                    collection(db, "artifacts", appId, "users", currentUser.uid, "friend_requests", "received"),
                    where("senderId", "==", userId)
                );
                const receivedRequestSnapshot = await getDocs(receivedRequestQuery);
                receivedRequestSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });

                const sentRequestQuery = query(
                    collection(db, "artifacts", appId, "users", userId, "friend_requests", "sent"),
                    where("receiverId", "==", currentUser.uid)
                );
                const sentRequestSnapshot = await getDocs(sentRequestQuery);
                sentRequestSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });

                await batch.commit();

                // Update local state
                receivedRequests.delete(userId);
                renderUserList(allUsersData, userSearchInput?.value || '');

                showMessageBox("Friend request rejected!", 'info');
                createNotification('info', 'Friend Request Rejected', 'Friend request has been rejected', null, true);

            } catch (error) {
                console.error("JCHAT_ERROR: Error rejecting friend request:", error);
                showMessageBox("Failed to reject friend request: " + error.message, 'error');
            } finally {
                toggleButtonLoading(buttonElement, false);
            }
        }

        /**
         * Unfriend user
         */
        async function unfriendUser(userId, buttonElement) {
            if (!currentUser) return;

            const confirmed = await showCustomConfirm(`Are you sure you want to unfriend this user?`);
            if (!confirmed) return;

            try {
                toggleButtonLoading(buttonElement, true);

                const batch = writeBatch(db);

                // Remove from both users' friends lists
                batch.delete(doc(db, "artifacts", appId, "users", currentUser.uid, "friends", userId));
                batch.delete(doc(db, "artifacts", appId, "users", userId, "friends", currentUser.uid));

                await batch.commit();

                // Update local state
                currentUsersFriends.delete(userId);
                renderUserList(allUsersData, userSearchInput?.value || '');

                showMessageBox("User unfriended!", 'info');
                createNotification('info', 'Friend Removed', 'User has been unfriended', null, true);

            } catch (error) {
                console.error("JCHAT_ERROR: Error unfriending user:", error);
                showMessageBox("Failed to unfriend user: " + error.message, 'error');
            } finally {
                toggleButtonLoading(buttonElement, false);
            }
        }

        /**
         * Start chat with user
         */
        function startChatWithUser(userId) {
            closeFindFriendsModal();
            window.location.href = `/chat.html?partnerId=${userId}`;
        }
        /**
         * Displays the call status overlay.
         * @param {string} title - The title for the overlay.
         * @param {string} message - The message to display.
         * @param {Array<Object>} buttons - Array of button objects {text, icon, className, onClick}.
         */
        function showCallStatusOverlay(title, message, buttons) {
            callStatusTitle.textContent = title;
            callStatusMessage.textContent = message;
            callActions.innerHTML = '';
            buttons.forEach(btn => {
                const buttonElement = document.createElement('button');
                buttonElement.className = btn.className;
                buttonElement.innerHTML = `<i class="${btn.icon}"></i>`;
                buttonElement.title = btn.text;
                buttonElement.addEventListener('click', btn.onClick);
                callActions.appendChild(buttonElement);
            });
            callStatusOverlay.classList.add('active');
        }

        /**
         * Hides the call status overlay.
         */
        function hideCallStatusOverlay() {
            callStatusOverlay.classList.remove('active');
            callStatusTitle.textContent = '';
            callStatusMessage.textContent = '';
            callActions.innerHTML = '';
        }

        /**
         * Initiates a voice or video call with WebRTC.
         * @param {string} callType - 'voice' or 'video'.
         */
        async function startCall(callKind) {
            if (!currentUser || !partnerId || !currentUserProfileData) {
                showMessageBox("You must be logged in and have a chat partner selected to start a call.", 'error');
                return;
            }
            if (!partnerProfileData) {
                showMessageBox("Partner profile not loaded. Please wait.", 'warning');
                return;
            }

            const confirmed = await showCustomConfirm(`Start a ${callKind} call with ${partnerProfileData.username}?`);
            if (!confirmed) return;

            try {
                // Initialize WebRTC
                await initializeWebRTC(callKind);
                isInitiator = true;
                callType = callKind;

                // Get user media
                await getUserMedia(callKind);

                // Create peer connection
                createPeerConnection();

                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Create and send offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Send call offer to partner
                await sendCallOffer(offer, callKind);

                // Create/Update call status doc as 'ringing' so receiver sees incoming call
                const chatRoomIdForCall = getChatRoomId(currentUser.uid, partnerId);
                const callDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomIdForCall, "call_status", "current_call");
                await setDoc(callDocRef, {
                    status: 'ringing',
                    callType: callKind,
                    callerId: currentUser.uid,
                    callerUsername: currentUserProfileData.username,
                    receiverId: partnerId,
                    receiverUsername: partnerProfileData?.username || 'Unknown User',
                    initiatedAt: serverTimestamp()
                });

                showCallStatusOverlay(
                    `Outgoing ${callKind} Call`,
                    `Calling ${partnerProfileData.username}...`,
                    [{ text: 'End Call', icon: 'fas fa-phone-slash', className: 'end-call-btn', onClick: () => endCall('caller_ended') }]
                );

                // Send notification to the receiver
                const notificationRef = collection(db, "artifacts", appId, "users", partnerId, "notifications");
                await addDoc(notificationRef, {
                    type: 'incoming_call',
                    message: `Incoming ${callKind} call from ${currentUserProfileData.username}!`,
                    senderId: currentUser.uid,
                    recipientId: partnerId,
                    timestamp: serverTimestamp(),
                    read: false,
                    callType: callKind,
                    chatRoomId: getChatRoomId(currentUser.uid, partnerId)
                });

                playNotificationSound('incoming_call');

            } catch (error) {
                console.error("JCHAT_ERROR: Error starting call:", error);
                showMessageBox(`Failed to start call: ${error.message}`, 'error');
                playNotificationSound('error');
                hideCallStatusOverlay();
                cleanupCall();
            }
        }

        /**
         * Initialize WebRTC for calls
         */
        async function initializeWebRTC(callType) {
            // Check if WebRTC is supported
            if (!navigator.mediaDevices || !window.RTCPeerConnection) {
                throw new Error('WebRTC is not supported in this browser');
            }

            // Check permissions
            if (callType === 'video') {
                const videoPermission = await navigator.permissions.query({ name: 'camera' });
                if (videoPermission.state === 'denied') {
                    throw new Error('Camera permission is required for video calls');
                }
            }

            const audioPermission = await navigator.permissions.query({ name: 'microphone' });
            if (audioPermission.state === 'denied') {
                throw new Error('Microphone permission is required for calls');
            }

            console.log("JCHAT_DEBUG: WebRTC initialized for", callType, "call");
        }

        /**
         * Get user media (camera/microphone)
         */
        async function getUserMedia(callType) {
            const constraints = {
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                },
                video: callType === 'video' ? {
                    width: { ideal: 1280, min: 640 },
                    height: { ideal: 720, min: 480 },
                    facingMode: currentCamera
                } : false
            };

            try {
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                if (callType === 'video') {
                    localVideo.srcObject = localStream;
                    await localVideo.play();
                }

                console.log("JCHAT_DEBUG: User media obtained successfully");
            } catch (error) {
                console.error("JCHAT_ERROR: Error getting user media:", error);
                throw new Error(`Failed to access ${callType === 'video' ? 'camera/microphone' : 'microphone'}: ${error.message}`);
            }
        }

        /**
         * Create peer connection
         */
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            // Handle incoming tracks
            peerConnection.ontrack = (event) => {
                console.log("JCHAT_DEBUG: Received remote track");
                remoteStream = event.streams[0];
                if (callType === 'video') {
                    remoteVideo.srcObject = remoteStream;
                    remoteVideo.play();
                }
            };

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendIceCandidate(event.candidate);
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log("JCHAT_DEBUG: Connection state:", peerConnection.connectionState);
                updateConnectionStatus(peerConnection.connectionState);
            };

            // Handle ICE connection state changes
            peerConnection.oniceconnectionstatechange = () => {
                console.log("JCHAT_DEBUG: ICE connection state:", peerConnection.iceConnectionState);
                updateCallQuality(peerConnection.iceConnectionState);
            };

            console.log("JCHAT_DEBUG: Peer connection created");
        }

        /**
         * Send call offer to partner
         */
        async function sendCallOffer(offer, callType) {
            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const signalingRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "signaling", "call_data");

            await setDoc(signalingRef, {
                type: 'offer',
                offer: offer,
                callType: callType,
                callerId: currentUser.uid,
                receiverId: partnerId,
                timestamp: serverTimestamp()
            });
        }

        /**
         * Send ICE candidate to partner
         */
        async function sendIceCandidate(candidate) {
            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const signalingRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "signaling", "call_data");

            await updateDoc(signalingRef, {
                iceCandidate: candidate,
                timestamp: serverTimestamp()
            });
        }

        /**
         * Ends the current call and cleans up WebRTC resources.
         * @param {string} reason - The reason for ending the call.
         */
        async function endCall(reason) {
            if (!currentUser || !partnerId) return;

            try {
                // Stop call timer
                if (callTimer) {
                    clearInterval(callTimer);
                    callTimer = null;
                }

                // Clean up WebRTC resources
                cleanupCall();

                // Hide call interfaces
                hideCallInterfaces();

                // Send call end signal to partner
                await sendCallEndSignal(reason);

                // Update call status in Firestore
                const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                const callDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "call_status", "current_call");
                await updateDoc(callDocRef, { status: reason, endedAt: serverTimestamp() });

                hideCallStatusOverlay();
                showMessageBox("Call ended.", 'info');

                // Send chat message about call end
                let messageText = '';
                if (reason === 'caller_ended') {
                    messageText = `${currentUserProfileData.username} ended the call.`;
                } else if (reason === 'receiver_ended') {
                    messageText = `${partnerProfileData.username} ended the call.`;
                } else if (reason === 'rejected') {
                    messageText = `${partnerProfileData.username} rejected the call.`;
                } else if (reason === 'no_answer') {
                    messageText = "Call unanswered.";
                } else {
                    messageText = "Call ended unexpectedly.";
                }
                await sendMessage('call_status', messageText);

            } catch (error) {
                console.error("JCHAT_ERROR: Error ending call:", error);
                showMessageBox(`Failed to end call: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Clean up WebRTC resources
         */
        function cleanupCall() {
            // Stop all tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Reset state
            isCallActive = false;
            isInitiator = false;
            callType = null;
            callStartTime = null;
            isMuted = false;
            isVideoEnabled = true;
            isSpeakerOn = false;

            console.log("JCHAT_DEBUG: WebRTC resources cleaned up");
        }

        /**
         * Hide call interfaces
         */
        function hideCallInterfaces() {
            videoCallContainer.classList.remove('active');
            voiceCallContainer.classList.remove('active');
        }

        /**
         * Send call end signal to partner
         */
        async function sendCallEndSignal(reason) {
            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const signalingRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "signaling", "call_data");

            await setDoc(signalingRef, {
                type: 'end_call',
                reason: reason,
                timestamp: serverTimestamp()
            });
        }

        /**
         * Accepts an incoming call and establishes WebRTC connection.
         * @param {string} callType - The type of call ('voice' or 'video').
         */
        async function acceptCall(callKind) {
            if (!currentUser || !partnerId) return;

            try {
                // Initialize WebRTC
                await initializeWebRTC(callKind);
                callType = callKind;

                // Get user media
                await getUserMedia(callKind);

                // Create peer connection
                createPeerConnection();

                // Add local stream to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Get the offer from signaling data
                const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
                const signalingRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "signaling", "call_data");
                const signalingDoc = await getDoc(signalingRef);
                
                if (signalingDoc.exists() && signalingDoc.data().type === 'offer') {
                    const offer = signalingDoc.data().offer;
                    await peerConnection.setRemoteDescription(offer);

                    // Create and send answer
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    // Send answer to caller
                    await sendCallAnswer(answer);

                    // Start the call
                    startActiveCall(callKind);

                    // Update call status
                    const callDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "call_status", "current_call");
                    await updateDoc(callDocRef, { 
                        status: 'accepted', 
                        acceptedBy: currentUser.uid, 
                        startedAt: serverTimestamp() 
                    });

                    playNotificationSound('success');
                    await sendMessage('call_status', `${currentUserProfileData.username} accepted the ${callKind} call.`);
                }

            } catch (error) {
                console.error("JCHAT_ERROR: Error accepting call:", error);
                showMessageBox(`Failed to accept call: ${error.message}`, 'error');
                playNotificationSound('error');
                cleanupCall();
            }
        }

        /**
         * Send call answer to partner
         */
        async function sendCallAnswer(answer) {
            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const signalingRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "signaling", "call_data");

            await updateDoc(signalingRef, {
                type: 'answer',
                answer: answer,
                timestamp: serverTimestamp()
            });
        }

        /**
         * Start active call interface
         */
        function startActiveCall(callType) {
            isCallActive = true;
            callStartTime = Date.now();
            
            // Start call timer
            callTimer = setInterval(updateCallTimer, 1000);

            // Show appropriate call interface
            if (callType === 'video') {
                videoCallContainer.classList.add('active');
                remoteVideoLabel.textContent = partnerProfileData.username;
            } else {
                voiceCallContainer.classList.add('active');
                voiceCallPartnerName.textContent = partnerProfileData.username;
                voiceCallStatus.textContent = 'Connected';
                
                // Set partner avatar
                if (partnerProfileData.profilePicId) {
                    voiceCallAvatar.innerHTML = `<img src="${partnerProfileData.profilePicId}" alt="${partnerProfileData.username}">`;
                } else {
                    voiceCallAvatar.innerHTML = `<i class="fas fa-user-circle"></i>`;
                }
            }

            hideCallStatusOverlay();
            console.log("JCHAT_DEBUG: Active call started");
        }

        /**
         * Update call timer display
         */
        function updateCallTimer() {
            if (callStartTime) {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                callTimerElement.textContent = timeString;
            }
        }

        /**
         * Update connection status indicator
         */
        function updateConnectionStatus(state) {
            const localStatus = document.getElementById('localConnectionStatus');
            const remoteStatus = document.getElementById('remoteConnectionStatus');

            if (state === 'connected') {
                localStatus.className = 'connection-status';
                remoteStatus.className = 'connection-status';
            } else if (state === 'connecting') {
                localStatus.className = 'connection-status poor';
                remoteStatus.className = 'connection-status poor';
            } else {
                localStatus.className = 'connection-status disconnected';
                remoteStatus.className = 'connection-status disconnected';
            }
        }

        /**
         * Update call quality indicator
         */
        function updateCallQuality(state) {
            const qualityBars = document.querySelectorAll('.quality-bar');
            
            if (state === 'connected' || state === 'completed') {
                qualityBars.forEach((bar, index) => {
                    if (index < 4) {
                        bar.className = 'quality-bar active';
                    } else {
                        bar.className = 'quality-bar poor';
                    }
                });
            } else if (state === 'checking' || state === 'connected') {
                qualityBars.forEach((bar, index) => {
                    if (index < 3) {
                        bar.className = 'quality-bar active';
                    } else if (index < 4) {
                        bar.className = 'quality-bar poor';
                    } else {
                        bar.className = 'quality-bar bad';
                    }
                });
            } else {
                qualityBars.forEach((bar, index) => {
                    if (index < 2) {
                        bar.className = 'quality-bar poor';
                    } else {
                        bar.className = 'quality-bar bad';
                    }
                });
            }
        }

        /**
         * Rejects an incoming call.
         */
        async function rejectCall() {
            if (!currentUser || !partnerId) return;

            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const callDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "call_status", "current_call");

            try {
                await updateDoc(callDocRef, { status: 'rejected', rejectedBy: currentUser.uid, endedAt: serverTimestamp() });
                hideCallStatusOverlay();
                showMessageBox("Call rejected.", 'info');
                playNotificationSound('info');
                await sendMessage('call_status', `${currentUserProfileData.username} rejected the call.`);
            } catch (error) {
                console.error("JCHAT_ERROR: Error rejecting call:", error);
                showMessageBox(`Failed to reject call: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }
        /**
         * Listens for incoming call status changes and WebRTC signaling.
         */
        function listenForCallStatus() {
            if (!currentUser || !partnerId) {
                // Do not set up listener if no partner is selected
                if (unsubscribeCallStatus) {
                    unsubscribeCallStatus();
                    unsubscribeCallStatus = null;
                }
                return;
            }

            const chatRoomId = getChatRoomId(currentUser.uid, partnerId);
            const callDocRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "call_status", "current_call");
            const signalingRef = doc(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "signaling", "call_data");

            if (unsubscribeCallStatus) unsubscribeCallStatus(); // Clean up previous listener

            // Listen for call status changes
            const callStatusUnsubscribe = onSnapshot(callDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const callData = docSnap.data();
                    console.log("JCHAT_DEBUG: Call status update:", callData);

                    if (callData.status === 'ringing') {
                        // If current user is the receiver and call is ringing
                        if (callData.receiverId === currentUser.uid) {
                            playNotificationSound('incoming_call');
                            showCallStatusOverlay(
                                `Incoming ${callData.callType} Call`,
                                `from ${callData.callerUsername}`,
                                [
                                    { text: 'Accept', icon: 'fas fa-phone', className: 'accept-call-btn', onClick: () => acceptCall(callData.callType) },
                                    { text: 'Reject', icon: 'fas fa-phone-slash', className: 'reject-call-btn', onClick: rejectCall }
                                ]
                            );
                        } else if (callData.callerId === currentUser.uid) {
                            // Caller sees this when their call is ringing
                            showCallStatusOverlay(
                                `Outgoing ${callData.callType} Call`,
                                `Calling ${callData.receiverUsername}...`,
                                [{ text: 'End Call', icon: 'fas fa-phone-slash', className: 'end-call-btn', onClick: () => endCall('caller_ended') }]
                            );
                        }
                    } else if (callData.status === 'accepted') {
                        // Call accepted, keep overlay active and update UI
                        const connectedPartnerName = (callData.callerId === currentUser.uid) ? callData.receiverUsername : callData.callerUsername;
                        showCallStatusOverlay(
                            `Call Connected`,
                            `with ${connectedPartnerName}`,
                            [{ text: 'End Call', icon: 'fas fa-phone-slash', className: 'end-call-btn', onClick: () => endCall((callData.callerId === currentUser.uid) ? 'caller_ended' : 'receiver_ended') }]
                        );
                        playNotificationSound('success'); // Play success sound for both parties on connect
                    } else if (callData.status === 'rejected' || callData.status === 'caller_ended' || callData.status === 'receiver_ended' || callData.status === 'no_answer') {
                        // Call ended for any reason, hide overlay
                        hideCallStatusOverlay();
                        cleanupCall();
                        // Message handled by sendMessage('call_status', ...) already
                    }
                } else {
                    // Call document doesn't exist or was deleted, meaning call ended
                    hideCallStatusOverlay();
                    cleanupCall();
                }
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to call status:", error);
                showMessageBox(`Error listening to call status: ${error.message}`, 'error');
            });

            // Listen for WebRTC signaling
            const signalingUnsubscribe = onSnapshot(signalingRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const signalingData = docSnap.data();
                    console.log("JCHAT_DEBUG: Signaling data:", signalingData);

                    if (signalingData.type === 'offer' && signalingData.callerId !== currentUser.uid) {
                        // Received call offer
                        try {
                            // Prepare to answer but do not auto-accept UI yet
                            callType = signalingData.callType;
                            await initializeWebRTC(callType);
                            await getUserMedia(callType);
                            createPeerConnection();
                            localStream.getTracks().forEach(track => {
                                peerConnection.addTrack(track, localStream);
                            });
                            await peerConnection.setRemoteDescription(signalingData.offer);
                            // Show overlay to accept/reject if not already shown by call status listener
                            showCallStatusOverlay(
                                `Incoming ${callType} Call`,
                                `from ${partnerProfileData?.username || 'Unknown'}`,
                                [
                                    { text: 'Accept', icon: 'fas fa-phone', className: 'accept-call-btn', onClick: () => acceptCall(callType) },
                                    { text: 'Reject', icon: 'fas fa-phone-slash', className: 'reject-call-btn', onClick: rejectCall }
                                ]
                            );
                        } catch (error) {
                            console.error("JCHAT_ERROR: Error handling call offer:", error);
                            rejectCall();
                        }
                    } else if (signalingData.type === 'answer' && signalingData.callerId === currentUser.uid) {
                        // Received call answer
                        if (peerConnection) {
                            await peerConnection.setRemoteDescription(signalingData.answer);
                            startActiveCall(callType);
                        }
                    } else if (signalingData.type === 'ice_candidate') {
                        // Received ICE candidate
                        if (peerConnection && signalingData.iceCandidate) {
                            await peerConnection.addIceCandidate(signalingData.iceCandidate);
                        }
                    } else if (signalingData.type === 'end_call') {
                        // Call ended by partner
                        hideCallStatusOverlay();
                        cleanupCall();
                        showMessageBox("Call ended by partner", 'info');
                    }
                }
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to signaling:", error);
            });

            // Combine both unsubscribes
            unsubscribeCallStatus = () => {
                callStatusUnsubscribe();
                signalingUnsubscribe();
            };
        }

        /**
         * Opens the select friend modal and loads the friend list.
         */
        async function openSelectFriendModal() {
            if (!currentUser) {
                showMessageBox("Please log in to select a friend.", 'warning');
                return;
            }
            selectFriendModal.classList.add('active');
            await loadFriendsForSelection(); // Load friends when modal opens
        }

        /**
         * Closes the select friend modal.
         */
        function closeSelectFriendModal() {
            try { selectFriendModal.classList.remove('active'); } catch {}
            try { friendSearchInput.value = ''; } catch {}
        }
        // Close button wiring for friend modal
        document.getElementById('closeFriendModalBtn')?.addEventListener('click', closeSelectFriendModal);

        let allFriendsData = []; // Store all friends data for filtering

        /**
         * Loads and displays the current user's friends for selection in the modal.
         * @param {string} [searchTerm=''] - Optional search term to filter friends.
         */
        async function loadFriendsForSelection(searchTerm = '') {
            if (!currentUser) {
                if (loadingFriendsModal) loadingFriendsModal.style.display = 'none';
                if (noFriendsModal) {
                    noFriendsModal.style.display = 'block';
                    noFriendsModal.textContent = "Please log in to see your friends.";
                }
                return;
            }

            friendListContainer.innerHTML = ''; // Clear previous list
            if (loadingFriendsModal) loadingFriendsModal.style.display = 'block';
            if (noFriendsModal) noFriendsModal.style.display = 'none';

            try {
                const friendsCollectionRef = collection(db, "artifacts", appId, "users", currentUser.uid, "friends");
                const friendsSnapshot = await getDocs(friendsCollectionRef);
                const friendIds = friendsSnapshot.docs.map(doc => doc.id);

                const friendsDataPromises = friendIds.map(async (friendId) => {
                    try {
                        const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", friendId);
                        const publicDocSnap = await getDoc(publicProfileDocRef);
                        if (publicDocSnap.exists()) {
                            const friendProfile = publicDocSnap.data();
                            return {
                                userId: friendId,
                                username: friendProfile.username || `User_${friendId.substring(0, 8)}`,
                                profilePicId: friendProfile.profilePicId || null,
                            };
                        }
                    } catch (_) {
                        // Ignore and fallback below
                    }
                    // Fallback if no public profile doc
                    return {
                        userId: friendId,
                        username: `User_${friendId.substring(0, 8)}`,
                        profilePicId: null,
                    };
                });

                const fetchedFriends = await Promise.all(friendsDataPromises);
                allFriendsData = fetchedFriends; // Store for filtering

                renderSelectableFriends(searchTerm);

            } catch (error) {
                console.error("JCHAT_ERROR: Error loading friends for selection:", error);
                showMessageBox(`Error loading friends list: ${error.message}`, 'error');
                if (loadingFriendsModal) loadingFriendsModal.style.display = 'none';
                if (noFriendsModal) {
                    noFriendsModal.style.display = 'block';
                    noFriendsModal.textContent = "Failed to load friends. Please try again.";
                }
            }
        }

        /**
         * Renders the filtered list of friends into the selection modal.
         * @param {string} searchTerm - The current search term.
         */
        function renderSelectableFriends(searchTerm) {
            friendListContainer.innerHTML = ''; // Clear existing list
            if (loadingFriendsModal) loadingFriendsModal.style.display = 'none';

            const filteredFriends = allFriendsData.filter(friend =>
                friend.username.toLowerCase().includes(searchTerm.toLowerCase())
            );

            if (filteredFriends.length === 0) {
                if (noFriendsModal) noFriendsModal.style.display = 'block';
                noFriendsModal.textContent = searchTerm ? "No matching friends found." : "You don't have any friends yet.";
                return;
            } else {
                if (noFriendsModal) noFriendsModal.style.display = 'none';
            }

            filteredFriends.forEach(friend => {
                const friendItem = document.createElement('div');
                friendItem.classList.add('friend-item');
                friendItem.setAttribute('data-user-id', friend.userId);

                const usernameInitial = (friend.username || "J").charAt(0).toUpperCase();
                const profilePicHtml = friend.profilePicId
                    ? `<img src="${getCloudinaryImageUrl(friend.profilePicId, 'w_80,h_80,c_fill,g_face,r_max')}" alt="${friend.username}'s profile picture" onerror="this.onerror=null;this.src='https://placehold.co/40x40/CCCCCC/000000?text=${usernameInitial}';">`
                    : `<div class="default-avatar"><i class="fas fa-user-circle"></i></div>`;

                const unreadCount = unreadMessageCountsByFriendId[friend.userId] || 0;

                friendItem.innerHTML = `
                    ${profilePicHtml}
                    <span>${friend.username || 'Unknown User'}</span>
                    <span class="message-badge" style="display: ${unreadCount > 0 ? 'flex' : 'none'};">
                        ${unreadCount}
                    </span>
                `;

                friendItem.addEventListener('click', async () => {
                    const selectedFriendId = friend.userId;
                    if (selectedFriendId === partnerId) {
                        showMessageBox(`${friend.username} is already your current chat partner.`, 'info');
                        closeSelectFriendModal();
                        return;
                    }
                    partnerId = selectedFriendId;
                    await fetchPartnerProfile(partnerId);
                    await fetchAndDisplayMessages();
                    listenForCallStatus(); // Re-establish call listener for new partner
                    closeSelectFriendModal();
                    showMessageBox(`Chatting with ${friend.username}`, 'success');
                });

                friendListContainer.appendChild(friendItem);
            });
        }

        /**
         * Sets up real-time listeners to calculate and display unread message counts for friends.
         * This includes the total count on the header's select friend button and individual counts in the modal.
         */
        async function setupFriendUnreadCountListeners() {
            if (!currentUser) {
                console.log("JCHAT_DEBUG: No current user to set up friend unread count listeners.");
                return;
            }

            // Clear all previous listeners to prevent duplicates
            unsubscribeAllFriendUnreadListeners.forEach(unsub => unsub());
            unsubscribeAllFriendUnreadListeners = [];
            unreadMessageCountsByFriendId = {};
            totalUnreadMessages = 0;
            updateSelectFriendBadgeUI(); // Reset badge UI

            const friendsCollectionRef = collection(db, "artifacts", appId, "users", currentUser.uid, "friends");

            // Listener for the current user's friends list
            const unsubFriends = onSnapshot(friendsCollectionRef, (friendsSnapshot) => {
                const currentFriendIds = friendsSnapshot.docs.map(doc => doc.id);
                console.log("JCHAT_DEBUG: Friends list updated:", currentFriendIds);

                // Create a temporary map to track existing listeners and their unsubs
                const activeFriendListeners = {};

                // Ensure listeners are set up for all current friends
                currentFriendIds.forEach(friendId => {
                    // Only set up a new listener if one doesn't already exist for this friendId
                    // This is a simplified check; a more robust solution would track active listeners
                    // and only create new ones if needed. For now, on every friends list change,
                    // we'll re-evaluate all current friends.
                    setupIndividualFriendUnreadListener(friendId);
                });

                // Clean up listeners for friends who are no longer in the list
                // This part is tricky with multiple nested listeners.
                // The current implementation re-adds listeners on every friends list change,
                // which can lead to duplicates if not managed carefully.
                // For simplicity here, we rely on `unsubscribeAllFriendUnreadListeners` to clear all.
                // A more advanced pattern would involve mapping friendId to its unsub function.

                // If the friend modal is open, re-render the friend list
                if (selectFriendModal.classList.contains('active')) {
                    renderSelectableFriends(friendSearchInput.value);
                }
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening to friends list:", error);
            });
            unsubscribeAllFriendUnreadListeners.push(unsubFriends);
        }

        /**
         * Sets up a listener for a specific friend's unread message count.
         * This is called for each friend found in the user's friends list.
         * @param {string} friendId - The ID of the friend.
         */
        function setupIndividualFriendUnreadListener(friendId) {
            const chatMetadataDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "chat_metadata", friendId);

            // Listener for the current user's chat_metadata with this specific friend
            const unsubChatMetadata = onSnapshot(chatMetadataDocRef, async (chatMetadataSnap) => {
                const lastReadTimestamp = chatMetadataSnap.exists() ? chatMetadataSnap.data().lastReadMessageTimestamp : null;
                const chatRoomId = getChatRoomId(currentUser.uid, friendId);
                const messagesCollectionRef = collection(db, "artifacts", appId, "public", "data", "chats", chatRoomId, "messages");

                // Query messages from this friend that are newer than lastReadTimestamp
                let q = query(messagesCollectionRef,
                    where("senderId", "==", friendId),
                    orderBy("timestamp") // Order by timestamp ascending for count
                );

                if (lastReadTimestamp) {
                    q = query(messagesCollectionRef,
                        where("senderId", "==", friendId),
                        where("timestamp", ">", lastReadTimestamp),
                        orderBy("timestamp")
                    );
                }

                try {
                    const unreadMessagesSnapshot = await getDocs(q); // Use getDocs for a one-time fetch
                    const unreadCount = unreadMessagesSnapshot.docs.length;

                    // Update the global map and total count
                    unreadMessageCountsByFriendId[friendId] = unreadCount;
                    totalUnreadMessages = Object.values(unreadMessageCountsByFriendId).reduce((sum, count) => sum + count, 0);

                    // Update the header badge UI
                    updateSelectFriendBadgeUI();

                    // If the friend modal is open, re-render the friend list
                    if (selectFriendModal.classList.contains('active')) {
                        renderSelectableFriends(friendSearchInput.value);
                    }
                } catch (error) {
                    console.error(`JCHAT_ERROR: Error fetching unread messages for friend ${friendId}:`, error);
                    // On error, set count to 0 for this friend to avoid displaying stale data
                    unreadMessageCountsByFriendId[friendId] = 0;
                    totalUnreadMessages = Object.values(unreadMessageCountsByFriendId).reduce((sum, count) => sum + count, 0);
                    updateSelectFriendBadgeUI();
                }
            }, (error) => {
                console.error(`JCHAT_ERROR: Error listening to chat metadata for friend ${friendId}:`, error);
            });
            unsubscribeAllFriendUnreadListeners.push(unsubChatMetadata); // Add to the master list of unsubs
        }

        /**
         * Updates the UI for the select friend button badge.
         */
        function updateSelectFriendBadgeUI() {
            if (selectFriendBadge) {
                if (totalUnreadMessages > 0) {
                    selectFriendBadge.textContent = totalUnreadMessages;
                    selectFriendBadge.style.display = 'flex';
                } else {
                    selectFriendBadge.style.display = 'none';
                }
            }
        }


        // --- Authentication State Listener ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                isAuthReady = true;
                console.log("JCHAT_DEBUG: User authenticated in Private Chat Page:", user.uid);
                await fetchAndDisplayHeaderProfile(user);
                
                // Get partnerId from URL query parameter
                const urlParams = new URLSearchParams(window.location.search);
                partnerId = urlParams.get('partnerId');

                if (partnerId) {
                    await fetchPartnerProfile(partnerId);
                    fetchAndDisplayMessages(); // Fetch messages once authenticated and partnerId is set
                    listenForCallStatus(); // Start listening for call status
                } else {
                    // Do not auto-open the friend selection modal; keep clean initial screen
                    // Update initial display for no partner selected
                    partnerDisplayName.textContent = "No Partner Selected";
                    partnerProfilePic.style.display = 'none';
                    partnerAvatarIcon.style.display = 'block';
                    messagesDisplay.innerHTML = ''; // Clear any loading messages
                    if (loadingMessages) loadingMessages.style.display = 'none';
                    if (noMessages) {
                        noMessages.style.display = 'block';
                        noMessages.textContent = "Please select a friend to start chatting.";
                    }
                }
                fetchNotificationCount(user.uid); // For the bell icon
                setupFriendUnreadCountListeners(); // For friend message badges

                // Load entitlements
                try {
                    const entRef = doc(db, 'artifacts', appId, 'users', user.uid, 'profiles', 'user_entitlements');
                    const entSnap = await getDoc(entRef);
                    if (entSnap.exists()) {
                        const data = entSnap.data();
                        userEntitlements = { ...userEntitlements, ...data };
                    }
                } catch (e) { console.warn('Entitlements load failed', e); }
                setGatedUI();

            } else {
                console.log("JCHAT_DEBUG: No user signed in. Attempting anonymous sign-in or redirecting to login page.");
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("JCHAT_DEBUG: Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("JCHAT_DEBUG: Signed in anonymously.");
                    }
                    // onAuthStateChanged will be triggered again with the new user
                } catch (error) {
                    console.error("JCHAT_ERROR: Error during anonymous sign-in or custom token sign-in:", error);
                    // If anonymous sign-in also fails, redirect to login
                    if (!auth.currentUser) {
                        isAuthReady = false;
                        currentUser = null;
                        if (headerDisplayName) headerDisplayName.textContent = "Guest";
                        if (headerProfilePic) headerProfilePic.style.display = 'none';
                        if (headerAvatarIcon) headerAvatarIcon.style.display = 'block';
                        if (adminIconLink) adminIconLink.style.display = 'none';
                        showMessageBox("You must be logged in to access chat.", 'error', true);
                        setTimeout(() => {
                            window.location.href = '/login.html';
                        }, 2000);
                    }
                }
            }
        });

        // --- Call Control Functions ---
        /**
         * Toggle mute/unmute
         */
        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    isMuted = !audioTrack.enabled;
                    
                    // Update button states
                    muteVideoBtn.classList.toggle('muted', isMuted);
                    muteVoiceBtn.classList.toggle('muted', isMuted);
                    
                    // Update button icons
                    const muteIcon = isMuted ? 'fa-microphone-slash' : 'fa-microphone';
                    muteVideoBtn.innerHTML = `<i class="fas ${muteIcon}"></i>`;
                    muteVoiceBtn.innerHTML = `<i class="fas ${muteIcon}"></i>`;
                }
            }
        }

        /**
         * Toggle video on/off
         */
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    isVideoEnabled = videoTrack.enabled;
                    
                    // Update button state
                    toggleVideoBtn.classList.toggle('muted', !isVideoEnabled);
                    
                    // Update button icon
                    const videoIcon = isVideoEnabled ? 'fa-video' : 'fa-video-slash';
                    toggleVideoBtn.innerHTML = `<i class="fas ${videoIcon}"></i>`;
                }
            }
        }

        /**
         * Switch between front and back cameras
         */
        async function switchCamera() {
            if (localStream && callType === 'video') {
                try {
                    // Stop current video track
                    const currentVideoTrack = localStream.getVideoTracks()[0];
                    if (currentVideoTrack) {
                        currentVideoTrack.stop();
                    }

                    // Switch camera
                    currentCamera = currentCamera === 'front' ? 'environment' : 'front';

                    // Get new video stream
                    const newVideoStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280, min: 640 },
                            height: { ideal: 720, min: 480 },
                            facingMode: currentCamera
                        }
                    });

                    // Replace video track in local stream
                    const newVideoTrack = newVideoStream.getVideoTracks()[0];
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        sender.replaceTrack(newVideoTrack);
                    }

                    // Update local video
                    localVideo.srcObject = localStream;
                    await localVideo.play();

                    console.log("JCHAT_DEBUG: Camera switched to", currentCamera);
                } catch (error) {
                    console.error("JCHAT_ERROR: Error switching camera:", error);
                    showMessageBox("Failed to switch camera", 'error');
                }
            }
        }

        /**
         * Toggle fullscreen mode
         */
        function toggleFullscreen() {
            const videoItem = document.querySelector('.video-item.fullscreen');
            if (videoItem) {
                // Exit fullscreen
                videoItem.classList.remove('fullscreen');
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
                fullscreenBtn.title = 'Fullscreen';
            } else {
                // Enter fullscreen
                const remoteVideoItem = document.getElementById('remoteVideoItem');
                remoteVideoItem.classList.add('fullscreen');
                fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
                fullscreenBtn.title = 'Exit Fullscreen';
            }
        }

        /**
         * Toggle speaker mode
         */
        function toggleSpeaker() {
            if (remoteVideo) {
                isSpeakerOn = !isSpeakerOn;
                remoteVideo.muted = !isSpeakerOn;
                
                // Update button state
                speakerBtn.classList.toggle('active', isSpeakerOn);
                
                // Update button icon
                const speakerIcon = isSpeakerOn ? 'fa-volume-mute' : 'fa-volume-up';
                speakerBtn.innerHTML = `<i class="fas ${speakerIcon}"></i>`;
            }
        }
        // ---- UI Toggles Wiring ----
        (function wireToggles(){
            // Friend selector button
            const selectFriendBtn = document.getElementById('selectFriendBtn');
            if (selectFriendBtn) {
                selectFriendBtn.addEventListener('click', openSelectFriendModal);
            }
            // Theme switcher
            const themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
            function applyTheme(theme){
                const themes = ['theme-light-mode', 'theme-dark-mode'];
                document.body.classList.remove(...themes);
                document.body.classList.add(theme);
                localStorage.setItem('jchat-theme', theme);
                const icon = themeSwitcherBtn?.querySelector('i');
                if (icon) icon.className = theme === 'theme-light-mode' ? 'fas fa-sun' : 'fas fa-moon';
            }
            const savedTheme = localStorage.getItem('jchat-theme') || 'theme-dark-mode';
            applyTheme(savedTheme);
            themeSwitcherBtn?.addEventListener('click', ()=>{
                const next = document.body.classList.contains('theme-dark-mode') ? 'theme-light-mode' : 'theme-dark-mode';
                applyTheme(next);
            });
            // Sound toggle
            const soundToggleIcon = document.getElementById('soundToggleIcon');
            if (soundToggleIcon) {
                const savedSoundPreference = localStorage.getItem('jchat-sound-enabled');
                if (savedSoundPreference !== null) {
                    notificationSoundEnabled = JSON.parse(savedSoundPreference);
                }
                const setSoundIcon = () => {
                    soundToggleIcon.classList.toggle('active', !!notificationSoundEnabled);
                    soundToggleIcon.classList.remove(notificationSoundEnabled ? 'fa-volume-mute' : 'fa-volume-up');
                    soundToggleIcon.classList.add(notificationSoundEnabled ? 'fa-volume-up' : 'fa-volume-mute');
                };
                setSoundIcon();
                soundToggleIcon.addEventListener('click', () => {
                    notificationSoundEnabled = !notificationSoundEnabled;
                    localStorage.setItem('jchat-sound-enabled', JSON.stringify(notificationSoundEnabled));
                    setSoundIcon();
                    showMessageBox(`Notification sounds ${notificationSoundEnabled ? 'ON' : 'OFF'}`, 'info');
                });
            }
            // Stickers toggle
            const stickersBtn = document.getElementById('stickersBtn');
            const stickerPicker = document.getElementById('stickerPicker');
            const stickerPickerClose = document.getElementById('stickerPickerClose');
            // Anchor sticker picker to the stickers button like WhatsApp
            if (stickersBtn && stickerPicker) {
                const anchor = stickersBtn.parentElement || document.body;
                if (anchor && anchor !== stickerPicker.parentElement) {
                    // Ensure anchor can position absolute children
                    if (getComputedStyle(anchor).position === 'static') {
                        anchor.style.position = 'relative';
                    }
                    anchor.appendChild(stickerPicker);
                    // Convert picker to anchored dropdown
                    Object.assign(stickerPicker.style, {
                        position: 'absolute',
                        bottom: '48px',
                        right: '0',
                        left: 'auto',
                        transform: 'none',
                        width: 'min(360px, 95vw)',
                        maxHeight: '60vh',
                        zIndex: '1200',
                        border: '1px solid #e0e0e0',
                        borderRadius: '16px',
                        boxShadow: '0 8px 32px rgba(0,0,0,0.2)'
                    });
                }
            }
            function openStickerPicker() {
                if (!stickerPicker) return;
                // Initialize packs on first open
                if (typeof window.__stickerPickerInitialized === 'undefined' || !window.__stickerPickerInitialized) {
                    buildStickerPicker();
                    window.__stickerPickerInitialized = true;
                }
                stickerPicker.style.display = 'block';
                stickerPicker.scrollTop = 0;
            }
            function closeStickerPicker() {
                if (!stickerPicker) return;
                stickerPicker.style.display = 'none';
            }
            stickersBtn?.addEventListener('click', ()=>{
                if (!stickersBtn) return;
                const locked = stickersBtn.dataset.locked === '1';
                if (locked && !UNLOCK_ALL_PREVIEW) {
                    showMessageBox('Stickers are locked. Visit Store to unlock.', 'info');
                    return;
                }
                if (stickerPicker?.style.display === 'block') closeStickerPicker(); else openStickerPicker();
            });
            stickerPickerClose?.addEventListener('click', closeStickerPicker);
            document.addEventListener('click', (ev)=>{
                if (stickerPicker && stickersBtn && stickerPicker.style.display === 'block' && !stickerPicker.contains(ev.target) && ev.target !== stickersBtn) {
                    closeStickerPicker();
                }
            });
        })();

        // ---- Stickers: Packs + Builder ----
        (function defineStickerPacks(){
            const STICKER_PACKS = [
                { id: 'smileys', name: 'Smileys', emojis: ['','','','','','','','','','','','','','','','','','','',''] },
                { id: 'hands', name: 'Hands', emojis: ['','','','','','','','','','','','','','','',''] },
                { id: 'hearts', name: 'Hearts', emojis: ['','','','','','','','','','','','','','','','','',''] },
                { id: 'party', name: 'Party', emojis: ['','','','','','','','','','','','',''] },
                { id: 'animals', name: 'Animals', emojis: ['','','','','','','','','','','','','',''] },
                { id: 'food', name: 'Food', emojis: ['','','','','','','','','','','','','','','',''] },
                { id: 'misc', name: 'More', emojis: ['','','','','','','','','','','','','',''] },
                { id: 'travel', name: 'Travel', emojis: ['','','','','','','','','','','','','',''] },
                { id: 'nature', name: 'Nature', emojis: ['','','','','','','','','','','','','','','',''] },
                { id: 'sports', name: 'Sports', emojis: ['','','','','','','','','','','',''] },
                { id: 'music', name: 'Music', emojis: ['','','','','','','','',''] },
                { id: 'objects', name: 'Objects', emojis: ['','','','','','','','','','','','',''] },
                { id: 'food2', name: 'Foods 2', emojis: ['','','','','','','','','','','','','',''] },
                { id: 'faces2', name: 'Faces 2', emojis: ['','','','','','','','','','','',''] },
                { id: 'activity', name: 'Activities', emojis: ['','','','','','','','','','','',''] },
            ];
            const emojiToCodePoints = (emoji) => Array.from(emoji).map(ch => ch.codePointAt(0).toString(16)).join('-');
            const getTwemojiUrl = (emoji) => {
    const cp = emojiToCodePoints(emoji);
    const urls = [
        `https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/${cp}.png`,
        `https://twemoji.maxcdn.com/v/latest/72x72/${cp}.png`,
        `https://cdn.jsdelivr.net/gh/twitter/twemoji@latest/assets/72x72/${cp}.png`
    ];
    return urls[0];
};

            window.buildStickerPicker = function buildStickerPicker(){
                const tabs = document.getElementById('stickerTabs');
                const grid = document.getElementById('stickerGrid');
                if (!tabs || !grid) return;
                tabs.innerHTML = '';
                function renderPack(pack){
                    grid.innerHTML = '';
                    pack.emojis.forEach((emoji, idx) => {
                        const isFree = idx < 3;
                        const url = getTwemojiUrl(emoji);
                        const wrap = document.createElement('div');
                        wrap.style.position = 'relative';
                        const img = document.createElement('img');
                        img.src = url;
                        img.alt = 'sticker';
                        img.loading = 'lazy';
                        img.style.cssText = `width:32px;height:32px;object-fit:contain;border-radius:8px;background:#f8f9fa;padding:3px;transition:all .12s ease;${isFree ? 'cursor:pointer;' : 'filter: grayscale(100%); opacity:.6; cursor:not-allowed;'}`;
                        // Fallback through CDNs on error
                        img.onerror = (() => {
                            const cp = emojiToCodePoints(emoji);
                            const fallbacks = [
                                `https://twemoji.maxcdn.com/v/latest/72x72/${cp}.png`,
                                `https://cdn.jsdelivr.net/gh/twitter/twemoji@latest/assets/72x72/${cp}.png`
                            ];
                            let i = 0;
                            return () => {
                                if (i < fallbacks.length) { img.src = fallbacks[i++]; }
                                else { wrap.style.display = 'none'; }
                            };
                        })();
                        if (isFree) {
                            img.addEventListener('mouseenter', ()=>{ img.style.transform = 'scale(1.08)'; img.style.background='#e9ecef'; });
                            img.addEventListener('mouseleave', ()=>{ img.style.transform = 'scale(1)'; img.style.background='#f8f9fa'; });
                            img.addEventListener('click', async ()=>{
                                try { await sendMessage('image', url); } catch (e) { console.error(e); showMessageBox('Failed to send sticker','error'); }
                            });
                        } else {
                            const lock = document.createElement('div');
                            lock.innerHTML = '<i class="fas fa-lock"></i>';
                            lock.style.cssText = 'position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.6);color:#fff;border-radius:8px;padding:2px 4px;font-size:10px;';
                            wrap.appendChild(lock);
                            img.title = 'Locked. Unlock this category in Store.';
                        }
                        wrap.appendChild(img);
                        grid.appendChild(wrap);
                    });
                }
                STICKER_PACKS.forEach((p, idx) => {
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = 'display:flex; align-items:center; gap:6px;';

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.textContent = p.name;
                    btn.style.cssText = 'flex:0 0 auto; padding:8px 12px; border:none; background:#f5f5f5; color:#666; border-radius:16px; font-size:13px; font-weight:600; cursor:pointer;';
                    if (idx === 0) { btn.classList.add('active'); btn.style.background = '#25D366'; btn.style.color = '#fff'; renderPack(p); }
                    btn.addEventListener('click', ()=>{
                        [...tabs.children].forEach(ch => { ch.firstChild?.classList?.remove('active'); ch.firstChild.style.background='#f5f5f5'; ch.firstChild.style.color='#666'; });
                        btn.classList.add('active'); btn.style.background='#25D366'; btn.style.color='#fff';
                        renderPack(p);
                    });

                    const price = document.createElement('a');
                    price.href = `/jcoin_shop.html?select=${encodeURIComponent(p.id)}`;
                    price.textContent = '300';
                    price.style.cssText = 'flex:0 0 auto; font-size:11px; color:#25D366; text-decoration:none; border:1px solid #e0e0e0; padding:2px 6px; border-radius:12px;';

                    wrapper.appendChild(btn);
                    wrapper.appendChild(price);
                    tabs.appendChild(wrapper);
                });
                const prev = document.getElementById('tabsPrev');
                const next = document.getElementById('tabsNext');
                prev?.addEventListener('click', ()=> tabs.scrollBy({left: -Math.max(200, tabs.clientWidth/2), behavior:'smooth'}));
                next?.addEventListener('click', ()=> tabs.scrollBy({left:  Math.max(200, tabs.clientWidth/2), behavior:'smooth'}));
            };
        })();

        // ---- Tiny Floating Flower: Bank + Quick Receipt Upload ----
        (function setupFloatingFlower(){
            try {
                const adminUid = 'cc96gdhCRPO72NFZtleRCujHvIq2';
                const opayAcct = '8111609765';
                const keystoneAcct = '6042862356';

                const container = document.createElement('div');
                container.id = 'flowerWidget';
                container.style.cssText = 'position:fixed; right:14px; bottom:14px; z-index:9999; display:flex; flex-direction:column; align-items:flex-end; gap:8px; pointer-events:none;';

                const button = document.createElement('button');
                button.id = 'flowerButton';
                button.setAttribute('aria-label', 'Support & Premium');
                button.style.cssText = 'pointer-events:auto; width:24px; height:24px; border:none; border-radius:50%; background:#fff; color:#e91e63; box-shadow:0 4px 12px rgba(0,0,0,.2); cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:14px; line-height:1;';
                button.textContent = '';

                const panel = document.createElement('div');
                panel.id = 'flowerPanel';
                panel.style.cssText = 'pointer-events:auto; display:none; width:280px; background:var(--card-background); border:1px solid var(--border-light); border-radius:12px; padding:10px; color:var(--white); box-shadow:0 10px 25px rgba(0,0,0,.35)';
                panel.innerHTML = `
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:6px; margin-bottom:6px;">
                        <div style="display:flex; align-items:center; gap:6px; font-weight:700;"><span></span><span>Premium & Payments</span></div>
                        <button id=\"flowerClose\" style=\"background:transparent;border:none;color:var(--white);cursor:pointer\"><i class=\"fas fa-times\"></i></button>
                    </div>
                    <div style=\"display:grid; gap:8px;\">
                        <div style=\"font-size:12px; color:var(--text-light)\">Transfer to any bank below. Use your Order ID as reference.</div>
                        <div style=\"padding:6px; border:1px solid var(--border-light); border-radius:8px;\">
                            <div style=\"display:flex;align-items:center;gap:6px;font-size:13px\"><i class=\"fas fa-university\" style=\"color:#ffd700\"></i><strong>OPay</strong></div>
                            <div style=\"font-size:12px\">Name: ELECHI JOSHUA</div>
                            <div style=\"font-size:12px\">Acct: <span>${opayAcct}</span> <button data-copy=\"${opayAcct}\" class=\"copyBtn\" style=\"margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 2px 6px; cursor: pointer; font-size:11px;\">Copy</button></div>
                        </div>
                        <div style=\"padding:6px; border:1px solid var(--border-light); border-radius:8px;\">
                            <div style=\"display:flex;align-items:center;gap:6px;font-size:13px\"><i class=\"fas fa-university\" style=\"color:#ffd700\"></i><strong>Keystone Bank</strong></div>
                            <div style=\"font-size:12px\">Name: ELECHI OSOUNDU JOSHUA</div>
                            <div style=\"font-size:12px\">Acct: <span>${keystoneAcct}</span> <button data-copy=\"${keystoneAcct}\" class=\"copyBtn\" style=\"margin-left:6px; background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 8px; padding: 2px 6px; cursor: pointer; font-size:11px;\">Copy</button></div>
                        </div>
                        <a href=\"/jcoin_shop.html\" target=\"_blank\" style=\"display:inline-flex;align-items:center;gap:6px; font-size:12px; text-decoration:none; color:#25D366;\"><i class=\"fas fa-store\"></i> Pick category to pay</a>
                        <div style=\"border-top:1px solid var(--border-light); padding-top:8px; display:grid; gap:6px;\">
                            <div style=\"font-weight:700; font-size:13px;\">Select Category & Upload Receipt</div>
                            <input id=\"flowerOrderId\" type=\"text\" placeholder=\"Order ID (e.g., EMOJI-...)\" style=\"width:100%; padding:8px; border-radius:8px; border:1px solid var(--border-light); background:transparent; color:var(--white); font-size:12px;\" />
                            <input id=\"flowerItemNote\" type=\"text\" placeholder=\"Category / Note (optional)\" style=\"width:100%; padding:8px; border-radius:8px; border:1px solid var(--border-light); background:transparent; color:var(--white); font-size:12px;\" />
                            <input id=\"flowerAmount\" type=\"number\" placeholder=\"Amount (NGN) optional\" style=\"width:100%; padding:8px; border-radius:8px; border:1px solid var(--border-light); background:transparent; color:var(--white); font-size:12px;\" />
                            <input id=\"flowerReceipt\" type=\"file\" accept=\"image/*,.pdf\" style=\"font-size:12px; color:var(--text-light)\" />
                            <div style=\"display:flex; justify-content:flex-end; gap:8px;\">
                                <button id=\"flowerSubmit\" class=\"modal-button save-button\" style=\"padding:6px 10px; font-size:12px;\"><span class=\"button-text\">Submit</span><div class=\"button-loader\" style=\"margin-left:6px\"></div></button>
                            </div>
                            <div id=\"flowerError\" style=\"display:none; color:#ff6b6b; font-size:12px;\"></div>
                        </div>
                    </div>
                `;

                container.appendChild(panel);
                container.appendChild(button);
                document.body.appendChild(container);

                const togglePanel = (show) => { panel.style.display = show ? 'block' : 'none'; };
                let lastAutoOpen = 0;
                let userDismissedUntil = 0;
                const autoOpenMs = 10000; // 10s
                const autoVisibleMs = 5000;

                button.addEventListener('click', ()=>{
                    const isVisible = panel.style.display === 'block';
                    togglePanel(!isVisible);
                });
                panel.querySelector('#flowerClose')?.addEventListener('click', ()=>{
                    togglePanel(false);
                    userDismissedUntil = Date.now() + 60000; // 1 min snooze
                });
                panel.querySelectorAll('.copyBtn').forEach(btn => btn.addEventListener('click', (e)=>{
                    const val = e.currentTarget.getAttribute('data-copy');
                    navigator.clipboard?.writeText(val).then(()=> showMessageBox('Copied', 'success')).catch(()=>{});
                }));

                // Auto-open disabled by request; users open via the tiny flower button
                // Initialize category list and order id
                const flowerCategory = panel.querySelector('#flowerCategory');
                const flowerOrderIdText = panel.querySelector('#flowerOrderIdText');
                if (flowerCategory) {
                    const OPTIONS = [
                        { id:'stickers:smileys', label:'Smileys' },
                        { id:'stickers:hands', label:'Hands' },
                        { id:'stickers:hearts', label:'Hearts' },
                        { id:'stickers:party', label:'Party' },
                        { id:'stickers:animals', label:'Animals' },
                        { id:'stickers:food', label:'Food' },
                        { id:'stickers:misc', label:'More' },
                        { id:'stickers:travel', label:'Travel' },
                        { id:'stickers:nature', label:'Nature' },
                        { id:'stickers:sports', label:'Sports' },
                        { id:'stickers:music', label:'Music' },
                        { id:'stickers:objects', label:'Objects' },
                        { id:'stickers:food2', label:'Foods 2' },
                        { id:'stickers:faces2', label:'Faces 2' },
                        { id:'stickers:activity', label:'Activities' }
                    ];
                    flowerCategory.innerHTML = OPTIONS.map(o => `<option value="${o.id}">${o.label}</option>`).join('');
                }
                function genOrderId(){ return `EMOJI-${Date.now()}`; }
                if (flowerOrderIdText) flowerOrderIdText.textContent = genOrderId();

                async function submitFlowerReceipt(){
                    const err = panel.querySelector('#flowerError');
                    const btn = panel.querySelector('#flowerSubmit');
                    const textEl = btn.querySelector('.button-text');
                    const loader = btn.querySelector('.button-loader');
                    const flowerCategory = panel.querySelector('#flowerCategory');
                    const flowerOrderIdText = panel.querySelector('#flowerOrderIdText');
                    const orderId = flowerOrderIdText?.textContent || `EMOJI-${Date.now()}`;
                    const note = flowerCategory?.value || '';
                    const amountRaw = '300';
                    const receiptFile = panel.querySelector('#flowerReceipt')?.files?.[0] || null;
                    err.style.display = 'none';

                    if (!auth?.currentUser) { showMessageBox('Please log in.', 'error'); return; }
                    if (!note) { err.textContent = 'Select a category.'; err.style.display = 'block'; return; }

                    try {
                        btn.disabled = true; textEl.textContent = 'Submitting...'; loader.style.display = 'inline-block';

                        let receiptUrl = '';
                        if (receiptFile) {
                            const path = `orders/${auth.currentUser.uid}/${orderId}/${encodeURIComponent(receiptFile.name)}`;
                            const storageRef = ref(storage, path);
                            await uploadBytes(storageRef, receiptFile);
                            receiptUrl = await getDownloadURL(storageRef);
                        }

                        const ordersRef = collection(db, 'artifacts', appId, 'public', 'data', 'orders');
                        const payload = {
                            orderId,
                            userId: auth.currentUser.uid,
                            itemType: 'emoji_packs',
                            itemNote: note,
                            itemIds: [note],
                            amount: `${Number(amountRaw)}`,
                            currency: 'NGN',
                            status: 'pending',
                            assignedAdminId: adminUid,
                            source: 'flower_widget',
                            receiptUrl: receiptUrl || '',
                            createdAt: serverTimestamp(),
                        };
                        await addDoc(ordersRef, payload);

                        showMessageBox('Submitted to Admin. You will be notified after approval.', 'success');
                        togglePanel(false);
                    } catch (e) {
                        console.error(e);
                        err.textContent = 'Failed to submit. Try again.';
                        err.style.display = 'block';
                    } finally {
                        btn.disabled = false; textEl.textContent = 'Submit'; loader.style.display = '';
                    }
                }

                panel.querySelector('#flowerSubmit')?.addEventListener('click', (e)=>{
                    e.preventDefault();
                    submitFlowerReceipt();
                });
            } catch (e) {
                console.warn('Flower widget init failed', e);
            }
        })();
        // ... existing code ...
        // ... existing code ...
    </script>
</body>
</html>