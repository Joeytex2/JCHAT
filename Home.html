<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Home</title>
    
    <!-- Security Meta Tags -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="JCHAT - Modern social chat platform with levels, JCoins, and community features">
    <meta name="keywords" content="chat, social, messaging, community, levels, gaming">
    <meta name="author" content="JCHAT Team">

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>
    <link rel="preconnect" href="https://api.cloudinary.com" crossorigin>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">


    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <style>
        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --glass-black: rgba(10, 10, 10, .75);
            --glass-blue: rgba(0, 213, 255, .15);
            --radius: 20px;
            --transition: .3s ease;

            /* These variables will be overridden by theme classes */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* New variables for consistent theming (Added for consistency with Profile/Levels) */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            /* --notification-badge-color: Hardcoded for visibility */
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff; /* A bright cyan */
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;
            --theme-gold: #ffd700;
        }

        /* Theme Switcher Button */
        .theme-switcher-btn {
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.7), rgba(255, 46, 146, 0.7));

            color: var(--white);
            border: none;
            border-radius: 50%;
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .theme-switcher-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }

        .theme-switcher-btn:active {
            transform: scale(0.98);
        }
        /* --- Theme Definitions (Light and Dark Mode) --- */
        /* Light Mode */
        body.theme-light-mode {
            background: #f0f2f5 !important;
            background-color: #f0f2f5 !important;
            background-image: radial-gradient(circle at top left, #e0e2e5, transparent 100px),
                              radial-gradient(circle at bottom right, #d0d2d5, transparent 150px) !important;
            --background-main: #f0f2f5;
            --background-gradient-1: #e0e2e5;
            --background-gradient-2: #d0d2d5;
            --white: #333;
            --text-light: #666;
            --card-background: rgba(255, 255, 255, 0.95);
            --header-background: rgba(255, 255, 255, 0.98);
            --border-light: rgba(0, 0, 0, 0.1);
            --input-background: rgba(0, 0, 0, 0.05);
            --button-background: linear-gradient(90deg, #6dd5ed, #2193b0);
            --button-shadow: 0 4px 15px rgba(109, 213, 237, 0.4), 0 4px 15px rgba(33, 147, 176, 0.4);
            --background-color-primary: #f0f2f5;
            --background-color-secondary: #e0e2e5;
            --header-background-color: #ffffff;
            --footer-background-color: #ffffff;
            --content-background-color: #f7f9fb;
            --card-background-color: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --text-color-light: #999999;
            --accent-color: #007bff;
            --accent-color-dark: #0056b3;
            --border-color: #e0e0e0;
            --input-background-color: #f0f0f0;
            --button-background: #e9ecef;
            --button-hover-background: #dee2e6;
            --active-item-background: rgba(0, 123, 255, 0.1);
            /* --notification-badge-color: Hardcoded for visibility */
            --status-online: #28a745;
            --status-offline: #6c757d;
            --status-away: #ffc107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
        }

        /* Dark Mode */
        body.theme-dark-mode {
            background: #1a1a2e !important;
            background-color: #1a1a2e !important;
            background-image: radial-gradient(circle at top left, #16213e, transparent 100px),
                              radial-gradient(circle at bottom right, #0f3460, transparent 150px) !important;
            --background-main: #1a1a2e;
            --background-gradient-1: #16213e;
            --background-gradient-2: #0f3460;
            --white: #e0e0e0;
            --text-light: #a0a0a0;
            --card-background: rgba(25, 25, 40, 0.7);
            --header-background: linear-gradient(135deg, rgba(10, 10, 20, .85), rgba(10, 10, 20, .75));
            --border-light: rgba(255, 255, 255, 0.08);
            --input-background: rgba(255, 255, 255, 0.08);
            --button-background: linear-gradient(90deg, #e94560, #ba2f49);
            --button-shadow: 0 4px 15px rgba(233, 69, 96, 0.4), 0 4px 15px rgba(186, 47, 73, 0.4);
            --background-color-primary: #121212;
            --background-color-secondary: #1e1e1e;
            --header-background-color: #2c2c2c;
            --footer-background-color: #2c2c2c;
            --content-background-color: #242424;
            --card-background-color: #2c2c2c;
            --text-color-primary: #ffffff;
            --text-color-secondary: #bbbbbb;
            --accent-color: #bb86fc;
            --accent-color-dark: #9a67ea;
            --border-color: #444444;
            --input-background-color: #383838;
            --button-background: #383838;
            --button-hover-background: #505050;
            --active-item-background: rgba(187, 134, 252, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #f44336;
            --warning-color: #ffeb3b;
        }

        /* Sunset Theme */
        body.theme-sunset-mode {
            background: linear-gradient(to top, #ff7e5f, #feb47b) !important;
            background-color: transparent !important;
            background-image: linear-gradient(to top, #ff7e5f, #feb47b) !important;
            --background-main: linear-gradient(to top, #ff7e5f, #feb47b);
            --card-background: rgba(255, 255, 255, 0.15);
            --white: #fff;
            --text-light: rgba(255, 255, 255, 0.8);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.3);
            --button-background: linear-gradient(90deg, #fd746c, #ff9068);
            --button-shadow: 0 4px 15px rgba(253, 116, 108, 0.4), 0 4px 15px rgba(255, 144, 104, 0.4);
            --background-color-primary: #ff7e5f;
            --background-color-secondary: #feb47b;
            --header-background-color: rgba(255, 126, 95, 0.9);
            --footer-background-color: rgba(255, 126, 95, 0.9);
            --content-background-color: rgba(255, 126, 95, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.15);
            --text-color-primary: #fff;
            --text-color-secondary: rgba(255, 255, 255, 0.8);
            --accent-color: #fd746c;
            --accent-color-dark: #ff9068;
            --border-color: rgba(255, 255, 255, 0.3);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #fd746c, #ff9068);
            --button-hover-background: #ff9068;
            --active-item-background: rgba(253, 116, 108, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #dc143c;
            --warning-color: #ffd700;
        }

/* Glass Mode specific variables */
        body.theme-glass-mode {
            --background-main: rgba(10, 10, 10, 0.75);
            background-image: url('https://source.unsplash.com/random/1920x1080?abstract,blur') !important; /* Added !important */
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            backdrop-filter: blur(10px);
            --card-background: rgba(25, 25, 40, 0.7);
            --white: #e0e0e0; /* text-color */
            --text-light: rgba(255, 255, 255, 0.7);
            --input-background: rgba(255, 255, 255, 0.05);
            --border-light: rgba(255, 255, 255, 0.1); /* glass-border-color */
            --button-background: linear-gradient(90deg, var(--pink), var(--blue));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5); /* Inner shadow for glass effect */

            /* New variables override for glass mode */
            --background-color-primary: rgba(10, 10, 10, 0.75);
            --background-color-secondary: rgba(10, 10, 10, 0.6);
            --header-background-color: rgba(10, 10, 10, 0.85);
            --footer-background-color: rgba(10, 10, 10, 0.85);
            --content-background-color: rgba(10, 10, 10, 0.75);
            --card-background-color: rgba(25, 25, 40, 0.7);
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: rgba(255, 255, 255, 0.1);
            --input-background-color: rgba(255, 255, 255, 0.05);
            --button-background: rgba(0, 213, 255, 0.15); /* Glassy button */
            --button-hover-background: rgba(0, 213, 255, 0.25);
            --active-item-background: rgba(0, 213, 255, 0.1);
        }



        /* Always show scrollbar to prevent layout shifts */
        html {
            overflow-y: scroll;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden; /* Prevent horizontal scroll */
            /* Removed padding-bottom as bottom nav is gone */
            background-color: var(--background-main);
            background-image: radial-gradient(circle at top left, var(--background-gradient-1), transparent 100px),
                              radial-gradient(circle at bottom right, var(--background-gradient-2), transparent 150px);
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease; /* Smooth theme transition */
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 55px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 30px;
        }

        .logo { display: none; }
        .brand-banner { width: 100%; padding: 28px 0; background: linear-gradient(90deg, var(--blue), var(--pink)); color:#fff; text-align:center; position: relative; border-bottom: 1px solid var(--border-light); }
        .brand-banner .brand-title { font-family: 'Poppins', sans-serif; font-size: 2rem; font-weight: 800; letter-spacing: -0.02em; }
        .brand-banner .brand-sub { opacity: .9; font-size: .95rem; margin-top: 6px; }
        .brand-banner .brand-glow { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 120px rgba(255,255,255,.15); border-radius: 0 0 16px 16px; }

        /* Removed Header Navigation (Home, Profile) */
        header nav {
            display: none; /* Hide the nav element entirely */
        }

        /* User Profile Header Styling */
        .user-profile-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cool Notification Icon Styling */
        .notification-icon-wrapper {
            position: relative;
            margin-right: 15px;
        }

        .notification-icon-wrapper a {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
            border: 2px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            /* Enhanced visibility with subtle glow */
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15), 0 0 20px rgba(255, 255, 255, 0.05);
        }

        .notification-icon-wrapper a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .notification-icon-wrapper a:hover::before {
            left: 100%;
        }

        .notification-icon-wrapper a:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.3),
                0 0 30px rgba(255, 142, 83, 0.2),
                0 2px 12px rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 215, 0, 0.7);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.08));
        }

        .notification-icon-wrapper i {
            font-size: 1.2rem;
            /* Improved visibility with solid colors that work across all themes */
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 142, 83, 0.6);
            transition: all 0.3s ease;
            z-index: 1;
            position: relative;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .notification-icon-wrapper a:hover i {
            transform: rotate(10deg) scale(1.05);
            color: #ffdf00;
            text-shadow: 0 0 15px rgba(255, 223, 0, 0.9), 0 0 20px rgba(255, 142, 83, 0.8);
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            /* High contrast background for excellent visibility */
            background: linear-gradient(135deg, #ff4757, #ff3742);
            color: #ffffff;
            border-radius: 50%;
            padding: 3px 7px;
            font-size: 0.75rem;
            font-weight: 900;
            min-width: 20px;
            height: 20px;
            text-align: center;
            /* Enhanced shadow for better definition */
            box-shadow: 
                0 2px 8px rgba(255, 71, 87, 0.6),
                0 0 0 2px #ffffff,
                0 0 0 3px rgba(255, 71, 87, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-notification 2s infinite;
            z-index: 2;
            /* Better text readability */
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1;
        }

        @keyframes pulse-notification {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .notification-badge:empty {
            display: none;
        }

        /* Additional cool effects for notification icon */
        .notification-icon-wrapper a:active {
            transform: scale(0.98);
        }

        /* Glow effect when there are notifications */
        .notification-icon-wrapper.has-notifications a {
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
        }

        .notification-icon-wrapper.has-notifications a:hover {
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.4),
                0 0 35px rgba(255, 215, 0, 0.6),
                0 2px 12px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced shaking animation for notification bell - shakes every 3 seconds */
        .notification-icon-wrapper.has-notifications i {
            animation: bell-shake 3s ease-in-out infinite;
            transform-origin: top;
        }

        @keyframes bell-shake {
            0%, 90%, 100% { transform: rotate(0deg); }
            5%, 15%, 25%, 35% { transform: rotate(10deg); }
            10%, 20%, 30% { transform: rotate(-10deg); }
            40%, 50%, 60%, 70%, 80% { transform: rotate(0deg); }
        }

        /* Pause shaking on hover */
        .notification-icon-wrapper.has-notifications a:hover i {
            animation-play-state: paused;
        }

        /* Header Notification Button */
        .header-notification-btn {
            background: transparent;
            border: none;
            color: var(--white);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-notification-btn:hover {
            background: var(--glass-blue);
            color: var(--blue);
        }

        .header-notification-btn.active {
            background: var(--glass-blue);
            color: var(--blue);
        }

        /* --- Comprehensive Notification System CSS --- */
        
        /* Toast Notifications */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 350px;
            z-index: 10000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast-notification.show {
            transform: translateX(0);
        }

        .toast-notification.toast-success {
            border-left: 4px solid #4caf50;
        }

        .toast-notification.toast-error {
            border-left: 4px solid #f44336;
        }

        .toast-notification.toast-info {
            border-left: 4px solid #2196f3;
        }

        .toast-notification.toast-warning {
            border-left: 4px solid #ff9800;
        }

        .toast-notification.toast-friend_request {
            border-left: 4px solid #9c27b0;
        }

        .toast-notification.toast-message {
            border-left: 4px solid #00bcd4;
        }

        .toast-notification.toast-level_up {
            border-left: 4px solid #ffd700;
        }

        .toast-icon {
            font-size: 0.9rem;
            color: var(--white);
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--white);
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.3;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--white);
        }




            position: relative;
        }


            color: var(--white);
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .no-notifications {
            text-align: center;
            padding: 60px 30px;
            color: var(--text-light);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.03) 0%, 
                rgba(255, 255, 255, 0.01) 100%);
            border-radius: 15px;
            margin: 20px;
        }

        .no-notifications i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.6;
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.7), rgba(255, 46, 146, 0.7));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .no-notifications p {
            font-size: 1rem;
            margin: 0;
            font-weight: 500;
        }

        /* Beautiful Notification Center Scrollbar */
        .notifications-list::-webkit-scrollbar {
            width: 8px;
        }

        .notifications-list::-webkit-scrollbar-track {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.05) 0%, 
                rgba(255, 255, 255, 0.02) 100%);
            border-radius: 4px;
            margin: 5px 0;
        }

        .notifications-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.3) 0%, 
                rgba(255, 255, 255, 0.1) 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .notifications-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.4) 0%, 
                rgba(255, 255, 255, 0.2) 100%);
            transform: scale(1.05);
        }

        /* Duplicate notification animation removed to prevent conflicts */

        /* Admin Icon Styling */
        #adminIconLink {
            display: none; /* Hidden by default */
            margin-right: 15px; /* Space it out from other icons */
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        #adminIconLink:hover {
            transform: scale(1.05);
        }

        .user-profile-header #profileLink {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--white);
            transition: opacity 0.3s ease, background-color 0.3s ease;
            padding: 5px 10px;
            border-radius: var(--radius);
        }

        .user-profile-header #profileLink:hover {
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .user-profile-header img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color); /* Used accent-color for consistency */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .user-profile-header i {
            font-size: 30px;
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        .user-profile-header span {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: visible;
            text-overflow: unset;
            max-width: none;
            /* Apply gradient to names */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }



        /* Main Content Area */
        main {
            flex-grow: 1;
            padding: 40px 0;
            padding-top: 55px; /* Adjust for fixed header */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top */
            text-align: center;
        }

        .content-wrapper {
            width: 100%;
            max-width: 1000px; /* Adjust as needed */
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        /* Daily Inspiration Section */
        .daily-inspiration-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 2rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            text-align: center;
        }

        .daily-inspiration-section h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 2rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            margin: 0;
        }

        .daily-inspiration-section .quote-text {
            font-size: 0.9rem;
            color: var(--white);
            line-height: 1.6;
            font-style: italic;
            margin: 0;
        }

        .daily-inspiration-section .quote-author {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-top: 0.5rem;
            font-weight: 600;
        }
        .daily-inspiration-section .inspiration-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        .inspiration-action-button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 0.8rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .inspiration-action-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--blue), 0 6px 20px var(--pink);
        }
        .inspiration-action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Post Creation Section */
        .post-creation-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 100%;
            max-width: 600px; /* Max width for post creation */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 20px; /* Space from inspiration section */
        }

        .post-creation-section h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            margin-bottom: 0.5rem;
        }

        .post-creation-section textarea {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 1rem;
            outline: none;
            transition: border-color var(--transition), box-shadow var(--transition);
            resize: vertical;
            min-height: 80px;
        }

        .post-creation-section textarea:focus {
            border-color: rgba(0, 213, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .post-creation-section .media-upload-area {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .post-creation-section .file-input-label {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: none; /* Changed from border to none */
            border-radius: 12px;
            padding: 8px 15px;
            cursor: pointer;
            font-weight: 700;
            transition: all var(--transition);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        .post-creation-section .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--blue), 0 44px 15px var(--pink);
        }

        .post-creation-section input[type="file"] {
            display: none;
        }

        .post-creation-section .media-preview {
            max-width: 100px;
            max-height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            display: none;
            margin-left: 10px;
        }

        .post-creation-section .media-preview {
            max-width: 100px;
            max-height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            display: none;
            margin-left: 10px;
        }

        .post-creation-section .post-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
        }

        .post-creation-section .post-button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-creation-section .post-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--blue), 0 6px 20px var(--pink);
        }
        .post-creation-section .post-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Posts Feed Section */
        .posts-feed-section {
            width: 100%;
            max-width: 600px; /* Max width for posts feed */
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px; /* Space from post creation section */
        }

        .post-card {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 4px 15px rgba(0, 0, 0, .2);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative; /* For dropdown menu positioning */
        }

        .post-header .author-pic-wrapper {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid var(--blue);
            flex-shrink: 0;
        }

        .post-header .author-pic {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .post-header .author-pic-placeholder {
            font-size: 40px;
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .post-header .author-info {
            flex-grow: 1;
        }

        .post-header .author-name {
            font-weight: 600;
            color: var(--white);
            font-size: 1rem;
            text-decoration: none; /* Make author name clickable */
        }

        .post-header .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .post-options-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 0.9rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .post-options-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .post-options-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .post-options-dropdown {
            position: absolute;
            top: 40px; /* Position below the button */
            right: 0;
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            min-width: 150px;
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow: hidden; /* For rounded corners on children */
        }

        .post-options-dropdown.active {
            display: flex;
        }

        .post-options-dropdown button {
            background: none;
            border: none;
            color: var(--white);
            padding: 10px 15px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .post-options-dropdown button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .post-options-dropdown button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .post-options-dropdown button i {
            width: 20px; /* Align icons */
        }

        /* Themed buttons in dropdown */
        .post-options-dropdown .edit-post-button {
            background: linear-gradient(90deg, var(--blue), #00d5ff80); /* Blue gradient */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(0, 213, 255, 0.3);
            border-radius: 0; /* Override default button border-radius */
        }
        .post-options-dropdown .edit-post-button:hover {
            background: linear-gradient(90deg, #00b5e0, var(--blue));
            box-shadow: 0 4px 10px rgba(0, 213, 255, 0.5);
        }

        .post-options-dropdown .delete-post-button {
            background: linear-gradient(90deg, var(--pink), #ff2e9280); /* Pink gradient */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(255, 46, 146, 0.3);
            border-radius: 0;
        }
        .post-options-dropdown .delete-post-button:hover {
            background: linear-gradient(90deg, #e02a82, var(--pink));
            box-shadow: 0 4px 10px rgba(255, 46, 146, 0.5);
        }

        .post-options-dropdown .share-post-button {
            background: linear-gradient(90deg, var(--blue), var(--pink)); /* Mixed gradient for share */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border-radius: 0;
        }
        .post-options-dropdown .share-post-button:hover {
            background: linear-gradient(90deg, var(--pink), var(--blue)); /* Reverse gradient on hover */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }


        .post-content-text {
            font-size: 1rem;
            color: var(--white);
            line-height: 1.5;
            word-wrap: break-word;
        }

        .post-media {
            margin-top: 10px;
        }

        .post-media img, .post-media video {
            max-width: 100%;
            border-radius: 10px;
            display: block;
            height: auto;
        }

        .post-reactions-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-light);
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-light);
        }

        .post-reactions-summary span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .post-reactions-summary i {
            font-size: 1rem;
        }

        .post-actions-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding-top: 1rem;
        }

        .post-action-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.2s ease, transform 0.1s ease-out; /* Added transform for animation */
            padding: 8px 12px;
            border-radius: 10px;
        }

        .post-action-button:hover:not(:disabled) {
            color: var(--blue);
            background-color: rgba(0, 213, 255, 0.05);
            transform: translateY(-2px); /* Slight lift on hover */
        }
        .post-action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Reaction button animations */
        .post-action-button.reacted-like {
            color: var(--blue);
            background-color: rgba(0, 213, 255, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }
        .post-action-button.reacted-love {
            color: var(--pink);
            background-color: rgba(255, 46, 146, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }
        .post-action-button.reacted-haha {
            color: #ffd700; /* Gold */
            background-color: rgba(255, 215, 0, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }

        @keyframes pop-reaction {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Comments Section */
        .comments-section {
            margin-top: 1rem;
            border-top: 1px solid var(--border-light);
            padding-top: 1rem;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 1rem;
        }

        .comment-item {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            background-color: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 10px;
        }

        .comment-item .comment-author-pic {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            border: 1px solid var(--blue);
        }

        .comment-item .comment-author-pic-placeholder {
            font-size: 30px;
            color: var(--text-light);
            flex-shrink: 0;
        }

        .comment-item .comment-content-wrapper {
            flex-grow: 1;
            text-align: left;
        }

        .comment-item .comment-author-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--white);
            margin-right: 5px;
            text-decoration: none;
        }

        .comment-item .comment-text {
            font-size: 0.9rem;
            color: var(--text-light);
            word-wrap: break-word;
            display: inline; /* Keep on same line as author for short comments */
        }

        .comment-item .comment-timestamp {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            margin-left: 10px;
        }

        .comment-item .delete-comment-button {
            background: none;
            border: none;
            color: var(--pink);
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.9rem;
            padding: 0; /* Remove padding */
        }
        .comment-item .delete-comment-button:hover:not(:disabled) {
            opacity: 0.8;
        }
        .comment-item .delete-comment-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }


        .comment-input-area {
            display: flex;
            gap: 10px;
            margin-top: 1rem;
            align-items: center;
        }

        .comment-input-area textarea {
            flex-grow: 1;
            padding: 8px 12px;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 0.9rem;
            outline: none;
            resize: vertical;
            min-height: 32px;
            max-height: 80px; /* Limit comment input height */
        }

        .comment-input-area textarea:focus {
            border-color: rgba(0, 213, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .comment-input-area button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 8px 15px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex-shrink: 0;
        }

        .comment-input-area button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
        }
        .comment-input-area button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Customization/Edit Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 2rem;
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            margin-bottom: 0.5rem;
        }

        .modal-content .radio-group,
        .modal-content .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            text-align: left;
        }

        .modal-content label {
            color: var(--text-light);
            font-size: 0.95rem;
            font-weight: 600;
        }

        .modal-content input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--blue);
            border-radius: 50%;
            background-color: var(--input-background);
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .modal-content input[type="radio"]:checked {
            background-color: var(--blue);
            border-color: rgba(0, 213, 255, 0.6);
        }

        .modal-content input[type="radio"]:checked::after {
            content: '';
            width: 8px;
            height: 8px;
            background-color: var(--white);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .modal-content textarea {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 1rem;
            outline: none;
            transition: border-color var(--transition), box-shadow var(--transition);
            resize: vertical;
            min-height: 80px;
        }
        .modal-content textarea:focus {
            border-color: rgba(0, 213, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .modal-content .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        .modal-content .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .modal-content .cancel-button {
            background: rgba(255, 255, 255, 0.1);
            color: var(--white);
            border: 1px solid var(--border-light);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .modal-content .cancel-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .modal-content .save-button {
            background: var(--button-background);
            color: var(--white);
            box-shadow: var(--button-shadow);
        }

        .modal-content .save-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
        }

        /* Loader styles for buttons */
        .button-loader {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--white);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
        }

        .button-loader.active {
            display: block;
        }

        .button-text {
            display: block;
        }

        .loading .button-text {
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Message Box Styles */
        #messageBox {
            position: fixed;
            top: 50%; /* Centered vertically */
            left: 50%;
            transform: translate(-50%, -50%); /* Centered horizontally and vertically */
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px; /* Increased padding for a 'squarer' feel */
            border-radius: 15px; /* Slightly less rounded */
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5); /* More pronounced shadow */
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; /* Add transform transition */
            min-width: 280px; /* Slightly wider */
            max-width: 90%; /* Responsive max-width */
            text-align: center;
            font-size: 1.1rem; /* Slightly larger font */
            font-weight: 600;
            backdrop-filter: blur(5px); /* Subtle blur for glass effect */
        }
        /* Specific styling for success messages */
        #messageBox.success {
            background: linear-gradient(135deg, var(--blue), var(--pink)); /* Pink and blue gradient */
            border: 2px solid rgba(255, 255, 255, 0.3); /* White border for definition */
            color: var(--white); /* Ensure text is white */
            box-shadow: 0 5px 25px rgba(0, 213, 255, 0.5), 0 5px 25px rgba(255, 46, 146, 0.5); /* Dual color shadow */
        }
        #messageBox.error { border-left: 5px solid var(--delete-button-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Corrected from original */
        #messageBox.info { border-left: 5px solid var(--accent-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Corrected from original */
        #messageBox.warning i { color: var(--warning-color); }


        @keyframes pulse-bg {
            0% { background-color: rgba(52, 152, 219, 0.9); }
            50% { background-color: rgba(52, 152, 219, 0.7); }
            100% { background-color: rgba(52, 152, 219, 0.9); }
        }
        #messageBox.loading-pulse { animation: pulse-bg 1.5s infinite ease-in-out; }

        /* Confirmation Modal Specific Styles */
        #confirmationModal .modal-content {
            max-width: 400px;
            text-align: center;
            padding: 1.8rem;
        }
        #confirmationModal .modal-content h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.6rem;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--pink), var(--blue));
            margin-bottom: 1rem;
        }
        #confirmationModal .modal-content p {
            font-size: 1rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }
        #confirmationModal .modal-content .button-group {
            justify-content: center;
            gap: 1rem;
        }
        #confirmationModal .confirm-button {
            background: var(--pink); /* Use pink for destructive action */
            color: var(--white);
            box-shadow: 0 4px 15px var(--pink);
        }
        #confirmationModal .confirm-button:hover {
            background: #e02a82; /* Darker pink on hover */
            box-shadow: 0 6px 20px var(--pink);
        }
        #confirmationModal .cancel-button {
            background: var(--blue); /* Use blue for cancel/safe action */
            color: var(--white);
            box-shadow: 0 4px 15px var(--blue);
        }
        #confirmationModal .cancel-button:hover {
            background: #00b5e0; /* Darker blue on hover */
            box-shadow: 0 6px 20px var(--blue);
        }


        /* --- Sidebar Navigation --- */
        #sidebarNav {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 250px; /* Default sidebar width */
            background: var(--header-background); /* Use header background for consistency */
            border-right: 1px solid var(--border-light);
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
            z-index: 90; /* Higher than main content, lower than modals */
            display: flex;
            flex-direction: column;
            padding: 20px;
            transition: transform 0.3s ease-out; /* Smooth slide transition */
            transform: translateX(-100%); /* Hidden by default */
        }

        #sidebarNav.sidebar-visible {
            transform: translateX(0); /* Show sidebar */
        }

        #sidebarNav.sidebar-hidden {
            transform: translateX(-100%); /* Hide sidebar */
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-light);
        }

        .sidebar-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
        }

        #sidebarCloseBtn {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        #sidebarCloseBtn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--white);
        }

        .sidebar-links {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar-nav-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 15px;
            border-radius: 10px;
            text-decoration: none;
            color: var(--text-light);
            font-size: 1.1rem;
            font-weight: 600;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .sidebar-nav-item:hover {
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--white);
            transform: translateX(5px);
        }

        .sidebar-nav-item.active {
            background-color: rgba(0, 213, 255, 0.15); /* Light blue tint for active */
            color: var(--white);
            border-left: 4px solid var(--blue); /* Highlight active link */
            padding-left: 11px; /* Adjust padding due to border */
        }

        .sidebar-nav-item i {
            font-size: 1.4rem;
            /* Apply gradient to sidebar icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            width: 30px; /* Fixed width for icon alignment */
            text-align: center;
        }

        .sidebar-nav-item span {
            /* Apply gradient to sidebar text labels */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        /* Sidebar Toggle Button in Header */
        #sidebarToggleFab {
            position: static; /* No longer fixed, now part of header flow */
            width: 30px; /* Smaller */
            height: 30px; /* Smaller */
            border-radius: 50%;
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.7), rgba(255, 46, 146, 0.7));
            color: var(--white);
            border: none;
            box-shadow: none; /* No shadow by default */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem; /* Smaller icon */
            cursor: pointer;
            z-index: 80;
            transition: opacity 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
            opacity: 0.3; /* Less visible when not in use */
            margin-right: 15px; /* Space from logo */
        }

        #sidebarToggleFab:hover {
            opacity: 1; /* Fully visible on hover */
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* Subtle shadow on hover */
            background: linear-gradient(45deg, var(--pink), var(--blue)); /* Reverse gradient on hover */
        }

        /* NEW: Maintenance Mode Overlay */
        #maintenanceOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Darker overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top of everything */
            color: var(--white);
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(8px); /* Subtle blur effect */
            transition: opacity 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        #maintenanceOverlay.active {
            opacity: 1;
            visibility: visible;
        }

        #maintenanceOverlay i {
            font-size: 5rem;
            color: var(--warning-color); /* Use warning color for icon */
            margin-bottom: 20px;
        }

        #maintenanceOverlay h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 3rem;
            font-weight: 800;
            color: var(--warning-color); /* Use warning color for heading */
            margin-bottom: 10px;
        }

        #maintenanceOverlay p {
            font-size: 0.9rem;
            line-height: 1.6;
            max-width: 600px;
            color: var(--text-light);
        }

        /* Call Overlay Styles (NEW) */
        #callOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: var(--white);
            font-family: 'Poppins', sans-serif;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }
        #callOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        #callOverlay .call-status-icon {
            font-size: 5rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            /* Animation for calling/ringing state */
            animation: pulse-color 2s infinite alternate;
        }
        /* New animation for call icon when active */
        @keyframes pulse-color {
            0% { color: var(--accent-color); }
            100% { color: var(--pink); }
        }
        #callOverlay .call-status-text {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 10px;
        }
        #callOverlay .call-timer {
            font-size: 1.5rem;
            color: var(--text-light);
            margin-bottom: 30px;
        }
        #callOverlay .call-actions {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #callOverlay .call-actions button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--white);
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #callOverlay .call-actions button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        #callOverlay .call-actions button.accept-call-btn {
            background: #28a745;
        }
        #callOverlay .call-actions button.decline-call-btn,
        #callOverlay .call-actions button.end-call-btn {
            background: var(--delete-button-color);
        }
        #callOverlay .call-actions button.toggle-mute-btn {
            background: rgba(255, 255, 255, 0.2);
        }
        #callOverlay .call-actions button.toggle-mute-btn.active {
            background: #ccc; /* Grey when muted */
            color: #333;
        }
        #callOverlay .call-actions button.toggle-video-btn {
            background: rgba(255, 255, 255, 0.2);
        }
        #callOverlay .call-actions button.toggle-video-btn.active {
            background: #ccc; /* Grey when video off */
            color: #333;
        }

        /* Video elements within call overlay */
        #callOverlay .video-streams {
            position: relative;
            width: 90%;
            max-width: 800px;
            height: 50%;
            max-height: 450px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: #000;
            display: none; /* Hidden by default until stream is active */
        }
        #localVideo {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 120px;
            height: 90px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            background-color: #333;
            z-index: 1;
            transform: scaleX(-1); /* Mirror local video */
            display: none; /* Hidden by default until stream is active */
        }
        #callOverlay.voice-call .video-streams {
            display: none; /* Hide video streams for voice calls */
        }
        /* Responsive Adjustments */
        @media (max-width: 600px) {
            header .header-content-wrapper {
                padding: 0 20px;
            }
.logo { display:none; }
            #sidebarToggleFab {
                width: 25px;
                height: 25px;
                font-size: 1rem;
                margin-right: 10px;
            }
            .notification-icon-wrapper a {
                width: 36px;
                height: 36px;
            }
            .notification-icon-wrapper i {
                font-size: 1.15rem;
            }
            .notification-badge {
                padding: 2px 5px;
                font-size: 0.65rem;
                min-width: 18px;
                height: 18px;
                top: -6px;
                right: -6px;
            }
            #adminIconLink {
                font-size: 1.1rem;
                margin-right: 10px;
            }
            .user-profile-header span {
                font-size: 0.9rem;
                max-width: 150px;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .daily-inspiration-section {
                padding: 1.5rem;
            }
            .daily-inspiration-section h2 {
                font-size: 1.8rem;
            }
            .daily-inspiration-section .quote-text {
                font-size: 1rem;
            }
            .daily-inspiration-section .quote-author {
                font-size: 0.8rem;
            }
            .inspiration-action-button {
                padding: 0.7rem 1.2rem;
                font-size: 0.8rem;
            }
            .post-creation-section {
                padding: 1rem;
            }
            .post-creation-section h3 {
                font-size: 1.1rem;
            }
            .post-creation-section textarea {
                padding: 0.7rem 0.9rem;
                font-size: 0.9rem;
            }
            .post-creation-section .post-button {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
            }
            .post-card {
                padding: 1rem;
            }
            .post-header .author-pic-wrapper {
                width: 35px;
                height: 35px;
            }
            .post-header .author-pic-placeholder {
                font-size: 35px;
            }
            .post-header .author-name {
                font-size: 0.9rem;
            }
            .post-header .post-timestamp {
                font-size: 0.7rem;
            }
            .post-action-button {
                font-size: 0.8rem;
            }
            .post-action-button i {
                font-size: 1rem;
            }
            .comment-item .comment-author-pic {
                width: 25px;
                height: 25px;
            }
            .comment-item .comment-author-pic-placeholder {
                font-size: 25px;
            }
            .comment-item .comment-author-name, .comment-item .comment-text {
                font-size: 0.8rem;
            }
            .comment-item .comment-timestamp {
                font-size: 0.75rem;
            }
            .comment-input-area textarea {
                padding: 6px 10px;
                font-size: 0.85rem;
            }
            .comment-input-area button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .modal-content h3 {
                font-size: 1.1rem;
            }
            .modal-content .radio-option {
                font-size: 0.9rem;
            }
            .modal-content .modal-button {
                padding: 8px 15px;
                font-size: 0.8rem;
            }
            #confirmationModal .modal-content h3 {
                font-size: 1.4rem;
            }
            #confirmationModal .modal-content p {
                font-size: 0.9rem;
            }
            /* Sidebar on mobile: make it full width */
            #sidebarNav {
                width: 100%;
                padding: 20px 10px; /* Adjust padding */
            }

            /* Maintenance Overlay on Mobile */
            #maintenanceOverlay h2 {
                font-size: 2rem;
            }
            #maintenanceOverlay p {
                font-size: 1rem;
            }
            #maintenanceOverlay i {
                font-size: 4rem;
            }
            /* Call Overlay on Mobile */
            #callOverlay .call-status-icon {
                font-size: 4rem;
            }
            #callOverlay .call-status-text {
                font-size: 1.5rem;
            }
            #callOverlay .call-timer {
                font-size: 0.9rem;
            }
            #callOverlay .call-actions button {
                width: 50px;
                height: 50px;
                font-size: 1.8rem;
            }
            #localVideo {
                width: 90px;
                height: 70px;
                bottom: 10px;
                right: 10px;
            }
        }

        /* Posts Controls */
        .post-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-controls select,
        .post-controls input[type="text"],
        .post-controls input[type="date"] {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            background: var(--input-background);
            color: var(--white);
        }
        .post-control-button {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            background: var(--button-background);
            color: var(--white);
            cursor: pointer;
        }
        .post-control-button:hover { opacity: .95; }

        /* Stories Bar */
        .stories-bar { display:flex; gap:10px; padding:8px 0; overflow-x:auto; }
        .story-item { display:flex; flex-direction:column; align-items:center; gap:6px; }
        .story-avatar { width:56px; height:56px; border-radius:50%; border:2px solid var(--blue); background:#333; display:flex; align-items:center; justify-content:center; overflow:hidden; }
        .story-avatar img { width:100%; height:100%; object-fit:cover; }
        .add-story-button { background: var(--button-background); color: var(--white); border: none; padding: 6px 10px; border-radius: 8px; cursor: pointer; }

        /* Engagement Panel */
        .engagement-panel { display:grid; grid-template-columns: 1fr; gap: 12px; margin: 10px 0; }
        .engage-card { background: var(--card-background); border:1px solid var(--glass-blue); border-radius: 15px; padding: 12px; }
        .engage-title { font-weight:600; margin-bottom:6px; }
        .quests-list { display:flex; flex-direction:column; gap:8px; }
        .quest-item { display:flex; align-items:center; justify-content:space-between; gap:10px; }
        .quest-progress { flex:1; height:8px; background:rgba(255,255,255,0.1); border-radius:6px; overflow:hidden; margin:0 8px; }
        .quest-progress > div { height:100%; background: var(--blue); }
        .spin-button { background: linear-gradient(90deg, var(--blue), var(--pink)); color:#fff; border:none; border-radius:10px; padding:8px 12px; cursor:pointer; }

        /* Theme Switcher */
        .theme-switcher { display:flex; gap:8px; align-items:center; }
        .theme-switcher select { padding:6px 10px; border-radius:8px; border:1px solid var(--border-light); background:var(--input-background); color:var(--white); }

        /* Story Viewer (compact) */
        #storyViewer { position: fixed; right: 16px; bottom: 16px; z-index: 1200; display: none; }
        #storyViewer.active { display: block; }
        #storyViewer .viewer-card {
            width: 300px; height: 520px; border-radius: 16px; overflow: hidden;
            background: var(--card-background); border: 1px solid var(--glass-blue);
            box-shadow: 0 12px 30px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;
        }
        #storyViewer .viewer-header { display:flex; align-items:center; justify-content:space-between; padding:8px 10px; }
        #storyViewer .viewer-title { color: var(--white); font-weight: 600; font-size: 0.95rem; }
        #storyViewer .viewer-close { background: transparent; border:none; color: var(--white); cursor:pointer; }
        #storyViewer .viewer-media { flex:1; display:flex; align-items:center; justify-content:center; background:#000; }
        #storyImage, #storyVideo { max-width:100%; max-height:100%; display:none; }
        #storyViewer .viewer-footer { display:flex; align-items:center; justify-content:space-between; padding:6px 10px; }
        #prevStoryBtn, #nextStoryBtn { background: rgba(255,255,255,0.1); color: var(--white); border: 1px solid var(--border-light); border-radius: 10px; padding: 6px 10px; cursor: pointer; }
    #smartScrollBtn { position: fixed; right: 16px; bottom: 90px; z-index: 1100; border: 1px solid var(--border-light); border-radius: 999px; background: var(--button-background); color: #fff; padding: 10px 14px; display: flex; align-items: center; gap: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.4); cursor: pointer; }
        #smartScrollBtn .label { font-weight: 600; }
    .icon-btn { background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 10px; padding: 6px 8px; margin-right: 8px; cursor: pointer; }

    /* Quick Actions Floating Menu */
    .quick-actions-menu {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }

    .quick-actions-toggle {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--blue), var(--pink));
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 8px 25px rgba(0, 213, 255, 0.4), 0 8px 25px rgba(255, 46, 146, 0.4);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1001;
    }

    .quick-actions-toggle:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 35px rgba(0, 213, 255, 0.6), 0 12px 35px rgba(255, 46, 146, 0.6);
    }

    .quick-actions-toggle.active {
        transform: rotate(45deg);
        background: linear-gradient(135deg, var(--pink), var(--blue));
    }

    .quick-actions-dropdown {
        position: absolute;
        bottom: 70px;
        right: 0;
        background: var(--glass-black);
        backdrop-filter: blur(15px);
        border: 1px solid var(--glass-blue);
        border-radius: 20px;
        padding: 15px;
        min-width: 200px;
        opacity: 0;
        visibility: hidden;
        transform: translateY(20px) scale(0.9);
        transition: all 0.3s ease;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
    }

    .quick-actions-dropdown.show {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
    }

    .quick-action-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        color: var(--white);
        cursor: pointer;
        border-radius: 12px;
        transition: all 0.2s ease;
        margin-bottom: 8px;
    }

    .quick-action-item:last-child {
        margin-bottom: 0;
    }

    .quick-action-item:hover {
        background: var(--glass-blue);
        transform: translateX(5px);
    }

    .quick-action-item i {
        font-size: 18px;
        width: 20px;
        text-align: center;
        color: var(--blue);
    }

            .quick-action-item span {
            font-weight: 500;
            font-size: 14px;
        }

        .quick-action-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--status-offline);
            margin-left: auto;
            transition: all 0.3s ease;
        }

        .quick-action-status.active {
            background: var(--status-online);
            box-shadow: 0 0 8px var(--status-online);
        }

    /* Mobile Responsiveness for Quick Actions */
    @media (max-width: 768px) {
        .quick-actions-menu {
            bottom: 20px;
            right: 20px;
        }

        .quick-actions-toggle {
            width: 55px;
            height: 55px;
            font-size: 22px;
        }

        .quick-actions-dropdown {
            min-width: 180px;
            padding: 12px;
        }

        .quick-action-item {
            padding: 10px 14px;
            font-size: 13px;
        }
    }

    /* Enhanced Mobile Experience */
    @media (max-width: 768px) {
        .content-wrapper {
            padding: 15px;
            gap: 15px;
        }

        .daily-inspiration-section {
            padding: 1.5rem;
            width: 95%;
        }

        .daily-inspiration-section h2 {
            font-size: 1.5rem;
        }

        .post-creation-section {
            padding: 1rem;
        }

        .post-creation-section h3 {
            font-size: 1.1rem;
        }

        .quick-actions-toggle {
            box-shadow: 0 6px 20px rgba(0, 213, 255, 0.5), 0 6px 20px rgba(255, 46, 146, 0.5);
        }

        .quick-actions-toggle:active {
            transform: scale(0.95);
        }
    }

    /* Smooth scrolling for better UX */
    html {
        scroll-behavior: smooth;
    }

    /* Enhanced button interactions */
    .quick-action-item:active {
        transform: scale(0.98);
    }

    /* Loading states for quick actions */
    .quick-action-item.loading {
        opacity: 0.7;
        pointer-events: none;
    }

    .quick-action-item.loading::after {
        content: '';
        width: 16px;
        height: 16px;
        border: 2px solid var(--blue);
        border-top: 2px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-left: auto;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Smart Notifications Panel */
    .notifications-panel {
        background: var(--glass-black);
        backdrop-filter: blur(15px);
        border: 1px solid var(--glass-blue);
        border-radius: var(--radius);
        box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
        padding: 1.5rem;
        width: 90%;
        max-width: 700px;
        margin: 20px auto;
        display: none;
    }

    .notifications-panel.show {
        display: block;
        animation: slideInUp 0.3s ease;
    }
    @keyframes slideInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .notifications-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-light);
    }

    .notifications-title {
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--white);
        font-weight: 600;
        font-size: 1.1rem;
    }

    .notifications-title i {
        color: var(--blue);
        font-size: 1.2rem;
    }

    .notifications-count {
        background: var(--pink);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
        font-weight: 600;
        min-width: 20px;
        text-align: center;
    }

    .clear-notifications-btn {
        background: transparent;
        border: 1px solid var(--border-light);
        color: var(--text-light);
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .clear-notifications-btn:hover {
        background: var(--glass-blue);
        color: var(--white);
        border-color: var(--blue);
    }

    .notifications-list {
        max-height: 300px;
        overflow-y: auto;
    }

    .notification-item {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px;
        border-radius: 10px;
        margin-bottom: 8px;
        transition: all 0.2s ease;
        border-left: 3px solid transparent;
    }

    .notification-item:hover {
        background: var(--glass-blue);
        transform: translateX(5px);
    }

    .notification-item.info {
        border-left-color: var(--blue);
        background: rgba(0, 213, 255, 0.1);
    }

    .notification-item.success {
        border-left-color: var(--status-online);
        background: rgba(76, 175, 80, 0.1);
    }

    .notification-item.warning {
        border-left-color: var(--warning-color);
        background: rgba(255, 193, 7, 0.1);
    }

    .notification-item.error {
        border-left-color: var(--delete-button-color);
        background: rgba(220, 53, 69, 0.1);
    }

    .notification-icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        flex-shrink: 0;
    }

    .notification-item.info .notification-icon {
        background: rgba(0, 213, 255, 0.2);
        color: var(--blue);
    }

    .notification-item.success .notification-icon {
        background: rgba(76, 175, 80, 0.2);
        color: var(--status-online);
    }

    .notification-item.warning .notification-icon {
        background: rgba(255, 193, 7, 0.2);
        color: var(--warning-color);
    }

    .notification-item.error .notification-icon {
        background: rgba(220, 53, 69, 0.2);
        color: var(--delete-button-color);
    }

    .notification-content {
        flex: 1;
        min-width: 0;
    }

    .notification-title {
        font-weight: 600;
        color: var(--white);
        margin-bottom: 4px;
        font-size: 0.9rem;
    }

    .notification-message {
        color: var(--text-light);
        font-size: 0.85rem;
        line-height: 1.4;
        margin-bottom: 6px;
    }

    .notification-time {
        color: var(--text-light);
        font-size: 0.75rem;
        opacity: 0.8;
    }

    .remove-notification-btn {
        background: transparent;
        border: none;
        color: var(--text-light);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s ease;
        opacity: 0.7;
    }

    .remove-notification-btn:hover {
        color: var(--delete-button-color);
        opacity: 1;
        background: rgba(220, 53, 69, 0.1);
    }

    .no-notifications {
        text-align: center;
        padding: 2rem;
        color: var(--text-light);
    }

    .no-notifications i {
        font-size: 3rem;
        margin-bottom: 1rem;
        opacity: 0.5;
    }

    .no-notifications p {
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
        color: var(--white);
    }

    .no-notifications span {
        font-size: 0.9rem;
    }
            /* Mobile responsiveness for notifications */
        @media (max-width: 768px) {
            .notifications-panel {
                width: 95%;
                padding: 1rem;
            }

            .notifications-header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .notifications-title {
                font-size: 1rem;
            }

            .notification-item {
                padding: 10px;
            }

            .notification-icon {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        /* Community Groups & Interest Hubs */
        .community-groups-section {
            background: var(--glass-black);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-blue);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-light);
        }

        .section-header h3 {
            color: var(--white);
            font-size: 1.3rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-header h3 i {
            color: var(--blue);
        }

        .create-group-btn {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .create-group-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 213, 255, 0.4);
        }

        .groups-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .group-card {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .group-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-color: var(--glass-blue);
        }

        .group-card.featured {
            border-color: var(--pink);
            background: linear-gradient(145deg, var(--card-background), rgba(255, 46, 146, 0.1));
        }

        .group-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 1rem;
        }

        .group-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--blue), var(--pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            flex-shrink: 0;
        }

        .group-info {
            flex: 1;
            min-width: 0;
        }

        .group-info h4 {
            color: var(--white);
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0 0 4px 0;
        }

        .group-info p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin: 0 0 6px 0;
            line-height: 1.4;
        }

        .member-count {
            color: var(--blue);
            font-size: 0.8rem;
            font-weight: 500;
        }

        .group-status {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            text-align: center;
            text-transform: uppercase;
        }

        .status-badge.trending {
            background: rgba(255, 46, 146, 0.2);
            color: var(--pink);
            border: 1px solid rgba(255, 46, 146, 0.3);
        }

        .status-badge.active {
            background: rgba(76, 175, 80, 0.2);
            color: var(--status-online);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-badge.new {
            background: rgba(0, 213, 255, 0.2);
            color: var(--blue);
            border: 1px solid rgba(0, 213, 255, 0.3);
        }

        .group-actions {
            display: flex;
            gap: 8px;
        }

        .join-group-btn, .group-preview-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .join-group-btn {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            color: white;
            border: none;
        }

        .join-group-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 213, 255, 0.4);
        }

        .group-preview-btn {
            background: transparent;
            color: var(--text-light);
        }

        .group-preview-btn:hover {
            background: var(--glass-blue);
            color: var(--white);
            border-color: var(--blue);
        }

        .interests-tags {
            border-top: 1px solid var(--border-light);
            padding-top: 1rem;
        }

        .interests-tags h4 {
            color: var(--white);
            font-size: 1rem;
            margin: 0 0 1rem 0;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .interest-tag {
            padding: 6px 12px;
            background: var(--glass-blue);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            color: var(--text-light);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .interest-tag:hover {
            background: var(--glass-blue);
            border-color: var(--blue);
            color: var(--white);
        }

        .interest-tag.active {
            background: var(--blue);
            border-color: var(--blue);
            color: white;
        }

        .add-interest-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--glass-blue);
            border: 1px dashed var(--border-light);
            color: var(--blue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .add-interest-btn:hover {
            background: var(--blue);
            color: white;
            border-color: var(--blue);
        }

        /* Mobile responsiveness for community groups */
        @media (max-width: 768px) {
            .community-groups-section {
                width: 95%;
                padding: 1rem;
            }

            .section-header {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }

            .groups-grid {
                grid-template-columns: 1fr;
                gap: 0.8rem;
            }

            .group-card {
                padding: 0.8rem;
            }

            .group-icon {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .group-info h4 {
                font-size: 1rem;
            }

            .group-actions {
                flex-direction: column;
            }
        }

        /* AI-Powered Smart Feed */
        .smart-feed-section {
            background: var(--glass-black);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-blue);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
        }

        .feed-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .feed-algorithm-select {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .feed-algorithm-select:hover {
            border-color: var(--blue);
        }

        .feed-algorithm-select:focus {
            outline: none;
            border-color: var(--blue);
            box-shadow: 0 0 0 2px rgba(0, 213, 255, 0.2);
        }

        .refresh-feed-btn {
            background: var(--glass-blue);
            border: 1px solid var(--border-light);
            color: var(--blue);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }

        .refresh-feed-btn:hover {
            background: var(--blue);
            color: white;
            transform: rotate(180deg);
        }

        .refresh-feed-btn.loading {
            animation: spin 1s linear infinite;
        }

        .feed-insights {
            margin: 1.5rem 0;
        }

        .insight-card {
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.1));
            border: 1px solid var(--glass-blue);
            border-radius: 12px;
            padding: 1rem;
        }

        .insight-card i {
            font-size: 1.5rem;
            color: var(--blue);
        }

        .insight-content h4 {
            color: var(--white);
            font-size: 1rem;
            margin: 0 0 4px 0;
        }

        .insight-content p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.4;
        }

        .smart-filters {
            margin: 1.5rem 0;
        }

        .filter-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .filter-tag {
            padding: 6px 12px;
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            color: var(--text-light);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-tag:hover {
            background: var(--glass-blue);
            border-color: var(--blue);
            color: var(--white);
        }

        .filter-tag.active {
            background: var(--blue);
            border-color: var(--blue);
            color: white;
        }

        .ai-recommendations {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1.5rem;
        }

        .recommendation-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }

        .recommendation-header h4 {
            color: var(--white);
            font-size: 1rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-header h4 i {
            color: var(--pink);
        }

        .ai-status {
            background: var(--glass-blue);
            color: var(--blue);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .ai-status.learning {
            animation: pulse 2s infinite;
        }

        .ai-status.ready {
            background: rgba(76, 175, 80, 0.2);
            color: var(--status-online);
        }

        .recommendation-content p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin: 0 0 12px 0;
        }

        .recommendation-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .recommendation-list li {
            color: var(--white);
            font-size: 0.9rem;
            padding: 6px 0;
            border-left: 2px solid var(--blue);
            padding-left: 12px;
            margin-bottom: 4px;
        }

        .recommendation-list li:last-child {
            margin-bottom: 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Mobile responsiveness for smart feed */
        @media (max-width: 768px) {
            .smart-feed-section {
                width: 95%;
                padding: 1rem;
            }

            .feed-controls {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }

            .feed-algorithm-select {
                width: 100%;
            }

            .filter-tags {
                gap: 6px;
            }

            .filter-tag {
                padding: 5px 10px;
                font-size: 0.8rem;
            }

            .insight-card {
                padding: 0.8rem;
            }

            .insight-card i {
                font-size: 1.2rem;
            }
        }

        /* Pull-to-Refresh Indicator */
        .pull-to-refresh-indicator {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: var(--glass-black);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-blue);
            border-radius: 0 0 20px 20px;
            padding: 15px 25px;
            color: var(--white);
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            opacity: 0;
        }

        .pull-to-refresh-indicator i {
            color: var(--blue);
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
            60% { transform: translateY(-3px); }
        }
        /* Feature Toggle Section */
        .feature-toggle-section {
            background: var(--glass-black);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-blue);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
        }

        .toggle-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .toggle-header h3 {
            color: var(--white);
            font-size: 1.3rem;
            font-weight: 600;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .toggle-header h3 i {
            color: var(--blue);
        }

        .toggle-header p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin: 0;
        }

        .toggle-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        .toggle-feature-btn {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            color: var(--white);
        }

        .toggle-feature-btn:hover {
            background: var(--glass-blue);
            border-color: var(--blue);
            transform: translateY(-2px);
        }

        .toggle-feature-btn.active {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            border-color: var(--blue);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 213, 255, 0.4);
        }

        .toggle-feature-btn i {
            font-size: 1.5rem;
            color: var(--blue);
        }

        .toggle-feature-btn.active i {
            color: white;
        }

        .toggle-feature-btn span {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .toggle-status {
            background: var(--glass-blue);
            color: var(--blue);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .toggle-feature-btn.active .toggle-status {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* Feature Recommendations */
        .feature-recommendations {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-light);
        }

        .recommendation-header {
            margin-bottom: 1rem;
        }

        .recommendation-header h4 {
            color: var(--white);
            font-size: 1rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-header h4 i {
            color: var(--pink);
        }

        .recommendation-content p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin: 0 0 12px 0;
        }

        .recommendation-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .recommendation-item {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s ease;
        }

        .recommendation-item:hover {
            background: var(--glass-blue);
            border-color: var(--blue);
        }

        .recommendation-item i {
            color: var(--blue);
            font-size: 1rem;
        }

        .recommendation-item .recommendation-text {
            flex: 1;
            color: var(--white);
            font-size: 0.85rem;
        }

        .recommendation-item .recommendation-action {
            background: var(--blue);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .recommendation-item .recommendation-action:hover {
            background: var(--accent-color-dark);
            transform: scale(1.05);
        }

        /* Hidden class for sections */
        .hidden {
            display: none !important;
        }

        /* Mobile Device Specific Styles */
        .mobile-device .quick-actions-toggle {
            box-shadow: 0 6px 20px rgba(0, 213, 255, 0.5), 0 6px 20px rgba(255, 46, 146, 0.5);
        }

        .mobile-device .notifications-panel {
            border-radius: 15px;
        }

        .mobile-device .community-groups-section {
            border-radius: 15px;
        }

        .mobile-device .smart-feed-section {
            border-radius: 15px;
        }

        /* Enhanced Mobile Touch Improvements */
        .mobile-device .group-card,
        .mobile-device .notification-item,
        .mobile-device .quick-action-item {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .mobile-device .filter-tag,
        .mobile-device .interest-tag {
            min-height: 44px; /* iOS touch target minimum */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Mobile responsiveness for feature toggle */
        @media (max-width: 768px) {
            .feature-toggle-section {
                width: 95%;
                padding: 1rem;
            }

            .toggle-buttons {
                grid-template-columns: 1fr;
                gap: 0.8rem;
            }

            .toggle-feature-btn {
                padding: 0.8rem;
            }

            .toggle-feature-btn i {
                font-size: 1.3rem;
            }
        }
                 /* Donation Widget (header button uses existing .theme-switcher-btn styles) */
         .donation-modal .modal-content { max-width: 460px; background: var(--card-background); color: var(--white); border: 1px solid var(--border-light); border-radius: 16px; }
         .donation-dropdown { position: absolute; top: 120%; right: 0; min-width: 320px; background: var(--card-background); border: 1px solid var(--border-light); border-radius: 14px; padding: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.3); z-index: 20; }
         .donation-list { display: grid; gap: 10px; margin-top: 8px; }
         .donation-item { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; padding: 10px; border: 1px solid var(--border-light); border-radius: 10px; background: rgba(255,255,255,.03); }
         .donation-item .label { opacity: .75; font-size: .85rem; }
         .donation-item .value { word-break: break-all; font-weight: 600; }
         .donation-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }
         .copy-btn { padding: 6px 10px; border-radius: 8px; background: var(--button-background); color: #fff; border: none; cursor: pointer; }
         .copy-btn:hover { filter: brightness(1.05); }
    </style>
</head>
<body class="theme-dark-mode">

    <header>
        <div class="header-content-wrapper">
            <!-- Sidebar Toggle Button in Header -->
            <button id="sidebarToggleFab" aria-label="Toggle Navigation">
                <i class="fas fa-bars"></i>
            </button>

            <!-- Removed Header Navigation (Home, Profile) -->
            <div class="user-profile-header" style="display:flex;align-items:center;gap:10px;">
                <div style="display:flex;align-items:center;gap:8px;margin-right:6px; position: relative;">
                    <button id="headerSupportBtn" class="theme-switcher-btn" title="Support" aria-label="Donate"><i class="fas fa-seedling"></i></button>
                    <span style="font-size:0.85rem;opacity:.8;">Support</span>
                    <div id="donationDropdown" class="donation-dropdown" aria-label="Donation Panel" style="display:none;">
                        <div class="donation-list">
                            <div class="donation-item">
                                <div class="label">Bank Name</div>
                                <div class="value" id="donationBankName"></div>
                                <button class="copy-btn" data-copy="donationBankName"><i class="fas fa-copy"></i></button>
                            </div>
                            <div class="donation-item">
                                <div class="label">Account Name</div>
                                <div class="value" id="donationAccountName"></div>
                                <button class="copy-btn" data-copy="donationAccountName"><i class="fas fa-copy"></i></button>
                            </div>
                            <div class="donation-item">
                                <div class="label">Account Number</div>
                                <div class="value" id="donationAccountNumber"></div>
                                <button class="copy-btn" data-copy="donationAccountNumber"><i class="fas fa-copy"></i></button>
                            </div>
                            <div class="donation-item">
                                <div class="label">SWIFT / IBAN</div>
                                <div class="value" id="donationSwift"></div>
                                <button class="copy-btn" data-copy="donationSwift"><i class="fas fa-copy"></i></button>
                            </div>
                            <div class="donation-item">
                                <div class="label">Note</div>
                                <div class="value" id="donationNote"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Theme Switcher Button -->
                <button id="themeSwitcherBtn" class="theme-switcher-btn" aria-label="Switch Theme">
                    <i class="fas fa-key"></i>
                </button>
                <!-- Admin Icon Link (visible only to admin) -->
                <a href="/Admin.html" id="adminIconLink" aria-label="Admin Dashboard" style="display: none;">
                    <i class="fas fa-user-cog"></i>
                </a>
                <!-- Notification Icon with Badge -->
                <div class="notification-icon-wrapper" style="position:relative;">
                    <button id="headerNotificationsBtn" class="header-notification-btn" aria-label="Toggle Notifications">
                        <i class="fas fa-bell"></i>
                        <span class="notification-badge" id="headerNotificationCount">0</span>
                    </button>
                </div>
                <!-- Profile Link with Picture and Name -->
                <a href="./Profile.html" id="profileLink" aria-label="View Profile" style="display:flex;align-items:center;gap:8px;">
                    <img id="headerProfilePic" src="" alt="Profile Picture" style="display:none;width:32px;height:32px;border-radius:50%;object-fit:cover;border:1px solid var(--border-light);">
                    <i id="headerAvatarIcon" class="fas fa-user-circle" role="img" aria-label="User Avatar" style="font-size:28px;"></i>
                    <span id="headerDisplayName"></span>
                </a>
            </div>
        </div>
    </header>

    <div class="brand-banner">
        <div class="brand-glow"></div>
        <div class="brand-title">JCHAT</div>
        <div class="brand-sub">Modern social chat platform with communities, JCoins and more</div>
    </div>
    <main>
        <div class="content-wrapper">
            <!-- Daily Inspiration Section -->
            <div class="daily-inspiration-section">
                <h2>Daily Inspiration</h2>
                <p id="inspirationQuote" class="quote-text"></p>
                <p id="inspirationAuthor" class="quote-author"></p>
                <div class="inspiration-actions">
                    <button id="sharePostInspirationButton" class="inspiration-action-button" disabled aria-label="Share Inspiration as Post">
                        <i class="fas fa-share-alt"></i> Share / Post
                    </button>
                    <button id="customizeInspirationButton" class="inspiration-action-button" disabled aria-label="Customize Inspiration Type">
                        <i class="fas fa-cog"></i> Customize Inspiration
                    </button>
                    <!-- NEW: Daily Bonus Button -->
                    <button id="claimDailyBonusButton" class="inspiration-action-button" disabled aria-label="Claim Daily Bonus">
                        <span class="button-text"><i class="fas fa-calendar-check"></i> Claim Daily Bonus</span>
                        <div class="button-loader" role="status" aria-label="Loading"></div>
                    </button>
                            </div>
            
            <!-- Share Inspiration Modal -->
            <div id="shareInspirationModal" class="modal-overlay share-modal" role="dialog" aria-modal="true" aria-labelledby="shareInspirationTitle" style="display:none;">
                <div class="modal-content">
                    <h3 id="shareInspirationTitle">Share Inspiration</h3>
                    <div id="sharePreview" style="padding:10px;border:1px dashed var(--border-light);border-radius:10px;color:var(--white);">
                        <div id="sharePreviewQuote" style="font-style:italic"></div>
                        <div id="sharePreviewAuthor" style="opacity:0.8;margin-top:6px"></div>
                    </div>
                    <div class="share-options" style="display:flex;flex-direction:column;gap:10px;margin-top:10px;">
                        <button id="copyInspirationBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-copy"></i> Copy to Clipboard</button>
                        <div id="friendPicker" style="border:1px solid var(--border-light);border-radius:10px;padding:8px;display:none;max-height:200px;overflow:auto;"></div>
                        <button id="sendToFriendBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-paper-plane"></i> Send to Friend</button>
                        <button id="postInspirationBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-feather-alt"></i> Post It</button>
                        <button id="saveInspirationBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-bookmark"></i> Save Inspiration</button>
                    </div>
                    <div class="button-group" style="margin-top:12px;">
                        <button id="closeShareModalBtn" class="modal-button cancel-button">Close</button>
                    </div>
                </div>
            </div>
            </div>

            <!-- Quick Actions Floating Menu -->
            <div class="quick-actions-menu" id="quickActionsMenu">
                <button class="quick-actions-toggle" id="quickActionsToggle" aria-label="Quick Actions">
                    <i class="fas fa-plus"></i>
                </button>
                <div class="quick-actions-dropdown" id="quickActionsDropdown">
                    <div class="quick-action-item" data-action="create-post">
                        <i class="fas fa-edit"></i>
                        <span>Create Post</span>
                    </div>
                    <div class="quick-action-item" data-action="share-inspiration">
                        <i class="fas fa-share-alt"></i>
                        <span>Share Inspiration</span>
                    </div>
                    <div class="quick-action-item" data-action="daily-bonus">
                        <i class="fas fa-gift"></i>
                        <span>Daily Bonus</span>
                    </div>
                    <div class="quick-action-item" data-action="communities">
                        <i class="fas fa-users"></i>
                        <span>Communities</span>
                        <div class="quick-action-status" id="quickCommunitiesStatus"></div>
                    </div>
                    <div class="quick-action-item" data-action="ai-feed">
                        <i class="fas fa-brain"></i>
                        <span>AI Smart Feed</span>
                        <div class="quick-action-status" id="quickAiFeedStatus"></div>
                    </div>
                    <div class="quick-action-item" data-action="mobile-features">
                        <i class="fas fa-mobile-alt"></i>
                        <span>Mobile Features</span>
                        <div class="quick-action-status" id="quickMobileStatus"></div>
                    </div>
                    <div class="quick-action-item" data-action="profile">
                        <i class="fas fa-user"></i>
                        <span>Profile</span>
                    </div>
                    <div class="quick-action-item" data-action="wallet">
                        <i class="fas fa-wallet"></i>
                        <span>Wallet</span>
                    </div>
                    <div class="quick-action-item" data-action="settings">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </div>
                </div>
            </div>

            <!-- Smart Notifications Panel -->
            <div class="notifications-panel" id="notificationsPanel">
                <div class="notifications-header">
                    <div class="notifications-title">
                        <i class="fas fa-bell"></i>
                        <span>Notifications</span>
                        <span class="notifications-count" id="notificationsCount">0</span>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <button class="clear-notifications-btn" id="saveNotificationsBtn" title="Save" aria-label="Save Notifications"><i class="fas fa-save"></i></button>
                        <button class="clear-notifications-btn" id="downloadNotificationsBtn" title="Download" aria-label="Download Notifications"><i class="fas fa-download"></i></button>
                        <button class="clear-notifications-btn" id="shareNotificationsBtn" title="Share" aria-label="Share Notifications"><i class="fas fa-share-alt"></i></button>
                        <button class="clear-notifications-btn" id="clearNotificationsBtn" aria-label="Clear All Notifications">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                <div class="notifications-list" id="notificationsList">
                    <div class="no-notifications">
                        <i class="fas fa-inbox"></i>
                        <p>No notifications yet</p>
                        <span>We'll notify you about important updates</span>
                    </div>
                </div>
            </div>

            <!-- Feature Toggle Section -->
            <div class="feature-toggle-section" id="featureToggleSection">
                <div class="toggle-header">
                    <h3><i class="fas fa-cogs"></i> Advanced Features</h3>
                    <p>Toggle these features on/off as needed</p>
                </div>
                
                <div class="toggle-buttons">
                    <button class="toggle-feature-btn" id="toggleCommunityBtn" data-feature="community">
                        <i class="fas fa-users"></i>
                        <span>Communities</span>
                        <div class="toggle-status">OFF</div>
                    </button>
                    
                    <button class="toggle-feature-btn" id="toggleSmartFeedBtn" data-feature="smartFeed">
                        <i class="fas fa-brain"></i>
                        <span>AI Smart Feed</span>
                        <div class="toggle-status">OFF</div>
                    </button>
                    
                    <button class="toggle-feature-btn" id="toggleMobileFeaturesBtn" data-feature="mobileFeatures">
                        <i class="fas fa-mobile-alt"></i>
                        <span>Mobile Features</span>
                        <div class="toggle-status">OFF</div>
                    </button>
                </div>
                
                <div class="feature-recommendations" id="featureRecommendations">
                    <div class="recommendation-header">
                        <h4><i class="fas fa-lightbulb"></i> Smart Recommendations</h4>
                    </div>
                    <div class="recommendation-content">
                        <p>Based on your activity, we recommend:</p>
                        <div class="recommendation-items" id="recommendationItems">
                            <!-- Dynamic recommendations will be added here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Community Groups & Interest Hubs (Hidden by default) -->
            <div class="community-groups-section hidden" id="communityGroupsSection">
                <div class="section-header">
                    <h3><i class="fas fa-users"></i> Communities & Interests</h3>
                    <button class="create-group-btn" id="createGroupBtn" aria-label="Create New Group">
                        <i class="fas fa-plus"></i> Create Group
                    </button>
                    <a href="/Groups.html" class="create-group-btn" aria-label="Open Groups" style="margin-left:auto;display:inline-flex;align-items:center;gap:6px;">
                        <i class="fas fa-external-link-alt"></i> Open Groups
                    </a>
                </div>
                
                <div class="groups-grid" id="groupsGrid"></div>

                <div class="interests-tags" id="interestsTags">
                    <h4>Your Interests</h4>
                    <div class="tags-container">
                        <span class="interest-tag active">Gaming</span>
                        <span class="interest-tag">Technology</span>
                        <span class="interest-tag">Music</span>
                        <span class="interest-tag">Sports</span>
                        <span class="interest-tag">Travel</span>
                        <button class="add-interest-btn" id="addInterestBtn">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- AI-Powered Smart Feed (Hidden by default) -->
            <div class="smart-feed-section hidden" id="smartFeedSection">
                <div class="section-header">
                    <h3><i class="fas fa-brain"></i> Smart Feed</h3>
                    <div class="feed-controls">
                        <select id="feedAlgorithm" class="feed-algorithm-select">
                            <option value="smart">Smart Recommendations</option>
                            <option value="recent">Most Recent</option>
                            <option value="popular">Most Popular</option>
                            <option value="friends">Friends Only</option>
                            <option value="interests">Interest-Based</option>
                        </select>
                        <button class="refresh-feed-btn" id="refreshFeedBtn" aria-label="Refresh Feed">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>
                
                <div class="feed-insights" id="feedInsights">
                    <div class="insight-card">
                        <i class="fas fa-lightbulb"></i>
                        <div class="insight-content">
                            <h4>Feed Insights</h4>
                            <p>AI is learning your preferences to show relevant content</p>
                        </div>
                    </div>
                </div>

                <div class="smart-filters" id="smartFilters">
                    <div class="filter-tags">
                        <span class="filter-tag active" data-filter="all">All Posts</span>
                        <span class="filter-tag" data-filter="text">Text Only</span>
                        <span class="filter-tag" data-filter="media">Media Posts</span>
                        <span class="filter-tag" data-filter="polls">Polls</span>
                        <span class="filter-tag" data-filter="inspiration">Inspiration</span>
                    </div>
                </div>

                <div class="ai-recommendations" id="aiRecommendations">
                    <div class="recommendation-header">
                        <h4><i class="fas fa-magic"></i> AI Recommendations</h4>
                        <span class="ai-status">Learning...</span>
                    </div>
                    <div class="recommendation-content">
                        <p>Based on your interests and activity, we recommend:</p>
                        <ul class="recommendation-list">
                            <li>Check out the Gaming Enthusiasts community</li>
                            <li>Share your daily inspiration</li>
                            <li>Connect with tech developers</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Post Creation Section -->
            <div class="post-creation-section" id="postCreationSection">
                <h3>Create New Post</h3>
                <textarea id="postContent" placeholder="What's on your mind?" maxlength="50000" disabled aria-label="Post Content"></textarea>
                <div class="media-upload-area">
                    <label for="postMediaUpload" class="file-input-label" aria-label="Add Media to Post">
                        <i class="fas fa-image"></i> Add Media
                    </label>
                    <input type="file" id="postMediaUpload" accept="image/*,video/*" disabled>
                    <img id="mediaImagePreview" class="media-preview" src="" alt="Image Preview" style="display: none;">
                    <video id="mediaVideoPreview" class="media-preview" src="" controls style="display: none;"></video>
                </div>
                <div style="margin:8px 0; display:flex; align-items:center; gap:10px;">
                    <label style="display:flex; align-items:center; gap:6px;">
                        <input type="checkbox" id="addPollCheckbox"> Add Poll
                    </label>
                    <div id="pollComposer" style="display:none; flex-direction:column; gap:6px; width:100%;">
                        <input type="text" class="poll-option-input" placeholder="Option 1" maxlength="100">
                        <input type="text" class="poll-option-input" placeholder="Option 2" maxlength="100">
                        <button id="addPollOptionBtn" class="post-control-button" type="button" style="width:max-content;">Add Option</button>
                    </div>
                </div>
                <div class="post-actions">
                    <button id="createPostButton" class="post-button" disabled aria-label="Create Post">
                        <span class="button-text">Post</span>
                        <div class="button-loader" role="status" aria-label="Loading"></div>
                    </button>
                </div>
            </div>


            <div id="trendingHashtags" style="margin:8px 0;color:var(--text-light);font-size:0.9rem;"></div>

            <!-- Engagement Panel -->
            <div class="engagement-panel" style="display:none;" id="engagementPanel">
                <div class="engage-card" id="streakCard">
                    <div class="engage-title">Daily Streak</div>
                    <div id="streakInfo" style="color:var(--text-light);">Loading streak...</div>
                </div>
                <div class="engage-card" id="questsCard">
                    <div class="engage-title">Weekly Quests</div>
                    <div class="quests-list" id="questsList"></div>
                </div>
                <div class="engage-card" id="spinCard">
                    <div class="engage-title">Daily Spin</div>
                    <button class="spin-button" id="spinNowButton"><i class="fas fa-sync"></i> Spin Now</button>
                    <div id="spinStatus" style="color:var(--text-light); margin-top:6px;"></div>
                </div>
                <div class="engage-card" id="storiesCard">
                    <div style="display:flex;align-items:center;justify-content:space-between;">
                        <div class="engage-title">Stories</div>
                        <button class="add-story-button" id="addStoryButton"><i class="fas fa-plus"></i> Add Story</button>
                        <input type="file" id="storyUploadInput" accept="image/*,video/*" style="display:none;">
                    </div>
                    <div class="stories-bar" id="storiesBar"></div>
                </div>
            </div>

            <!-- Posts Feed Section -->
            <div class="posts-feed-section" id="postsFeed">
                <!-- Posts will be loaded here dynamically -->
                <p style="text-align: center; color: var(--text-light);" id="loadingPostsMessage">Loading posts...</p>
            </div>
        </div>
    </main>



    <!-- Customization Modal -->
    <div id="customizeInspirationModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="customizeInspirationModalTitle">
        <div class="modal-content">
            <h3 id="customizeInspirationModalTitle">Customize Inspiration Type</h3>
            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="motivational" checked aria-label="Motivational Inspiration">
                    Motivational
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="peaceful" aria-label="Peaceful Inspiration">
                    Peaceful
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="funny" aria-label="Funny Inspiration">
                    Funny
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="wisdom" aria-label="Wisdom Inspiration">
                    Wisdom
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="love" aria-label="Love Inspiration">
                    Love
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="off" aria-label="Turn Off Inspiration">
                    Off
                </label>
            </div>
            <div class="button-group">
                <button id="cancelCustomize" class="modal-button cancel-button" aria-label="Cancel Customization">Cancel</button>
                <button id="saveCustomize" class="modal-button save-button" aria-label="Save Customization">Save</button>
            </div>
        </div>
    </div>

    <!-- Filters Modal -->
    <div id="filtersModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="filtersModalTitle" style="display:none;">
        <div class="modal-content">
            <h3 id="filtersModalTitle">Feed Filters</h3>
            <div class="input-group" style="display:flex;gap:8px;flex-wrap:wrap;">
                <label><input type="radio" name="filterType" value="all" checked> All</label>
                <label><input type="radio" name="filterType" value="text"> Text</label>
                <label><input type="radio" name="filterType" value="image"> Images</label>
                <label><input type="radio" name="filterType" value="video"> Videos</label>
            </div>
            <div class="input-group" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="filterSavedOnly"> Saved only</label>
                <input type="date" id="filterDateFrom" placeholder="From">
                <input type="date" id="filterDateTo" placeholder="To">
            </div>
            <div class="button-group" style="display:flex;gap:10px;justify-content:flex-end;">
                <button id="resetFiltersBtn" class="modal-button cancel-button">Reset</button>
                <button id="applyFiltersBtn" class="modal-button confirm-button">Apply</button>
            </div>
        </div>
    </div>

    <!-- Edit Post Modal -->
    <div id="editPostModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="editPostModalTitle">
        <div class="modal-content">
            <h3 id="editPostModalTitle">Edit Post</h3>
            <div class="input-group">
                <label for="editPostContent">Post Content:</label>
                <textarea id="editPostContent" maxlength="500" aria-label="Edit Post Content"></textarea>
            </div>
            <div class="media-upload-area">
                <label for="editPostMediaUpload" class="file-input-label" aria-label="Change Media for Post">
                    <i class="fas fa-image"></i> Change Media
                </label>
                <input type="file" id="editPostMediaUpload" accept="image/*,video/*">
                <img id="editMediaImagePreview" class="media-preview" src="" alt="Image Preview" style="display: none;">
                <video id="editMediaVideoPreview" class="media-preview" src="" controls style="display: none;"></video>
                <button id="removeEditMedia" class="modal-button cancel-button" style="display: none;" aria-label="Remove Media from Post">Remove Media</button>
            </div>
            <div class="button-group">
                <button id="cancelEditPost" class="modal-button cancel-button" aria-label="Cancel Editing">Cancel</button>
                <button id="saveEditedPost" class="modal-button save-button" aria-label="Save Edited Post">
                    <span class="button-text">Save Changes</span>
                    <div class="button-loader" role="status" aria-label="Loading"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="confirmationTitle">
        <div class="modal-content">
            <h3 id="confirmationTitle">Confirm Action</h3>
            <p id="confirmationMessage">Are you sure you want to proceed with this action?</p>
            <div class="button-group">
                <button id="confirmCancelButton" class="modal-button cancel-button" aria-label="Cancel">Cancel</button>
                <button id="confirmProceedButton" class="modal-button confirm-button" aria-label="Proceed">Proceed</button>
            </div>
        </div>
    </div>

    <!-- Custom Message Box -->
    <div id="messageBox" role="alert" aria-live="polite"></div>

    <!-- NEW: Maintenance Mode Overlay -->
    <div id="maintenanceOverlay" role="dialog" aria-modal="true" aria-labelledby="maintenanceOverlayTitle">
        <i class="fas fa-tools" role="img" aria-label="Maintenance Icon"></i>
        <h2 id="maintenanceOverlayTitle">Maintenance Mode</h2>
        <p id="maintenanceAnnouncementText">JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!</p>
    </div>

    <!-- Call Overlay (NEW) -->
    <div id="callOverlay" role="dialog" aria-modal="true" aria-labelledby="callStatusText">
        <div class="video-streams">
            <video id="remoteVideo" autoplay playsinline aria-label="Remote Video Stream"></video>
            <video id="localVideo" autoplay playsinline muted aria-label="Local Video Stream"></video>
        </div>
        <i id="callStatusIcon" class="fas fa-phone" role="img" aria-label="Call Status Icon"></i>
        <p id="callStatusText" class="call-status-text">Calling...</p>
        <p id="callTimer" class="call-timer" style="display: none;" aria-live="polite">00:00</p>
        <div class="call-actions" id="callActions">
            <button id="acceptCallBtn" class="accept-call-btn" style="display: none;" aria-label="Accept Call"><i class="fas fa-phone"></i></button>
            <button id="declineCallBtn" class="decline-call-btn" style="display: none;" aria-label="Decline Call"><i class="fas fa-phone-slash"></i></button>
            <button id="toggleMuteBtn" class="toggle-mute-btn" style="display: none;" title="Mute/Unmute" aria-label="Toggle Mute"><i class="fas fa-microphone"></i></button>
            <button id="toggleVideoBtn" class="toggle-video-btn" style="display: none;" title="Turn Video On/Off" aria-label="Toggle Video"><i class="fas fa-video"></i></button>
            <button id="endCallBtn" class="end-call-btn" style="display: none;" aria-label="End Call"><i class="fas fa-phone-slash"></i></button>
        </div>
    </div>
    <!-- Sidebar Navigation -->
    <aside id="sidebarNav" class="sidebar-hidden" role="navigation" aria-label="Main Navigation">
        <div class="sidebar-header">
            <span class="sidebar-title">JCHAT Menu</span>
            <button id="sidebarCloseBtn" aria-label="Close Menu">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="sidebar-links">
            <a href="/home.html" class="sidebar-nav-item active" aria-current="page">
                <i class="fas fa-home"></i>
                <span>Home</span>
            </a>
            <a href="/profile.html" class="sidebar-nav-item">
                <i class="fas fa-user"></i>
                <span>Profile</span>
            </a>
            <a href="/Private_Chat.html" class="sidebar-nav-item" id="chatLink">
                <i class="fas fa-comment-dots"></i>
                <span>Chat</span>
            </a>
            <a href="/find_friends.html" class="sidebar-nav-item" id="findFriendsLink">
                <i class="fas fa-users"></i>
                <span>Users</span>
            </a>
            <a href="/friends.html" class="sidebar-nav-item" id="friendsLink">
                <i class="fas fa-user-friends"></i>
                <span>Friends</span>
            </a>
            <a href="/groups.html" class="sidebar-nav-item" id="groupsLink">
                <i class="fas fa-layer-group"></i> <!-- New Groups icon -->
                <span>Groups</span>
            </a>
            <a href="/settings.html" class="sidebar-nav-item">
                <i class="fas fa-cog"></i>
                <span>Settings</span>
            </a>
            <a href="/About_Us.html" class="sidebar-nav-item">
                <i class="fas fa-globe"></i>
                <span>About Us</span>
            </a>
            <a href="/solution_center.html" class="sidebar-nav-item">
                <i class="fas fa-question-circle"></i>
                <span>Solution Center</span>
            </a>
            <!-- NEW: Guide Link - moved inside sidebar-links -->
            <a href="/guide.html" class="sidebar-nav-item">
                <i class="fas fa-book"></i>
                <span>Guide</span>
                </a>
            <!-- NEW: Guide Link - moved inside sidebar-links -->
            <a href="/Community_guidelines.html" class="sidebar-nav-item">
                <i class="fas fa-exclamation-triangle"></i>
                <span>Community Guidelines</span>
            </a>
            <!-- New: Logout Link in Sidebar -->
            <a href="#" id="sidebarLogoutLink" class="sidebar-nav-item">
                <i class="fas fa-sign-out-alt"></i>
                <span>Logout</span>
            </a>
        </div>
    </aside>

    <!-- Smart Scroll Button -->
    <button id="smartScrollBtn" aria-label="Smart Scroll"><i class="fas fa-arrow-down"></i><span class="label">Bottom</span></button>
    <!-- Donation Modal (reuses modal styles) -->
    <div id="donationModal" class="modal-overlay donation-modal" role="dialog" aria-modal="true" aria-labelledby="donationTitle" style="display:none;">
        <div class="modal-content">
            <h3 id="donationTitle">Support Development</h3>
            <div class="donation-list">
                <div class="donation-item">
                    <div class="label">Bank Name</div>
                    <div class="value" id="donationBankName"></div>
                    <button class="copy-btn" data-copy="donationBankName"><i class="fas fa-copy"></i></button>
                </div>
                <div class="donation-item">
                    <div class="label">Account Name</div>
                    <div class="value" id="donationAccountName"></div>
                    <button class="copy-btn" data-copy="donationAccountName"><i class="fas fa-copy"></i></button>
                </div>
                <div class="donation-item">
                    <div class="label">Account Number</div>
                    <div class="value" id="donationAccountNumber"></div>
                    <button class="copy-btn" data-copy="donationAccountNumber"><i class="fas fa-copy"></i></button>
                </div>
                <div class="donation-item">
                    <div class="label">SWIFT / IBAN</div>
                    <div class="value" id="donationSwift"></div>
                    <button class="copy-btn" data-copy="donationSwift"><i class="fas fa-copy"></i></button>
                </div>
                <div class="donation-item">
                    <div class="label">Note</div>
                    <div class="value" id="donationNote"></div>
                </div>
            </div>
            <div class="donation-actions">
                <button id="donationCloseBtn" class="modal-button cancel-button">Close</button>
            </div>
        </div>
    </div>

    <!-- Compact Story Viewer -->
    <div id="storyViewer" aria-live="polite">
        <div class="viewer-card">
            <div class="viewer-header">
                <div class="viewer-title" id="storyViewerTitle">Story</div>
                <button class="viewer-close" id="closeStoryViewer" aria-label="Close"><i class="fas fa-times"></i></button>
            </div>
            <div class="viewer-media">
                <img id="storyImage" alt="story image" />
                <video id="storyVideo" controls playsinline></video>
            </div>
            <div class="viewer-footer">
                <button id="prevStoryBtn"><i class="fas fa-chevron-left"></i> Prev</button>
                <button id="nextStoryBtn">Next <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>
    <script type="module">
        // console.debug("Home.html script started.");

        // Import Firebase modules (Updated to v11.8.0 - Latest Stable)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, orderBy, where, getDocs, addDoc, runTransaction, writeBatch, serverTimestamp, arrayUnion, arrayRemove, onSnapshot } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-firestore.js";

        // --- Firebase & Canvas Environment Configuration ---
        // Firebase configuration, dynamically loaded from Canvas environment variables if available.
        // Provides fallback values for local development if environment variables are not set.
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: typeof __firebase_api_key !== 'undefined' ? __firebase_api_key : "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
            authDomain: typeof __firebase_auth_domain !== 'undefined' ? __firebase_auth_domain : "jchat-1.firebaseapp.com",
            projectId: typeof __firebase_project_id !== 'undefined' ? __firebase_project_id : "jchat-1",
            storageBucket: typeof __firebase_storage_bucket !== 'undefined' ? __firebase_storage_bucket : "jchat-1.firebasestorage.app",
            messagingSenderId: "328479683167",
            appId: typeof __firebase_app_id !== 'undefined' ? __firebase_app_id : "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
            measurementId: typeof __firebase_measurement_id !== 'undefined' ? __firebase_measurement_id : "G-S6Z9GG0R9P"
        };
        // Application ID, dynamically loaded from Canvas environment or defaults for local.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // Initial authentication token for Canvas environment.
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Cloudinary Configuration for media uploads.
        const cloudinaryConfig = {
            cloudName: "dxld01rcp",
            uploadPreset: "Storage_preset"
        };

        // Enhanced Client-Side Features (Updated)
        const JCHAT_VERSION = "2.1.0";
        const CACHE_VERSION = "jchat-v2.1.0";
        
        // Offline Detection
        let isOnline = navigator.onLine;
        window.addEventListener('online', () => {
            isOnline = true;
            showMessageBox('🟢 Connection restored! Back online.', 'success');
            // console.debug('Back online');
        });
        
        window.addEventListener('offline', () => {
            isOnline = false;
            showMessageBox('🔴 You are offline. Some features may be limited.', 'warning', true);
            // console.debug('Gone offline');
        });

        // Global Error Handling - Temporarily disabled for debugging
        window.addEventListener('error', (event) => {
            console.error('JCHAT_ERROR: Unhandled error:', event.error);
            console.error('JCHAT_ERROR: Error details:', {
                name: event.error?.name,
                message: event.error?.message,
                stack: event.error?.stack,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
            
            // Temporarily disabled to debug profile link issues
            // if (typeof showMessageBox === 'function' && messageBox && event.error) {
            //     showMessageBox('An unexpected error occurred. Please refresh if issues persist.', 'error');
            // }
        });

        // Performance Monitoring
        const performanceObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'navigation') {
                    console.log(`JCHAT_PERF: Page load time: ${entry.loadEventEnd - entry.loadEventStart}ms`);
                }
            }
        });
        
        if ('PerformanceObserver' in window) {
            performanceObserver.observe({ entryTypes: ['navigation'] });
        }

        // Initialize Firebase services: App, Auth, and Firestore.
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- ADMIN UID ---
        // The specific UID for the administrator, used for feature toggling and permissions.
        const ADMIN_UID = 'cc96gdhCRPO72NFZtleRCujHvIq2';

        // --- DOM Elements (Initialize after DOM is loaded) ---
        let themeSwitcherBtn, headerProfilePic, headerAvatarIcon, headerDisplayName;
        let notificationCountElement, adminIconLink, profileLink;
        let inspirationQuoteElement, inspirationAuthorElement, sharePostInspirationButton;
        let customizeInspirationButton, claimDailyBonusButton, customizeInspirationModal;
        let inspirationTypeRadios, cancelCustomizeButton, saveCustomizeButton;
        let postCreationSection, postContentInput, postMediaUpload, mediaImagePreview, mediaVideoPreview;
        let createPostButton, postsFeed, loadingPostsMessage, postTypeFilter, postSearchInput;
        let postDateFromInput, postDateToInput, exportPostsCsvButton, exportPostsJsonButton;
        let showSavedOnlyCheckbox, trendingHashtagsDiv, editPostModal, editPostContentInput;
        let editPostMediaUpload, editMediaImagePreview, editMediaVideoPreview, removeEditMediaButton;
        let cancelEditPostButton, saveEditedPostButton;
        // Theme switcher functionality
        let currentTheme = 'theme-dark-mode'; // Default theme
        const themeSwitcherThemes = ['theme-dark-mode', 'theme-light-mode'];

        // Initialize theme switcher
        function initializeThemeSwitcher() {
            // Load saved theme from localStorage
            const savedTheme = localStorage.getItem('jchat-theme') || 'theme-dark-mode';
            setTheme(savedTheme);
            
            // Add event listener to theme switcher button
            themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
            if (themeSwitcherBtn) {
                themeSwitcherBtn.addEventListener('click', cycleTheme);
            }
        }

        // Cycle through themes
        function cycleTheme() {
            const nextTheme = currentTheme === 'theme-dark-mode' ? 'theme-light-mode' : 'theme-dark-mode';
            setTheme(nextTheme);
        }

        // Set theme
        function setTheme(theme) {
            const body = document.body;
            
            // Remove all theme classes
            body.classList.remove('theme-dark-mode', 'theme-light-mode', 'theme-sunset-mode');
            
            // Add the new theme class
            body.classList.add(theme);
            
            // Update current theme
            currentTheme = theme;
            
            // Save theme to localStorage
            localStorage.setItem('jchat-theme', theme);
            
            // Update theme switcher button icon
            if (themeSwitcherBtn) {
                const icon = themeSwitcherBtn.querySelector('i');
                if (icon) {
                    icon.className = (theme === 'theme-light-mode') ? 'fas fa-sun' : 'fas fa-key';
                }
            }
            
            // Show theme change notification
            const themeName = theme.replace('theme-', '').replace('-mode', '');
            if (typeof showMessageBox === 'function') { showMessageBox(`Theme changed to ${themeName} mode`, 'success'); }
        }
        // Function to initialize all DOM elements safely
        function initializeDOMElements() {
            try {
                // Header elements
                themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
                headerProfilePic = document.getElementById('headerProfilePic');
                headerAvatarIcon = document.getElementById('headerAvatarIcon');
                headerDisplayName = document.getElementById('headerDisplayName');
                notificationCountElement = document.getElementById('headerNotificationCount');
                adminIconLink = document.getElementById('adminIconLink');
                profileLink = document.getElementById('profileLink');

                // Daily Inspiration section elements
                inspirationQuoteElement = document.getElementById('inspirationQuote');
                inspirationAuthorElement = document.getElementById('inspirationAuthor');
                sharePostInspirationButton = document.getElementById('sharePostInspirationButton');
                customizeInspirationButton = document.getElementById('customizeInspirationButton');
                claimDailyBonusButton = document.getElementById('claimDailyBonusButton');

                // Customize Inspiration Modal elements
                customizeInspirationModal = document.getElementById('customizeInspirationModal');
                inspirationTypeRadios = document.querySelectorAll('input[name="inspirationType"]');
                cancelCustomizeButton = document.getElementById('cancelCustomize');
                saveCustomizeButton = document.getElementById('saveCustomize');

                // Post Creation section elements
                postCreationSection = document.getElementById('postCreationSection');
                postContentInput = document.getElementById('postContent');
                postMediaUpload = document.getElementById('postMediaUpload');
                mediaImagePreview = document.getElementById('mediaImagePreview');
                mediaVideoPreview = document.getElementById('mediaVideoPreview');
                createPostButton = document.getElementById('createPostButton');
                postsFeed = document.getElementById('postsFeed');
                loadingPostsMessage = document.getElementById('loadingPostsMessage');
                postTypeFilter = document.getElementById('postTypeFilter');
                postSearchInput = document.getElementById('postSearchInput');
                postDateFromInput = document.getElementById('postDateFrom');
                postDateToInput = document.getElementById('postDateTo');
                exportPostsCsvButton = document.getElementById('exportPostsCsvButton');
                exportPostsJsonButton = document.getElementById('exportPostsJsonButton');
                showSavedOnlyCheckbox = document.getElementById('showSavedOnly');
                trendingHashtagsDiv = document.getElementById('trendingHashtags');

                // Edit Post Modal elements
                editPostModal = document.getElementById('editPostModal');
                editPostContentInput = document.getElementById('editPostContent');
                editPostMediaUpload = document.getElementById('editPostMediaUpload');
                editMediaImagePreview = document.getElementById('editMediaImagePreview');
                editMediaVideoPreview = document.getElementById('editMediaVideoPreview');
                removeEditMediaButton = document.getElementById('removeEditMedia');
                cancelEditPostButton = document.getElementById('cancelEditPost');
                saveEditedPostButton = document.getElementById('saveEditedPost');

                // Additional elements
                confirmationModal = document.getElementById('confirmationModal');
                confirmationTitle = document.getElementById('confirmationTitle');
                confirmationMessage = document.getElementById('confirmationMessage');
                confirmCancelButton = document.getElementById('confirmCancelButton');
                confirmProceedButton = document.getElementById('confirmProceedButton');
                messageBox = document.getElementById('messageBox');
                sidebarNav = document.getElementById('sidebarNav');
                sidebarToggleFab = document.getElementById('sidebarToggleFab');
                sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
                sidebarNavItems = document.querySelectorAll('.sidebar-nav-item');
                sidebarLogoutLink = document.getElementById('sidebarLogoutLink');
                chatLink = document.getElementById('chatLink');
                findFriendsLink = document.getElementById('findFriendsLink');
                friendsLink = document.getElementById('friendsLink');
                groupsLink = document.getElementById('groupsLink');
                jcoinShopLink = document.getElementById('jcoinShopLink');
                maintenanceOverlay = document.getElementById('maintenanceOverlay');
                maintenanceAnnouncementText = document.getElementById('maintenanceAnnouncementText');
                callOverlay = document.getElementById('callOverlay');
                callStatusIcon = document.getElementById('callStatusIcon');
                callStatusText = document.getElementById('callStatusText');
                callTimerDisplay = document.getElementById('callTimer');
                callActions = document.getElementById('callActions');
                acceptCallBtn = document.getElementById('acceptCallBtn');
                declineCallBtn = document.getElementById('declineCallBtn');
                endCallBtn = document.getElementById('endCallBtn');
                localVideo = document.getElementById('localVideo');
                remoteVideo = document.getElementById('remoteVideo');
                toggleMuteBtn = document.getElementById('toggleMuteBtn');
                toggleVideoBtn = document.getElementById('toggleVideoBtn');

                console.log('JCHAT_DEBUG: DOM elements initialized successfully');
            } catch (error) {
                console.error('JCHAT_ERROR: Error initializing DOM elements:', error);
            }
        }

        // Additional DOM elements - will be initialized in initializeDOMElements
        let confirmationModal, confirmationTitle, confirmationMessage;
        let confirmCancelButton, confirmProceedButton, messageBox;

        // All DOM elements - will be initialized in initializeDOMElements  
        let sidebarNav, sidebarToggleFab, sidebarCloseBtn, sidebarNavItems, sidebarLogoutLink;
        let chatLink, findFriendsLink, friendsLink, groupsLink, jcoinShopLink;
        let maintenanceOverlay, maintenanceAnnouncementText, callOverlay, callStatusIcon;
        let callStatusText, callTimerDisplay, callActions, acceptCallBtn, declineCallBtn;
        let endCallBtn, localVideo, remoteVideo, toggleMuteBtn, toggleVideoBtn;


        // --- Global State Variables ---
        let currentUser = null; // Stores the Firebase authenticated user object.
        let currentUserProfileData = null; // Stores the authenticated user's own profile data from Firestore.
        let inspirationIntervalId = null; // Interval ID for refreshing daily inspiration.
        let dailyBonusCountdownInterval = null; // Interval for daily bonus cooldown countdown.
        let currentMediaFile = null; // Stores the file object for new post media.
        let currentEditPostId = null; // Stores the ID of the post being edited.
        let currentEditMediaFile = null; // Stores the new file object for edited post media.
        let currentEditMediaUrl = null; // Stores the existing media URL for edited post.
        let currentEditMediaType = null; // Stores the existing media type for edited post.
        let isAuthReady = false; // Flag indicating if Firebase authentication state has been determined.
        let unsubscribeListeners = []; // Array to store all onSnapshot unsubscribe functions for cleanup.
        let currentSystemSettings = {}; // Stores global system settings fetched from Firestore.

        // --- Notification Badge Management ---
        function updateNotificationBadge(count) {
            const notificationWrapper = document.querySelector('.notification-icon-wrapper');
            const badge = document.getElementById('headerNotificationCount');
            
            if (badge && notificationWrapper) {
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.style.display = 'flex';
                    notificationWrapper.classList.add('has-notifications');
                    console.log("JCHAT_DEBUG: Notification bell is now shaking with", count, "unread notifications");
                } else {
                    badge.style.display = 'none';
                    notificationWrapper.classList.remove('has-notifications');
                    console.log("JCHAT_DEBUG: Notification bell stopped shaking - no unread notifications");
                }
            }
        }

        // WebRTC Call State Variables
        let localStream; // Local media stream (audio/video).
        let remoteStream; // Remote media stream from the other peer.
        let peerConnection; // RTCPeerConnection object.
        let currentCallType; // 'voice' or 'video'.
        let isMuted = false; // Mute state for local audio.
        let isVideoOff = false; // Video off state for local video.
        let callState = 'idle'; // Current call state: 'idle', 'calling', 'ringing', 'connected', 'busy', 'declined', 'ended', 'no-answer'.
        let callDuration = 0; // Duration of the current call in seconds.
        let callDurationInterval; // Interval ID for updating call timer.
        let callTimeoutId; // Timeout ID for incoming call no-answer.
        let callRef; // Firestore document reference for the current call.
        let isIncomingCall = false; // Flag to differentiate initiator from receiver.
        let recipientUserProfileData = null; // To store caller's profile for display in incoming calls.


        // --- Theme Management Variables ---
        const themes = [
            'theme-light-mode',
            'theme-dark-mode',
            'theme-glass-mode',
            'theme-sunset-mode'
        ];

        // --- Inspiration Quotes Data (Local Fallback) ---
        // These are used as the primary source of inspiration quotes.
        const pick = arr => arr[Math.floor(Math.random() * arr.length)];
        const quoteTemplates = {
            motivational: { openers:["Keep going","Start small","Believe in yourself","Stay consistent","Trust the process"], bridges:["—"," because ",": ",", and ","; "], endings:["every step counts.","tomorrow thanks you for today's effort.","progress loves momentum.","you're closer than you think.","discipline builds destiny."] },
            peaceful: { openers:["Breathe","Slow down","Be gentle","Find quiet","Let go"], bridges:["—"," and ",", then "," as ",": "], endings:["clarity will meet you.","peace finds its way in.","the heart softens.","the mind untangles.","you return to yourself."] },
            funny: { openers:["Reminder","Breaking news","Pro tip","True story","PSA"], bridges:[": "," — "," — ",": "], endings:["motivation will arrive after snacks.","I'm on a seafood diet—I see food and I code.","sleep is a patch we never apply.","tomorrow is just today with a wig.","coffee is my personality driver."] },
            wisdom: { openers:["Growth","Curiosity","Patience","Listening","Kindness"], bridges:[" reveals that "," teaches that "," reminds us "," shows that ",": "], endings:["there's more to learn than to prove.","small habits shape great outcomes.","the quietest lessons echo the longest.","consistency outlives talent.","clarity follows attention."] },
            love: { openers:["Love","Compassion","Care","Gratitude","Warmth"], bridges:[" grows where "," lives when "," begins when "," multiplies when ",": "], endings:["we show up for each other.","we choose patience.","we listen before we speak.","small gestures carry big meaning.","we forgive and rebuild."] }
        };
        function generateProceduralQuote(type) { const t = quoteTemplates[type] || quoteTemplates.motivational; return { quote: `${pick(t.openers)}${pick(t.bridges)}${pick(t.endings)}`, author: 'JCHAT' }; }
        const inspirationalQuotes = {
            motivational: [
                { quote: "Every sunrise is an invitation to brighten your world.", author: "JCHAT" },
                { quote: "Your potential is limitless; dare to explore it.", author: "JCHAT" },
                { quote: "Small steps forward still lead to great destinations.", author: "JCHAT" },
                { quote: "Embrace challenges, for they forge your strength.", author: "JCHAT" },
                { quote: "The best time for new beginnings is now.", author: "JCHAT" },
            ],
            peaceful: [
                { quote: "Find your calm in the rhythm of your breath.", author: "JCHAT" },
                { quote: "Let go of what was, embrace the serenity of what is.", author: "JCHAT" },
                { quote: "Peace is not the absence of trouble, but the presence of calm within it.", author: "JCHAT" },
                { quote: "In stillness, discover the answers you seek.", author: "JCHAT" },
                { quote: "May your mind be clear, and your heart be light.", author: "JCHAT" },
            ],
            funny: [
                { quote: "I'm not lazy, I'm just on energy-saving mode.", author: "JCHAT" },
                { quote: "My bed is a magical place where I suddenly remember everything I forgot to do.", author: "JCHAT" },
                { quote: "I used to think I was indecisive, but now I'm not so sure.", author: "JCHAT" },
                { quote: "Life is short. Smile while you still have teeth.", author: "JCHAT" },
                { quote: "My favorite exercise is a cross between a lunge and a crunch. I call it lunch.", author: "JCHAT" },
            ],
            wisdom: [
                { quote: "True wisdom lies in knowing the depth of your own ignorance.", author: "JCHAT" },
                { quote: "The greatest teacher is experience.", author: "JCHAT" },
                { quote: "A mind stretched by new experiences never returns to its old dimensions.", author: "JCHAT" },
                { quote: "Listen more than you speak; learn more than you teach.", author: "JCHAT" },
                { quote: "The only true wisdom is in knowing you know nothing.", author: "JCHAT" },
            ],
            love: [
                { quote: "Kindness is love's simplest language.", author: "JCHAT" },
                { quote: "Love grows in the space between patience and care.", author: "JCHAT" },
                { quote: "Where gratitude lives, love multiplies.", author: "JCHAT" },
                { quote: "Choose love, even on the small days.", author: "JCHAT" },
            ]
        };

        // --- Level and XP Progression Logic ---
        /**
         * Provides information about user levels, XP requirements, and rewards.
         * @param {number} level - The current level of the user.
         * @returns {object} An object containing level details.
         */
        function getLevelInfo(level) {
            // CHALLENGING SYSTEM - Dynamic calculation matching Profile.html
            let jCoinReward = 0;
            let gasReward = 0;
            let otherRewards = [];
            let name = "Unknown";
            let icon = "fas fa-question-circle";
            let timeEstimate = "Unknown";

            if (level >= 1 && level <= 25) { // Tier 1: Early Explorer
                jCoinReward = 10 + (level - 1) * 5; // Start 10, +5/level
                gasReward = 5 + (level - 1) * 2;   // Start 5, +2/level
                const levelNames = [
                    "Novice", "Beginner", "Apprentice", "Explorer", "Pioneer",
                    "Communicator", "Socialite", "Networker", "Influencer", "Trendsetter",
                    "Innovator", "Creator", "Visionary", "Architect", "Maestro",
                    "Strategist", "Guardian", "Champion", "Hero", "Legend",
                    "Mythic", "Celestial", "Divine", "Transcendent", "Cosmic Being"
                ];
                const levelIcons = [
                    "fas fa-leaf", "fas fa-seedling", "fas fa-user-graduate", "fas fa-map-marker-alt", "fas fa-compass",
                    "fas fa-comments", "fas fa-users", "fas fa-share-alt", "fas fa-star", "fas fa-fire",
                    "fas fa-lightbulb", "fas fa-paint-brush", "fas fa-eye", "fas fa-building", "fas fa-music",
                    "fas fa-chess", "fas fa-shield-alt", "fas fa-trophy", "fas fa-mask", "fas fa-dragon",
                    "fas fa-meteor", "fas fa-galaxy", "fas fa-hand-sparkles", "fas fa-infinity", "fas fa-atom"
                ];
                const timeEstimates = [
                    "1 week", "2 weeks", "3 weeks", "1 month", "6 weeks",
                    "2 months", "10 weeks", "3 months", "14 weeks", "4 months",
                    "18 weeks", "5 months", "22 weeks", "6 months", "26 weeks",
                    "7 months", "30 weeks", "8 months", "34 weeks", "9 months",
                    "38 weeks", "10 months", "42 weeks", "11 months", "1 year"
                ];
                
                name = levelNames[level - 1] || `Level ${level}`;
                icon = levelIcons[level - 1] || "fas fa-star";
                timeEstimate = timeEstimates[level - 1] || "Unknown";

                // Specific rewards for challenging progression
                if (level === 1) otherRewards.push("Badge: 'First Steps'");
                if (level === 3) otherRewards.push("Unlock: 1-Hour XP Boost");
                if (level === 5) otherRewards.push("Badge: 'Chat Starter'", "Unlock: Basic Profile Frame");
                if (level === 10) otherRewards.push("Unlock: Custom Status Messages");
                if (level === 15) otherRewards.push("Badge: 'Community Builder'");
                if (level === 20) otherRewards.push("Unlock: Legendary Status", "Special Profile Effects");
                if (level === 25) otherRewards.push("Badge: 'Cosmic Being'", "Ultimate Profile Customization");
            }

            let xpToNextLevel;

            if (level < 1) level = 1;

            // XP Calculation Logic - CHALLENGING progression system
            // Uses the same formula as Profile.html: 1500 * level * (level + 1) / 2
            // This creates a more challenging and rewarding progression curve
            xpToNextLevel = 1500 * level * (level + 1) / 2;

            // Handle higher levels (26+) with generic tiers
            if (level > 25 && level <= 500) {
                // Tiered naming for higher levels
                const tierNames = [
                    "Adept", "Master", "Grandmaster", "Exalted", "Ascendant",
                    "Divine", "Apex", "Cosmic", "Ethereal", "Legendary",
                    "Mythical", "Celestial", "Transcendent", "Omnipotent", "Infinite",
                    "Starlight", "Nebula", "Galaxy", "Universe", "Multiverse",
                    "Zenith", "Pinnacle", "Sovereign", "Eternal", "Absolute"
                ];
                const tierIcons = [
                    "fas fa-magic", "fas fa-crown", "fas fa-chess-king", "fas fa-gem",
                    "fas fa-star-of-life", "fas fa-hand-sparkles", "fas fa-mountain", "fas fa-atom",
                    "fas fa-cloud-sun", "fas fa-dragon", "fas fa-meteor", "fas fa-galaxy",
                    "fas fa-infinity", "fas fa-bahai", "fas fa-globe-americas", "fas fa-star",
                    "fas fa-cloud", "fas fa-atom", "fas fa-globe", "fas fa-cubes",
                    "fas fa-mountain", "fas fa-trophy", "fas fa-shield-alt", "fas fa-infinity", "fas fa-brain"
                ];

                const baseLevelForTier = 26;
                const levelsPerTierName = 25; // Challenging system: bigger tier spans
                const levelsPerTierIcon = 25;

                const tierNameIndex = Math.floor((level - baseLevelForTier) / levelsPerTierName);
                const tierIconIndex = Math.floor((level - baseLevelForTier) / levelsPerTierIcon);

                name = `${tierNames[tierNameIndex % tierNames.length]} Lv. ${level}`;
                icon = tierIcons[tierIconIndex % tierIcons.length];
                jCoinReward = 130 + (level - 26) * 10; // Challenging: higher base, slower growth
                gasReward = 50 + (level - 26) * 5;
                timeEstimate = `${Math.ceil(level / 4)} months`;
            } else if (level > 500) {
                name = `Transcendent Lv. ${level}`;
                icon = "fas fa-infinity";
                jCoinReward = 130 + (500 - 26) * 10 + (level - 500) * 50;
                gasReward = 50 + (500 - 26) * 5 + (level - 500) * 25;
                timeEstimate = `${Math.ceil(level / 2)} months`;
            } else {
                // Fallback for any edge cases
                name = `Explorer Lv. ${level}`;
                icon = "fas fa-compass";
                jCoinReward = 10;
                gasReward = 5;
                timeEstimate = "Unknown";
            }

            return {
                level: level,
                name: name,
                icon: icon,
                jCoinReward: jCoinReward,
                gasReward: gasReward,
                xpToNextLevel: xpToNextLevel,
                timeEstimate: timeEstimate,
                otherRewards: otherRewards
            };
        }

        // --- NEW: Pending Activity Reward Creation Function ---
        /**
         * Creates a pending activity reward document for admin review.
         * This system allows for manual approval of XP/JCoin rewards, preventing abuse.
         * @param {string} userId - The ID of the user who performed the activity.
         * @param {string} username - The username of the user.
         * @param {string} activityType - The type of activity (e.g., 'daily_login', 'react_like', 'post_comment', 'post_creation', 'post_deletion').
         * @param {number} suggestedXpReward - The suggested XP amount to award (can be negative for deductions).
         * @param {number} suggestedJCoinReward - The suggested JCoin amount to award (can be negative for deductions).
         * @param {string} [activityId=null] - Optional: ID of the specific activity (e.g., commentId, reactionId).
         * @param {string} [postId=null] - Optional: ID of the post related to the activity.
         */
        async function createPendingActivityReward(
            userId,
            username,
            activityType,
            suggestedXpReward,
            suggestedJCoinReward,
            activityId = null,
            postId = null
        ) {
            try {
                const pendingRewardsCollectionRef = collection(db, "artifacts", appId, "public", "data", "pending_activity_rewards");

                const newRewardDocRef = await addDoc(pendingRewardsCollectionRef, {
                    userId: userId,
                    username: username,
                    activityType: activityType,
                    suggestedXpReward: suggestedXpReward,
                    suggestedJCoinReward: suggestedJCoinReward,
                    status: 'pending', // Always pending for admin review
                    timestamp: serverTimestamp(),
                    activityId: activityId, // Store activity ID if relevant
                    postId: postId // Store postId if relevant
                });

                console.log(`JCHAT_DEBUG: Pending activity reward created with ID: ${newRewardDocRef.id}`);
            } catch (error) {
                console.error("JCHAT_ERROR: Error creating pending activity reward:", error);
            }
        }


        // --- Daily Login Bonus Logic ---
        /**
         * Updates the countdown timer and state of the daily bonus button.
         * This function is called every second by an interval.
         */
        function updateDailyBonusCountdown() {
            // If user or profile data is not available, stop the timer and disable the button.
            if (!currentUserProfileData || !claimDailyBonusButton) {
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            const now = new Date();
            // Convert Firestore Timestamp to Date object if it exists.
            const lastClaimedTimestamp = currentUserProfileData.lastLoginBonusClaimed ?
                currentUserProfileData.lastLoginBonusClaimed.toDate() : null;

            // If no previous claim, enable the button immediately.
            if (!lastClaimedTimestamp) {
                claimDailyBonusButton.disabled = false;
                claimDailyBonusButton.querySelector('.button-text').textContent = "Claim Daily Bonus";
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            // Calculate the next available claim time (24 hours after last claim).
            const nextClaimTime = new Date(lastClaimedTimestamp.getTime() + (24 * 60 * 60 * 1000));
            const timeLeft = nextClaimTime.getTime() - now.getTime();

            if (timeLeft <= 0) {
                // If cooldown is over, enable the button.
                claimDailyBonusButton.disabled = false;
                claimDailyBonusButton.querySelector('.button-text').textContent = "Claim Daily Bonus";
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
            } else {
                // If still in cooldown, display the countdown.
                claimDailyBonusButton.disabled = true;
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                claimDailyBonusButton.querySelector('.button-text').textContent = `Next in ${hours}h ${minutes}m ${seconds}s`;
            }
        }

        /**
         * Checks the daily bonus status and starts/stops the countdown timer.
         * This is called on auth state change and after claiming a bonus.
         */
        async function checkAndStartDailyBonusTimer() {
            // Disable button and clear timer if not authenticated or profile not loaded.
            if (!currentUser || !currentUserProfileData) {
                if (claimDailyBonusButton) {
                    claimDailyBonusButton.disabled = true;
                    claimDailyBonusButton.querySelector('.button-text').textContent = "Login to Claim Bonus";
                }
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            // Perform an initial update to set the correct state immediately.
            updateDailyBonusCountdown();

            // Clear any existing interval before setting a new one to prevent duplicates.
            if (dailyBonusCountdownInterval) {
                clearInterval(dailyBonusCountdownInterval);
            }

            // Start the interval only if the button is currently disabled (meaning there's an active cooldown).
            if (claimDailyBonusButton && claimDailyBonusButton.disabled) {
                dailyBonusCountdownInterval = setInterval(updateDailyBonusCountdown, 1000); // Update every second
            }
        }


        /**
         * Handles the click event for claiming the daily bonus.
         * Checks cooldown, updates Firestore, and creates a pending reward.
         */
        async function handleClaimDailyBonusClick() {
            // Pre-checks for authentication and profile data.
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("Please log in to claim daily bonus.", 'error');
                return;
            }

            const now = new Date();
            const lastClaimedTimestamp = currentUserProfileData.lastLoginBonusClaimed ?
                currentUserProfileData.lastLoginBonusClaimed.toDate() : null;

            // Check if the bonus has already been claimed within the last 24 hours.
            if (lastClaimedTimestamp) {
                const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                if (lastClaimedTimestamp > twentyFourHoursAgo) {
                    showMessageBox("Daily bonus already claimed today. Check back tomorrow!", 'info');
                    return;
                }
            }

            // Show loading state for the button and message box.
            toggleButtonLoading(claimDailyBonusButton, true);
            showMessageBox("Claiming daily bonus...", 'loading', true);

            try {
                const userProfileDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "profiles", "user_profile");

                // Update the lastLoginBonusClaimed timestamp in the user's private profile.
                await updateDoc(userProfileDocRef, {
                    lastLoginBonusClaimed: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });

                // Create a pending reward for admin review instead of directly awarding.
                await createPendingActivityReward(
                    currentUser.uid,
                    currentUserProfileData.username,
                    'daily_login',
                    10, // Suggested XP reward for daily login
                    3  // Suggested JCoin reward for daily login
                );

                showMessageBox(`Daily bonus claimed! 10 XP and 3 JCoins are pending admin review.`, 'success');
                playNotificationSound('success');

                // Update local profile data immediately for UI consistency (especially for the timer).
                currentUserProfileData.lastLoginBonusClaimed = { toDate: () => new Date() };
                checkAndStartDailyBonusTimer(); // Re-evaluate status and start/stop timer.
            } catch (error) {
                console.error("JCHAT_ERROR: Error claiming daily bonus:", error);
                showMessageBox(`Failed to claim bonus: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(claimDailyBonusButton, false); // Revert button loading state.
            }
        }
        // --- Tone.js Synths for Notification Sounds ---
        // Initialize various synths for different notification types.
        const successSynth = new Tone.Synth().toDestination();
        const errorSynth = new Tone.Synth().toDestination();
        const infoSynth = new Tone.Synth().toDestination();
        const ringingSynth = new Tone.Synth().toDestination(); // For incoming call ring
        // Configure basic sound properties for each synth.
        successSynth.oscillator.type = "sine";
        successSynth.envelope.attack = 0.01;
        successSynth.envelope.decay = 0.2;
        successSynth.envelope.sustain = 0.0;
        successSynth.envelope.release = 0.5;

        errorSynth.oscillator.type = "sawtooth";
        errorSynth.envelope.attack = 0.01;
        errorSynth.envelope.decay = 0.3;
        errorSynth.envelope.sustain = 0.0;
        errorSynth.envelope.release = 0.5;

        infoSynth.oscillator.type = "triangle";
        infoSynth.envelope.attack = 0.01;
        infoSynth.envelope.decay = 0.1;
        infoSynth.envelope.sustain = 0.0;
        infoSynth.envelope.release = 0.3;

        // Ringing sound (similar to a phone ring) pattern setup.
        ringingSynth.oscillator.type = "square";
        ringingSynth.envelope.attack = 0.01;
        ringingSynth.envelope.decay = 0.6;
        ringingSynth.envelope.sustain = 0.0;
        ringingSynth.envelope.release = 0.8;
        const ringingPattern = new Tone.Pattern(function(time, note){
            ringingSynth.triggerAttackRelease(note, "8n", time);
        }, ["C5", "C5", "C5", "C5"]).start(0);
        ringingPattern.interval = "1s"; // Adjust interval for ringing pattern.
        ringingPattern.humanize = true;
        ringingPattern.playbackRate = 1;
        ringingPattern.loop = true;
        ringingPattern.autostart = false; // Will be started manually.

        // --- Comprehensive Notification System ---
        let notifications = [];
        let unreadNotificationCount = 0;
        let notificationSoundEnabled = true;
        /**
         * Creates a new notification
         * @param {string} type - 'success', 'error', 'info', 'warning', 'friend_request', 'message', 'level_up'
         * @param {string} title - Notification title
         * @param {string} message - Notification message
         * @param {string} icon - FontAwesome icon class (optional, will auto-select based on type)
         * @param {boolean} persistent - Whether notification should persist
         */
        function createNotification(type, title, message, icon = null, persistent = false) {
            // Auto-select icon based on type if not provided
            if (!icon) {
                switch (type) {
                    case 'success':
                        icon = 'fas fa-check-circle';
                        break;
                    case 'error':
                        icon = 'fas fa-exclamation-circle';
                        break;
                    case 'info':
                        icon = 'fas fa-info-circle';
                        break;
                    case 'warning':
                        icon = 'fas fa-exclamation-triangle';
                        break;
                    case 'friend_request':
                        icon = 'fas fa-user-plus';
                        break;
                    case 'message':
                        icon = 'fas fa-comment';
                        break;
                    case 'level_up':
                        icon = 'fas fa-star';
                        break;
                    default:
                        icon = 'fas fa-bell';
                }
            }
            const notification = {
                id: Date.now() + Math.random(),
                type: type,
                title: title,
                message: message,
                icon: icon,
                timestamp: new Date(),
                read: false,
                persistent: persistent
            };

            notifications.unshift(notification);
            if (!notification.read) {
                unreadNotificationCount++;
            }

            // Limit notifications to 50
            if (notifications.length > 50) {
                notifications = notifications.slice(0, 50);
            }

            updateNotificationBadge(unreadNotificationCount);
            
            // Play sound if enabled
            if (notificationSoundEnabled) {
                playNotificationSound(type);
            }

            // Save to localStorage
            saveNotificationsToStorage();

            return notification;
        }
        /**
         * Plays a notification sound based on type.
         * @param {string} type - 'success', 'error', 'info', 'warning', 'friend_request', 'message', 'level_up'.
         */
        function playNotificationSound(type) {
            try {
                // Create audio element for the new notification sound
                const audio = new Audio('ne.mp3');
                audio.volume = 0.6; // Set volume to 60%
                
                // Play the notification sound
                audio.play().catch(error => {
                    console.log('JCHAT_DEBUG: Could not play notification sound:', error);
                    // Fallback to Tone.js if audio file fails
                    Tone.start();
                    if (type === 'success') {
                        successSynth.triggerAttackRelease("C5", "8n");
                    } else if (type === 'error') {
                        errorSynth.triggerAttackRelease("C3", "8n");
                    } else if (type === 'info') {
                        infoSynth.triggerAttackRelease("E4", "16n");
                    } else if (type === 'warning') {
                        errorSynth.triggerAttackRelease("A3", "8n");
                    } else if (type === 'friend_request') {
                        infoSynth.triggerAttackRelease("G4", "8n");
                    } else if (type === 'message') {
                        infoSynth.triggerAttackRelease("D4", "8n");
                    } else if (type === 'level_up') {
                        successSynth.triggerAttackRelease("C6", "4n");
                    }
                });
            } catch (error) {
                console.log('JCHAT_DEBUG: Error playing notification sound:', error);
                // Fallback to Tone.js
                Tone.start();
                if (type === 'success') {
                    successSynth.triggerAttackRelease("C5", "8n");
                } else if (type === 'error') {
                    errorSynth.triggerAttackRelease("C3", "8n");
                } else if (type === 'info') {
                    infoSynth.triggerAttackRelease("E4", "16n");
                } else if (type === 'warning') {
                    errorSynth.triggerAttackRelease("A3", "8n");
                } else if (type === 'friend_request') {
                    infoSynth.triggerAttackRelease("G4", "8n");
                } else if (type === 'message') {
                    infoSynth.triggerAttackRelease("D4", "8n");
                } else if (type === 'level_up') {
                    successSynth.triggerAttackRelease("C6", "4n");
                }
            }
        }

        /**
         * Starts the ringing sound for incoming calls.
         */
        function startRingingSound() {
            Tone.start();
            ringingPattern.start();
        }

        /**
         * Stops the ringing sound.
         */
        function stopRingingSound() {
            ringingPattern.stop();
        }

        // --- Utility Functions ---
        /**
         * Displays a custom message box with a given message, type, and persistence.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'info', 'warning', or 'loading'.
         * @param {boolean} isPersistent - If true, the message box will not auto-hide.
         */
        function showMessageBox(message, type, isPersistent = false) {
            if (!messageBox) {
                messageBox = document.getElementById('messageBox');
                if (!messageBox) {
                    console.error("JCHAT_ERROR: messageBox element not found.");
                    return;
                }
            }
            // Clear any existing auto-hide timeout.
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }

            // Set inner HTML with icon and text elements.
            messageBox.innerHTML = `<i id=\"messageBoxIcon\"></i><span id=\"messageBoxText\"></span><button id=\"messageBoxClose\" aria-label=\"Close\" style=\"margin-left:8px;border:none;background:transparent;color:inherit;cursor:pointer;\"><i class=\"fas fa-times\"></i></button>`;
            const messageBoxIcon = document.getElementById('messageBoxIcon');
            const messageBoxText = document.getElementById('messageBoxText');

            messageBoxText.textContent = message;
            // Apply CSS classes for styling and visibility.
            messageBox.className = 'message-box show ' + type;

            // Set icon based on message type.
            if (messageBoxIcon) {
                messageBoxIcon.className = ''; // Clear existing classes.
                if (type === 'success') {
                    messageBoxIcon.classList.add('fas', 'fa-check-circle');
                } else if (type === 'error') {
                    messageBoxIcon.classList.add('fas', 'fa-times-circle');
                } else if (type === 'info') {
                    messageBoxIcon.classList.add('fas', 'fa-info-circle');
                } else if (type === 'warning') {
                    messageBoxIcon.classList.add('fas', 'fa-exclamation-triangle');
                } else if (type === 'loading') {
                    messageBoxIcon.classList.add('fas', 'fa-spinner', 'fa-spin'); // Spinner for loading.
                }
            }

            // Apply pulsing animation for loading messages.
            if (type === 'loading') {
                messageBox.classList.add('loading-pulse');
            } else {
                messageBox.classList.remove('loading-pulse');
            }

            // Make the message box visible.
            messageBox.style.display = 'flex';
            messageBox.style.opacity = '1';

            // Manual close handler
            const messageBoxClose = document.getElementById('messageBoxClose');
            if (messageBoxClose) {
                messageBoxClose.onclick = () => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', function handler() {
                        messageBox.style.display = 'none';
                        messageBox.removeEventListener('transitionend', handler);
                        messageBox.classList.remove('loading-pulse');
                    }, { once: true });
                };
            }

            // Set auto-hide timeout if not persistent.
            if (!isPersistent) {
                messageBox.timeoutId = setTimeout(() => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', function handler() {
                        messageBox.style.display = 'none';
                        messageBox.removeEventListener('transitionend', handler);
                        messageBox.classList.remove('loading-pulse');
                    }, { once: true });
                }, 3000);
            }
        }

        /**
         * Displays a confirmation modal and returns a Promise that resolves to true if confirmed, false otherwise.
         * @param {string} title - The title of the confirmation modal.
         * @param {string} message - The message to display in the confirmation modal.
         * @returns {Promise<boolean>}
         */
        function showConfirmationModal(title, message) {
            return new Promise((resolve) => {
                // Check if all necessary modal elements exist.
                if (!confirmationTitle || !confirmationMessage || !confirmationModal || !confirmProceedButton || !confirmCancelButton) {
                    console.error("JCHAT_ERROR: Confirmation modal elements not found.");
                    resolve(false); // Resolve false if elements are missing.
                    return;
                }

                confirmationTitle.textContent = title;
                confirmationMessage.textContent = message;
                confirmationModal.classList.add('active'); // Show the modal.

                // Event handler for confirming the action.
                const handleConfirm = () => {
                    confirmationModal.classList.remove('active'); // Hide modal.
                    // Remove event listeners to prevent memory leaks and duplicate calls.
                    confirmProceedButton.removeEventListener('click', handleConfirm);
                    confirmCancelButton.removeEventListener('click', handleCancel);
                    resolve(true); // Resolve with true (confirmed).
                };

                // Event handler for canceling the action.
                const handleCancel = () => {
                    confirmationModal.classList.remove('active'); // Hide modal.
                    // Remove event listeners.
                    confirmProceedButton.removeEventListener('click', handleConfirm);
                    confirmCancelButton.removeEventListener('click', handleCancel);
                    resolve(false); // Resolve with false (canceled).
                };

                // Attach event listeners to buttons.
                confirmProceedButton.addEventListener('click', handleConfirm);
                confirmCancelButton.addEventListener('click', handleCancel);

                // Close modal if clicking outside the content area.
                confirmationModal.addEventListener('click', function outsideClickListener(event) {
                    if (event.target === confirmationModal) {
                        handleCancel(); // Treat outside click as a cancel.
                        confirmationModal.removeEventListener('click', outsideClickListener);
                    }
                });
            });
        }

        /**
         * Generates a Cloudinary image URL with specified transformations.
         * Handles both public IDs and existing Cloudinary URLs.
         * @param {string} urlOrPublicId - The Cloudinary public ID or an existing Cloudinary URL.
         * @param {string} transformations - Cloudinary transformation string (e.g., "w_auto,f_auto,q_auto").
         * @returns {string|null} The transformed Cloudinary URL or null if input is invalid.
         */
        function getCloudinaryImageUrl(urlOrPublicId, transformations = "w_auto,f_auto,q_auto") {
            if (!urlOrPublicId) return null;
            if (urlOrPublicId.startsWith('http://') || urlOrPublicId.startsWith('https://')) {
                // If it's already a full URL, ensure it's a Cloudinary URL before transforming.
                if (urlOrPublicId.includes('res.cloudinary.com')) {
                    // This is a basic attempt to insert transformations into an existing Cloudinary URL.
                    // More robust parsing might be needed for complex existing URLs.
                    const parts = urlOrPublicId.split('/upload/');
                    if (parts.length === 2) {
                        // Check if transformations are already present to avoid duplication.
                        const currentTransformations = parts[1].split('/')[0];
                        if (currentTransformations.includes(transformations.split(',')[0])) {
                            return urlOrPublicId; // Assume already transformed.
                        }
                        return `${parts[0]}/upload/${transformations}/${parts[1]}`;
                    }
                }
                return urlOrPublicId; // Return as is if not a recognizable Cloudinary URL or already transformed.
            }
            // Construct URL from public ID.
            return `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/image/upload/${transformations}/${urlOrPublicId}`;
        }

        /**
         * Displays a profile picture or a placeholder icon based on the provided profilePicId.
         * @param {HTMLImageElement} imgElement - The <img> element to display the picture.
         * @param {HTMLElement} iconElement - The <i> element to display the placeholder icon.
         * @param {string|null} profilePicId - The Cloudinary public ID of the profile picture, or null.
         * @param {string} usernameInitial - The first letter of the username for the placeholder.
         * @param {string} transformations - Cloudinary transformation string for the image.
         */
        function displayProfilePicture(imgElement, iconElement, profilePicId, usernameInitial, transformations) {
            if (imgElement && iconElement) {
                if (profilePicId) {
                    const imageUrl = getCloudinaryImageUrl(profilePicId, transformations);
                    imgElement.src = imageUrl;
                    imgElement.style.display = 'block'; // Show image.
                    iconElement.style.display = 'none'; // Hide icon.
                    // Fallback for image loading errors.
                    imgElement.onerror = () => {
                        console.error(`Failed to load profile picture: ${profilePicId}. Using placeholder.`);
                        imgElement.src = `https://placehold.co/120x120/CCCCCC/000000?text=${usernameInitial}`;
                        imgElement.style.display = 'block';
                        iconElement.style.display = 'none';
                    };
                } else {
                    imgElement.src = '';
                    imgElement.style.display = 'none'; // Hide image.
                    iconElement.style.display = 'block'; // Show icon.
                }
            }
        }

        /**
         * Resizes an image file using a canvas and returns it as a Blob.
         * @param {File} file - The image file to resize.
         * @param {number} maxWidth - Maximum width for the resized image.
         * @param {number} maxHeight - Maximum height for the resized image.
         * @param {number} quality - JPEG quality (0.0 to 1.0).
         * @returns {Promise<Blob>} A Promise that resolves with the resized image Blob.
         */
        function resizeImage(file, maxWidth = 800, maxHeight = 800, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        // Calculate new dimensions to fit within maxWidth/maxHeight while maintaining aspect ratio.
                        if (width > maxWidth) {
                            height = height * (maxWidth / width);
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = width * (maxHeight / height);
                            height = maxHeight;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert canvas content to a Blob.
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas to Blob conversion failed: Resulting blob was null.'));
                            }
                        }, 'image/jpeg', quality);
                    };
                    img.onerror = (error) => {
                        console.error("Image element loading error:", error);
                        reject(new Error(`Image loading failed: ${error.message || 'Unknown image loading error.'}`));
                    };
                    img.src = event.target.result;
                };
                reader.onerror = (error) => {
                    console.error("FileReader error during readAsDataURL:", error);
                    reject(new Error(`FileReader error: ${error.target.error ? error.target.error.message : 'Unknown error reading file.'}`));
                }
                try {
                    reader.readAsDataURL(file);
                } catch (e) {
                    console.error("Error calling readAsDataURL:", e);
                    reject(new Error(`Failed to read file data: ${e.message}`));
                }
            });
        }

        /**
         * Uploads a media file (image or video) to Cloudinary.
         * @param {File|Blob} file - The file to upload.
         * @returns {Promise<string|null>} The secure URL of the uploaded media, or null if upload fails.
         */
        async function uploadMediaToCloudinary(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', cloudinaryConfig.uploadPreset);

                const resourceType = file.type.startsWith('image/') ? 'image' : 'video';

                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/${resourceType}/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Cloudinary upload error:", errorData);
                    throw new Error(`Cloudinary upload failed: ${errorData.error.message || response.statusText}`);
                }

                const data = await response.json();
                return data.secure_url;
            } catch (error) {
                console.error("Error uploading to Cloudinary:", error);
                return null;
            }
        }
        /**
         * Applies the selected theme to the document body.
         * @param {string} themeName - The CSS class name for the theme (e.g., 'theme-dark-mode').
         */
        function applyTheme(themeName) {
            document.body.classList.remove(...themes); // Remove all existing theme classes.
            document.body.classList.add(themeName); // Add the new theme class.
            localStorage.setItem('jchat-theme', themeName); // Save theme preference to local storage.
        }

        /**
         * Toggles the loading state of a button, showing/hiding a spinner.
         * @param {HTMLButtonElement} buttonElement - The button element to toggle.
         * @param {boolean} isLoading - True to show loading state, false to hide.
         */
        function toggleButtonLoading(buttonElement, isLoading) {
            if (!buttonElement) return;
            const loader = buttonElement.querySelector('.button-loader');
            const text = buttonElement.querySelector('.button-text');

            if (isLoading) {
                buttonElement.disabled = true; // Disable button during loading.
                buttonElement.classList.add('loading');
                if (loader) loader.classList.add('active');
                if (text) text.style.display = 'none';
            } else {
                buttonElement.disabled = false; // Re-enable button.
                buttonElement.classList.remove('loading');
                if (loader) loader.classList.remove('active');
                if (text) text.style.display = 'block';
            }
        }

        /**
         * Enables or disables all interactive elements on the page based on a global state.
         * This is primarily used for maintenance mode or initial loading.
         * @param {boolean} enable - True to enable, false to disable.
         * @param {boolean} isCurrentUserAdmin - True if the current user is an admin (allows bypass for some features).
         */
        function toggleInteractiveElements(enable, isCurrentUserAdmin = false) {
            console.log(`JCHAT_DEBUG: toggleInteractiveElements called with enable: ${enable}, isAdmin: ${isCurrentUserAdmin}`);

            // If enabling, and it's an admin, we want to ensure everything is truly enabled.
            // Otherwise, apply the 'enable' state universally.
            const finalEnableState = enable || isCurrentUserAdmin; // If enable is true, or if it's an admin, enable.

            // Main content buttons/inputs
            if (sharePostInspirationButton) sharePostInspirationButton.disabled = !finalEnableState;
            if (customizeInspirationButton) customizeInspirationButton.disabled = !finalEnableState;
            if (claimDailyBonusButton) claimDailyBonusButton.disabled = !finalEnableState;
            if (postContentInput) postContentInput.disabled = !finalEnableState;
            if (postMediaUpload) postMediaUpload.disabled = !finalEnableState;
            if (createPostButton) createPostButton.disabled = !finalEnableState;

            // Dynamically created elements (posts, comments) - these will be refined by applySystemSettings later.
            // These are selected globally and then their disabled state is set.
            document.querySelectorAll('.comment-input').forEach(input => {
                input.disabled = !finalEnableState;
            });
            document.querySelectorAll('.submit-comment-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.react-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.comment-toggle-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.post-options-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.edit-post-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            // The delete-post-button is removed from here as per user request.
            document.querySelectorAll('.share-post-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.delete-comment-button').forEach(button => {
                button.disabled = !finalEnableState;
            });

            // Modals (buttons within modals)
            if (cancelCustomizeButton) cancelCustomizeButton.disabled = !finalEnableState;
            if (saveCustomizeButton) saveCustomizeButton.disabled = !finalEnableState;
            if (editPostContentInput) editPostContentInput.disabled = !finalEnableState;
            if (editPostMediaUpload) editPostMediaUpload.disabled = !finalEnableState;
            if (removeEditMediaButton) removeEditMediaButton.disabled = !finalEnableState;
            if (cancelEditPostButton) cancelEditPostButton.disabled = !finalEnableState;
            if (saveEditedPostButton) saveEditedPostButton.disabled = !finalEnableState;
            if (confirmCancelButton) confirmCancelButton.disabled = !finalEnableState;
            if (confirmProceedButton) confirmProceedButton.disabled = !finalEnableState;

            // Sidebar links (pointer-events and opacity, as they are not 'disabled' attributes).
            // These will be further refined by applySystemSettings for specific toggles.
            if (chatLink) {
                chatLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                chatLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (findFriendsLink) {
                findFriendsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                findFriendsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (friendsLink) {
                friendsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                friendsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (groupsLink) {
                groupsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                groupsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (jcoinShopLink) {
                jcoinShopLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                jcoinShopLink.style.opacity = finalEnableState ? '1' : '0.5';
            }

            // Guide link - also controlled by global enable state.
            const guideLink = document.querySelector('.sidebar-nav-item[href="/guide.html"]');
            if (guideLink) {
                guideLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                guideLink.style.opacity = finalEnableState ? '1' : '0.5';
            }

            console.log(`JCHAT_DEBUG: Finished toggling interactive elements. Post content input disabled state: ${postContentInput ? postContentInput.disabled : 'N/A (element not found)'}`);
        }

        /**
         * Handles user logout, signs out from Firebase, updates inCall status, and redirects.
         */
        async function handleLogout() {
            if (!isAuthReady || !currentUser) {
                showMessageBox("Not ready to log out or no user found.", 'info');
                return;
            }

            try {
                // Set user's inCall status to false in public profile on logout.
                if (currentUser && currentUserProfileData) {
                    const userPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                    await updateDoc(userPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on logout:", e));
                }

                // End any active WebRTC call before logging out.
                if (callState !== 'idle') {
                    await endCall(false); // End call without updating Firestore status to avoid conflicts during logout.
                }

                await signOut(auth); // Sign out from Firebase.
                showMessageBox("Logged out successfully! 👋", 'success');
                // Redirect to login page after a short delay.
                setTimeout(() => {
                    window.location.href = '/login.html';
                }, 1500);

            } catch (error) {
                console.error("JCHAT_ERROR: Error logging out:", error);
                showMessageBox(`Failed to log out: ${error.message}. Please try again.`, 'error');
            }
        }

        /**
         * Updates the profile picture URL for all posts authored by a specific user.
         * This ensures consistency across the feed when a user changes their profile picture.
         * @param {string} userId - The ID of the user whose posts need updating.
         * @param {string} newProfilePicId - The new Cloudinary public ID for the profile picture.
         */
        async function updatePostsWithNewProfilePic(userId, newProfilePicId) {
            if (!isAuthReady) return;
            try {
                const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
                const q = query(postsCollectionRef, where("authorId", "==", userId));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const batch = writeBatch(db); // Use a batch write for efficiency.
                    querySnapshot.forEach(docSnap => {
                        const postRef = doc(db, "artifacts", appId, "public", "data", "posts", docSnap.id);
                        batch.update(postRef, { profilePhoto: newProfilePicId });
                    });
                    await batch.commit(); // Commit all batched updates.
                    console.log(`JCHAT_DEBUG: Updated profile picture for ${querySnapshot.size} posts by user ${userId}.`);
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating posts with new profile picture:", error);
            }
        }

        /**
         * Fetches and displays the current user's profile information in the header.
         * Creates a new profile if one doesn't exist.
         * Also syncs public profile data and updates posts if profile pic changes.
         * @param {object} user - The Firebase user object.
         */
        async function fetchAndDisplayHeaderProfile(user) {
            console.log("JCHAT_DEBUG: Entering fetchAndDisplayHeaderProfile for user:", user.uid);
            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", user.uid, "profiles", "user_profile");
                const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);

                const privateDocSnap = await getDoc(privateProfileDocRef);
                let profileData = null;
                let oldProfilePicId = null;

                if (privateDocSnap.exists()) {
                    profileData = privateDocSnap.data();
                    oldProfilePicId = profileData.profilePicId;
                    console.log("JCHAT_DEBUG: Fetched existing private profile data:", profileData);
                } else {
                    // Create a new default profile if one doesn't exist.
                    profileData = {
                        username: user.displayName || `User_${user.uid.substring(0, 8)}`,
                        email: user.email || "",
                        profilePicId: user.photoURL || null,
                        bio: "",
                        location: "",
                        friendsCount: 0,
                        followersCount: 0,
                        followingCount: 0,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp(),
                        inspirationType: "motivational",
                        visibility: {
                            displayName: true, profilePic: true, bio: false, location: false,
                            emailPublic: false, allowFriendRequests: true, allowMessages: true,
                        },
                        totalPosts: 0,
                        jCoins: 0, // Ensure jCoins is initialized
                        gas: 0, // Ensure gas is initialized
                        level: 1, // Ensure level is initialized
                        currentXp: 0, // Ensure currentXp is initialized
                        xpToNextLevel: getLevelInfo(1).xpToNextLevel, // Ensure xpToNextLevel is initialized
                        lastLoginBonusClaimed: null, // Ensure lastLoginBonusClaimed is initialized
                        inCall: false, // Ensure inCall is initialized
                    };
                    await setDoc(privateProfileDocRef, profileData);
                    console.log("JCHAT_DEBUG: Created new private profile data:", profileData);
                }

                // Ensure new fields are present if they were added after initial profile creation (for existing users).
                const updates = {};
                if (profileData.gas === undefined) updates.gas = 0;
                if (profileData.level === undefined) updates.level = 1;
                if (profileData.currentXp === undefined) updates.currentXp = 0;
                if (profileData.xpToNextLevel === undefined || profileData.xpToNextLevel !== getLevelInfo(profileData.level || 1).xpToNextLevel) {
                     updates.xpToNextLevel = getLevelInfo(profileData.level || 1).xpToNextLevel;
                }
                if (profileData.lastLoginBonusClaimed === undefined) updates.lastLoginBonusClaimed = null;
                if (profileData.jCoins === undefined) updates.jCoins = 0; // Ensure jCoins is initialized
                if (profileData.inCall === undefined) updates.inCall = false; // Ensure inCall is initialized

                if (Object.keys(updates).length > 0) {
                    await updateDoc(privateProfileDocRef, updates);
                    const updatedSnap = await getDoc(privateProfileDocRef);
                    profileData = updatedSnap.data(); // Get the latest data after update.
                    console.log("JCHAT_DEBUG: Updated private profile with new fields:", updates);
                }

                currentUserProfileData = profileData; // Store the fetched/updated profile data globally.

                // For public profile, only include genuinely public fields and handle createdAt.
                const publicProfileUpdates = {
                    username: profileData.username,
                    profilePicId: profileData.profilePicId,
                    userId: user.uid,
                    totalPosts: profileData.totalPosts, // Ensure totalPosts is synced.
                    visibility: profileData.visibility, // Ensure visibility is synced.
                    updatedAt: serverTimestamp(),
                    inCall: profileData.inCall, // Sync inCall status to public profile.
                };
                // Only explicitly set createdAt if the public profile document does NOT exist.
                const publicDocSnap = await getDoc(publicProfileDocRef);
                if (!publicDocSnap.exists()) {
                    publicProfileUpdates.createdAt = serverTimestamp();
                }
                await setDoc(publicProfileDocRef, publicProfileUpdates, { merge: true }); // Use merge to avoid overwriting.
                console.log("JCHAT_DEBUG: Updated public profile summary:", publicProfileUpdates);


                const usernameInitial = (profileData.username || "J").charAt(0).toUpperCase();
                // Update header UI for profile picture and display name.
                if (headerProfilePic && headerAvatarIcon && headerDisplayName) {
                    displayProfilePicture(headerProfilePic, headerAvatarIcon, profileData?.profilePicId, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                    headerDisplayName.textContent = profileData.username || "JCHAT User";
                }

                // Ensure profile link is correct.
                if (profileLink) profileLink.href = `./Profile.html?userId=${user.uid}`;

                // If profile picture has changed, update all posts by this user.
                if (oldProfilePicId !== profileData.profilePicId) {
                    await updatePostsWithNewProfilePic(user.uid, profileData.profilePicId);
                }

                // Start displaying daily inspiration based on user's preference.
                startInspirationDisplay(currentUserProfileData.inspirationType || "motivational");
                await fetchNotificationCount(user.uid); // Fetch unread notification count.

                // Display admin icon if the current user is the admin.
                if (adminIconLink) {
                    if (user.uid === ADMIN_UID) {
                        adminIconLink.style.display = 'block';
                        console.log("JCHAT_DEBUG: Admin icon displayed.");
                    } else {
                        adminIconLink.style.display = 'none';
                        console.log("JCHAT_DEBUG: Admin icon hidden.");
                    }
                }

                console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile completed successfully.");

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching or creating profile for header:", error);
                // Fallback UI update in case of error.
                const usernameInitial = (user.displayName || "J").charAt(0).toUpperCase();
                if (headerProfilePic && headerAvatarIcon && headerDisplayName) {
                    displayProfilePicture(headerProfilePic, headerAvatarIcon, user.photoURL, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                    headerDisplayName.textContent = user.displayName || "JCHAT User";
                }
                showMessageBox(`Error loading header profile: ${error.message}`, 'error');

                console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile failed. Interactive elements might still be enabled if auth succeeded.");
            }
        }
        /**
         * Fetches the count of unread notifications for the current user.
         * @param {string} userId - The ID of the current user.
         */
        async function fetchNotificationCount(userId) {
            if (!isAuthReady) return;
            try {
                const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                const q = query(notificationsCollectionRef, where("read", "==", false));
                const querySnapshot = await getDocs(q);
                const unreadCount = querySnapshot.size;

                // Use the new updateNotificationBadge function
                updateNotificationBadge(unreadCount);
            }
            catch (error) {
                console.error("JCHAT_ERROR: Error fetching notification count:", error);
                updateNotificationBadge(0);
            }
        }

        // --- Inspiration Quotes Display (No LLM) ---
        /**
         * Retrieves a random quote from the local inspirationalQuotes data based on type.
         * @param {string} type - The category of inspiration (e.g., "motivational").
         * @returns {object} A quote object with 'quote' and 'author' properties.
         */
        function getGeneratedQuote(type = "motivational") {
            if (Math.random() < 0.8) return generateProceduralQuote(type);
            const list = inspirationalQuotes[type] || inspirationalQuotes.motivational;
            return list[Math.floor(Math.random() * list.length)];
        }

        /**
         * Deterministic, time-based inspiration (no randomness).
         * Varies by weekday, month, and part of day. Updates every minute.
         */
        function pickDeterministic(arr, seed) {
            if (!arr || arr.length === 0) return '';
            const idx = Math.abs(seed) % arr.length;
            return arr[idx];
        }
        function getPartOfDay(h) {
            if (h >= 5 && h < 12) return 'morning';
            if (h >= 12 && h < 17) return 'afternoon';
            if (h >= 17 && h < 21) return 'evening';
            return 'night';
        }
        function selectTypeByTime() {
            const now = new Date();
            const weekday = now.getDay(); // 0-6
            const hour = now.getHours();
            const part = getPartOfDay(hour);
            if (part === 'evening' && (weekday === 5 || weekday === 6)) return 'love';
            if ((weekday === 0 && (part === 'evening' || part === 'night'))) return 'peaceful';
            const map = ['motivational','wisdom','love','peaceful','funny','motivational','funny'];
            return map[weekday] || 'motivational';
        }
        function generateTimeBasedQuote(preferredType) {
            const now = new Date();
            const weekday = now.getDay();
            const month = now.getMonth();
            const hour = now.getHours();
            const minute = now.getMinutes();
            const seed = (weekday + 1) * 10000 + (month + 1) * 100 + hour * 10 + Math.floor(minute / 5);
            const type = preferredType && preferredType !== 'off' ? preferredType : selectTypeByTime();
            const t = quoteTemplates[type] || quoteTemplates.motivational;
            const open = pickDeterministic(t.openers, seed + 17);
            const bridge = pickDeterministic(t.bridges, seed + 31);
            const end = pickDeterministic(t.endings, seed + 53);
            return { quote: `${open}${bridge}${end}`, author: 'JCHAT' };
        }
        /**
         * Displays the time-based inspiration quote.
         */
        async function displayInspiration() {
            const chosen = (currentUserProfileData?.inspirationType) || null;
            if (chosen === 'off') {
                if (inspirationQuoteElement) inspirationQuoteElement.textContent = "Inspiration is turned off.";
                if (inspirationAuthorElement) inspirationAuthorElement.textContent = "";
                return;
            }
            const quoteData = generateTimeBasedQuote(chosen);
            if (inspirationQuoteElement) inspirationQuoteElement.textContent = `"${quoteData.quote}"`;
            if (inspirationAuthorElement) inspirationAuthorElement.textContent = `- ${quoteData.author}`;
        }

        /**
         * Starts the interval for displaying new inspiration quotes periodically.
         * @param {string} type - The inspiration type to display.
         */
        function startInspirationDisplay(type) {
            if (inspirationIntervalId) {
                clearInterval(inspirationIntervalId); // Clear any existing interval.
            }
            if (currentUserProfileData) {
                currentUserProfileData.inspirationType = type; // Update local profile data.
            }
            displayInspiration(); // Display initial quote immediately.
            inspirationIntervalId = setInterval(displayInspiration, 20 * 1000); // Refresh every 20 seconds.
        }

        /**
         * Opens the customization modal for daily inspiration.
         */
        function openCustomizeModal() {
            if (!isAuthReady) {
                showMessageBox("Please log in to customize inspiration.", 'error');
                return;
            }
            const currentType = currentUserProfileData?.inspirationType || "motivational";
            // Set the radio button corresponding to the current inspiration type.
            if (inspirationTypeRadios && typeof inspirationTypeRadios.forEach === 'function') {
                inspirationTypeRadios.forEach(radio => {
                    radio.checked = (radio.value === currentType);
                });
            }
            if (customizeInspirationModal) customizeInspirationModal.classList.add('active'); // Show modal.
        }
        /**
         * Closes the customization modal.
         */
        function closeCustomizeModal() {
            if (customizeInspirationModal) customizeInspirationModal.classList.remove('active');
        }

        /**
         * Saves the selected inspiration type to Firestore.
         */
        async function saveInspirationType() {
            if (!isAuthReady || !currentUser) {
                showMessageBox("You must be logged in to save settings.", 'error');
                return;
            }

            const selectedRadio = document.querySelector('input[name="inspirationType"]:checked');
            if (!selectedRadio) {
                showMessageBox("Please select an inspiration type.", 'info');
                return;
            }
            const newType = selectedRadio.value;

            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "profiles", "user_profile");
                await updateDoc(privateProfileDocRef, {
                    inspirationType: newType,
                    updatedAt: serverTimestamp()
                });
                if (currentUserProfileData) {
                    currentUserProfileData.inspirationType = newType; // Update local state.
                }
                startInspirationDisplay(newType); // Restart inspiration display with new type.
                showMessageBox("Inspiration type saved!", 'success');
                closeCustomizeModal();
            } catch (error) {
                console.error("JCHAT_ERROR: Error saving inspiration type:", error);
                showMessageBox(`Failed to save inspiration type: ${error.message}`, 'error');
            }
        }
        // Event listener for post media upload input.
        if (postMediaUpload) {
            postMediaUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                currentMediaFile = file; // Store the selected file.
                // Reset previews.
                if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                if (mediaImagePreview) mediaImagePreview.src = '';
                if (mediaVideoPreview) mediaVideoPreview.src = '';

                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (file.type.startsWith('image/')) {
                            if (mediaImagePreview) {
                                mediaImagePreview.src = e.target.result;
                                mediaImagePreview.style.display = 'block';
                            }
                        } else if (file.type.startsWith('video/')) {
                            if (mediaVideoPreview) {
                                mediaVideoPreview.src = e.target.result;
                                mediaVideoPreview.style.display = 'block';
                            }
                        }
                    };
                    reader.readAsDataURL(file); // Read file as Data URL for preview.
                }
            });
        }

        /**
         * Creates a new post with content and optional media.
         * Handles media upload, Firestore transaction, and pending reward creation.
         */
        async function createNewPost() {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("Please log in to create a post.", 'error');
                return;
            }

            // Check if post creation is enabled by system settings (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post creation is currently disabled by administrators.", 'warning');
                return;
            }

            const content = postContentInput.value.trim();
            if (!content && !currentMediaFile) {
                showMessageBox("Post content or media cannot be empty.", 'info');
                return;
            }

            toggleButtonLoading(createPostButton, true); // Show loading spinner.
            showMessageBox("Creating post...", 'loading', true); // Show persistent loading message.

            let mediaUrl = null;
            let mediaType = 'text';

            try {
                if (currentMediaFile) {
                    showMessageBox('Uploading media...', 'loading', true);
                    let fileToUpload = currentMediaFile;
                    // Resize image files before upload for optimization.
                    if (currentMediaFile.type.startsWith('image/')) {
                        fileToUpload = await resizeImage(currentMediaFile);
                    }
                    mediaUrl = await uploadMediaToCloudinary(fileToUpload);
                    if (mediaUrl) {
                        mediaType = currentMediaFile.type.startsWith('image/') ? 'image' : 'video';
                        showMessageBox('Media uploaded!', 'success');
                    } else {
                        throw new Error("Failed to upload media."); // Throw error if Cloudinary upload fails.
                    }
                }

                // Poll handling
                const pollEnabled = !!document.getElementById('addPollCheckbox')?.checked;
                let poll = null;
                if (pollEnabled) {
                    const optionEls = [...document.querySelectorAll('#pollComposer .poll-option-input')];
                    const options = optionEls.map(o => o.value.trim()).filter(Boolean).slice(0,6);
                    if (options.length >= 2) {
                        poll = { options: options.map(o => ({ text:o, votes:0 })), allowMultiple:false };
                    }
                }

                const postData = {
                    authorId: currentUser.uid,
                    username: currentUserProfileData.username || "JCHAT User",
                    profilePhoto: currentUserProfileData.profilePicId || null,
                    content: content,
                    timestamp: serverTimestamp(),
                    likesCount: 0,
                    commentsCount: 0,
                    isEdited: false,
                    status: 'active',
                    reactions: { like: 0, love: 0, haha: 0 },
                    mediaUrl: mediaUrl,
                    mediaType: mediaType,
                    visibility: 'public',
                    tags: [],
                    location: {},
                    poll: poll
                };

                let postId = null; // To store the ID of the newly created post.

                // Use a Firestore transaction to ensure atomicity for post creation.
                await runTransaction(db, async (transaction) => {
                    // Note: totalPosts update is removed here as it's now handled by admin approval of pending reward.
                    const newPostRef = doc(collection(db, "artifacts", appId, "public", "data", "posts"));
                    transaction.set(newPostRef, postData);
                    postId = newPostRef.id; // Get the ID of the new post.
                });

                // Create a pending reward for post creation for admin review.
                if (postId) {
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        'post_creation',
                        20, // Suggested XP for post creation.
                        5,  // Suggested JCoins for post creation.
                        null, // No specific activityId for post creation itself.
                        postId // Link to the created post.
                    );
                }

                showMessageBox("Post created successfully! 20 XP and 5 JCoins are pending admin review.", 'success', true);
                playNotificationSound('success');
                // Clear input fields and previews after successful post creation.
                postContentInput.value = '';
                if (postMediaUpload) postMediaUpload.value = '';
                if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                if (mediaImagePreview) mediaImagePreview.src = '';
                if (mediaVideoPreview) mediaVideoPreview.src = '';
                currentMediaFile = null;

            } catch (error) {
                console.error("JCHAT_ERROR: Error creating post:", error);
                showMessageBox(`Failed to create post: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(createPostButton, false); // Hide loading spinner.
            }
        }
        /**
         * Handles user reactions (like, love, haha) to a post.
         * Uses a transaction to update reaction counts and user's reaction status.
         * Creates a pending reward for the reaction.
         * @param {string} postId - The ID of the post being reacted to.
         * @param {string} reactionType - The type of reaction ('like', 'love', 'haha').
         */
        async function handleReaction(postId, reactionType) {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("You must be logged in to react.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled by system settings (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Reactions are currently disabled by administrators.", 'warning');
                return;
            }

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
            const userReactionRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "userReactions", currentUser.uid);

            try {
                let xpReward = 0;
                let jCoinReward = 0;
                let activityType = '';

                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    const userReactionDoc = await transaction.get(userReactionRef);

                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    const postData = postDoc.data();
                    let serverReactions = postData.reactions || { like: 0, love: 0, haha: 0 };
                    let serverLikesCount = postData.likesCount || 0;
                    let serverUserPreviousReaction = userReactionDoc.exists() ? userReactionDoc.data().type : null;

                    if (serverUserPreviousReaction === reactionType) {
                        // User is un-reacting: decrement count, delete user reaction document.
                        serverReactions[reactionType] = Math.max(0, serverReactions[reactionType] - 1);
                        if (reactionType === 'like') serverLikesCount = Math.max(0, serverLikesCount - 1);
                        transaction.delete(userReactionRef);
                        activityType = `unreact_${reactionType}`;
                        xpReward = -3; // Suggested XP deduction for un-reacting.
                        jCoinReward = -2; // Suggested JCoin deduction for un-reacting.
                    } else {
                        // User is reacting or changing reaction:
                        // If there was a previous reaction, decrement its count.
                        if (serverUserPreviousReaction) {
                            serverReactions[serverUserPreviousReaction] = Math.max(0, serverReactions[serverUserPreviousReaction] - 1);
                            if (serverUserPreviousReaction === 'like') serverLikesCount = Math.max(0, serverLikesCount - 1);
                        }
                        // Increment the new reaction type's count.
                        serverReactions[reactionType] = (serverReactions[reactionType] || 0) + 1;
                        if (reactionType === 'like') serverLikesCount = (serverLikesCount || 0) + 1;

                        // Set/update the user's reaction document.
                        transaction.set(userReactionRef, { type: reactionType, userId: currentUser.uid, timestamp: serverTimestamp() });
                        activityType = `react_${reactionType}`;
                        xpReward = 3; // Suggested XP for reacting.
                        jCoinReward = 2; // Suggested JCoins for reacting.
                    }

                    // Update the post document with new reaction counts.
                    transaction.update(postRef, {
                        reactions: serverReactions,
                        likesCount: serverLikesCount,
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for the reaction (or deduction for un-reaction).
                if (xpReward !== 0 || jCoinReward !== 0) {
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        activityType,
                        xpReward,
                        jCoinReward,
                        null, // No specific activityId for reaction itself.
                        postId
                    );
                }

                showMessageBox(`Reaction recorded! ${xpReward} XP and ${jCoinReward} JCoins are pending admin review.`, 'success');
                playNotificationSound('info');
            } catch (error) {
                console.error("JCHAT_ERROR: Error handling reaction (Firestore update failed):", error);
                showMessageBox(`Failed to update reaction: ${error.message}. Please refresh.`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Adds a new comment to a post.
         * Uses a transaction to update comment count on the post.
         * Creates a pending reward for the comment.
         * @param {string} postId - The ID of the post to comment on.
         * @param {string} commentText - The content of the comment.
         */
        async function addComment(postId, commentText) {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("You must be logged in to comment.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Commenting is currently disabled by administrators.", 'warning');
                return;
            }

            if (!commentText.trim()) {
                showMessageBox("Comment cannot be empty.", 'info');
                return;
            }

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
            const commentsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts", postId, "comments");

            try {
                let commentId = null;
                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    const newCommentRef = doc(commentsCollectionRef); // Create a new document reference for the comment.
                    const newComment = {
                        userId: currentUser.uid,
                        username: currentUserProfileData.username || "JCHAT User",
                        profilePhoto: currentUserProfileData.profilePicId || null,
                        content: commentText.trim(),
                        timestamp: serverTimestamp()
                    };
                    transaction.set(newCommentRef, newComment); // Set the new comment data.
                    commentId = newCommentRef.id; // Get the ID of the new comment.

                    const currentCommentsCount = postDoc.data().commentsCount || 0;
                    transaction.update(postRef, {
                        commentsCount: currentCommentsCount + 1, // Increment comments count on the post.
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for the comment for admin review.
                if (commentId) {
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        'post_comment',
                        2, // Suggested XP for commenting.
                        4,  // Suggested JCoins for commenting.
                        commentId, // Pass commentId as activityId.
                        postId
                    );
                }

                showMessageBox("Comment added! 2 XP and 4 JCoins are pending admin review.", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error adding comment:", error);
                showMessageBox(`Failed to add comment: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Deletes a comment from a post.
         * Only the comment author or an admin can delete a comment.
         * Uses a transaction to decrement comment count on the post.
         * Creates a pending reward for the deletion (negative XP/JCoins).
         * @param {string} postId - The ID of the post the comment belongs to.
         * @param {string} commentId - The ID of the comment to delete.
         * @param {string} commentAuthorId - The ID of the user who authored the comment.
         */
        async function deleteComment(postId, commentId, commentAuthorId) {
            // Check permissions: current user must be the comment author or an admin.
            if (!isAuthReady || !currentUser || (currentUser.uid !== commentAuthorId && currentUser.uid !== ADMIN_UID)) {
                showMessageBox("You can only delete your own comments unless you are an admin.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Commenting is currently disabled by administrators, so deletion is also restricted.", 'warning');
                return;
            }

            // Show confirmation modal before proceeding with deletion.
            const confirmed = await showConfirmationModal(
                "Delete Comment",
                "Are you sure you want to delete this comment? This action cannot be undone."
            );
            if (!confirmed) {
                return;
            }

            showMessageBox("Deleting comment...", 'loading', true);

            const commentRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "comments", commentId);
            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);

            try {
                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    transaction.delete(commentRef); // Delete the comment document.

                    const currentCommentsCount = postDoc.data().commentsCount || 0;
                    transaction.update(postRef, {
                        commentsCount: Math.max(0, currentCommentsCount - 1), // Decrement comments count.
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for comment deletion (negative XP/JCoins).
                await createPendingActivityReward(
                    commentAuthorId, // The user who originally posted the comment.
                    currentUserProfileData.username, // Using current user's username for logging purposes.
                    'comment_deletion',
                    -2, // Suggested XP deduction for deleting a comment.
                    -4,  // Suggested JCoin deduction for deleting a comment.
                    commentId, // Pass commentId as activityId.
                    postId
                );

                showMessageBox("Comment deleted successfully!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting comment:", error);
                showMessageBox(`Failed to delete comment: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Opens the edit post modal and populates it with existing post data.
         * @param {string} postId - The ID of the post to edit.
         * @param {string} currentContent - The current text content of the post.
         * @param {string|null} currentMediaUrl - The current media URL of the post.
         * @param {string} currentMediaType - The current media type of the post ('image', 'video', 'text').
         */
        function openEditPostModal(postId, currentContent, currentMediaUrl, currentMediaType) {
            if (!isAuthReady || !currentUser) {
                showMessageBox("You must be logged in to edit posts.", 'error');
                return;
            }
            // Check if post creation (and thus editing) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post editing is currently disabled by administrators.", 'warning');
                return;
            }

            currentEditPostId = postId;
            if (editPostContentInput) editPostContentInput.value = currentContent;
            currentEditMediaUrl = currentMediaUrl;
            currentEditMediaType = currentMediaType;
            currentEditMediaFile = null; // Clear any previously selected new media file.

            // Reset media previews and remove media button.
            if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
            if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.src = '';
            if (editMediaVideoPreview) editMediaVideoPreview.src = '';
            if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

            // Display existing media if available.
            if (currentMediaUrl) {
                if (currentMediaType === 'image') {
                    if (editMediaImagePreview) {
                        editMediaImagePreview.src = currentMediaUrl;
                        editMediaImagePreview.style.display = 'block';
                    }
                } else if (currentMediaType === 'video') {
                    if (editMediaVideoPreview) {
                        editMediaVideoPreview.src = currentMediaUrl;
                        editMediaVideoPreview.style.display = 'block';
                    }
                }
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'inline-block'; // Show remove media button.
            }

            if (editPostModal) editPostModal.classList.add('active'); // Show edit modal.
        }

        // Event listener for edit post media upload input.
        if (editPostMediaUpload) {
            editPostMediaUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                currentEditMediaFile = file; // Store the newly selected file.
                // Reset previews and hide remove media button.
                if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                if (editMediaImagePreview) editMediaImagePreview.src = '';
                if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (file.type.startsWith('image/')) {
                            if (editMediaImagePreview) {
                                editMediaImagePreview.src = e.target.result;
                                editMediaImagePreview.style.display = 'block';
                            }
                        } else if (file.type.startsWith('video/')) {
                            if (editMediaVideoPreview) {
                                editMediaVideoPreview.src = e.target.result;
                                editMediaVideoPreview.style.display = 'block';
                            }
                        }
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        // Event listener for removing media from an edited post.
        if (removeEditMediaButton) {
            removeEditMediaButton.addEventListener('click', () => {
                currentEditMediaFile = null;
                currentEditMediaUrl = null;
                currentEditMediaType = 'text';
                // Clear and hide all media related elements.
                if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                if (editMediaImagePreview) editMediaImagePreview.src = '';
                if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                if (editPostMediaUpload) editPostMediaUpload.value = ''; // Clear file input.
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
                showMessageBox("Media removed.", "info");
            });
        }

        /**
         * Saves the changes made to an edited post.
         * Handles new media upload, updates Firestore, and shows messages.
         */
        async function saveEditedPost() {
            if (!isAuthReady || !currentUser || !currentEditPostId) {
                showMessageBox("No post selected for editing.", 'error');
                return;
            }
            // Check if post creation (and thus editing) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post editing is currently disabled by administrators.", 'warning');
                return;
            }

            const newContent = editPostContentInput.value.trim();
            if (!newContent && !currentEditMediaFile && !currentEditMediaUrl) {
                showMessageBox("Post content or media cannot be empty.", 'info');
                return;
            }

            toggleButtonLoading(saveEditedPostButton, true); // Show loading spinner.
            showMessageBox("Saving changes...", 'loading', true); // Show persistent loading message.

            let finalMediaUrl = currentEditMediaUrl;
            let finalMediaType = currentEditMediaType;

            try {
                if (currentEditMediaFile) {
                    showMessageBox('Uploading new media...', 'loading', true);
                    let fileToUpload = currentEditMediaFile;
                    // Resize image files before upload.
                    if (currentEditMediaFile.type.startsWith('image/')) {
                        fileToUpload = await resizeImage(currentEditMediaFile);
                    }
                    finalMediaUrl = await uploadMediaToCloudinary(fileToUpload);
                    if (finalMediaUrl) {
                        finalMediaType = currentEditMediaFile.type.startsWith('image/') ? 'image' : 'video';
                        showMessageBox('New media uploaded!', 'success');
                    } else {
                        throw new Error("Failed to upload new media.");
                    }
                } else if (!currentEditMediaUrl && !currentEditMediaFile) {
                    // If no existing media and no new media, set to null/text.
                    finalMediaUrl = null;
                    finalMediaType = 'text';
                }

                const postRef = doc(db, "artifacts", appId, "public", "data", "posts", currentEditPostId);
                await updateDoc(postRef, {
                    content: newContent,
                    mediaUrl: finalMediaUrl,
                    mediaType: finalMediaType,
                    isEdited: true, // Mark post as edited.
                    updatedAt: serverTimestamp()
                });

                showMessageBox("Post updated successfully!", 'success');
                playNotificationSound('success');
                closeEditPostModal(); // Close the modal after successful save.
            } catch (error) {
                console.error("JCHAT_ERROR: Error saving edited post:", error);
                showMessageBox(`Failed to save changes: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(saveEditedPostButton, false); // Hide loading spinner.
            }
        }

        /**
         * Closes the edit post modal and resets its fields.
         */
        function closeEditPostModal() {
            if (editPostModal) editPostModal.classList.remove('active');
            if (editPostContentInput) editPostContentInput.value = '';
            if (editPostMediaUpload) editPostMediaUpload.value = '';
            if (mediaImagePreview) mediaImagePreview.style.display = 'none';
            if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
            if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.src = '';
            if (editMediaVideoPreview) editMediaVideoPreview.src = '';
            if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
            // Reset global state variables for editing.
            currentEditPostId = null;
            currentEditMediaFile = null;
            currentEditMediaUrl = null;
            currentEditMediaType = null;
        }

        // The deletePost function is no longer called from the UI, but it's kept here just in case it's needed elsewhere.
        /**
         * Deletes a post from Firestore.
         * Only the post author or an admin can delete a post.
         * Creates a pending reward for the deletion (negative XP/JCoins).
         * @param {string} postId - The ID of the post to delete.
         * @param {string} postAuthorId - The ID of the user who authored the post.
         */
        async function deletePost(postId, postAuthorId) {
            // Check permissions: current user must be the post author or an admin.
            if (!isAuthReady || !currentUser || (currentUser.uid !== postAuthorId && currentUser.uid !== ADMIN_UID)) {
                showMessageBox("You can only delete your own posts unless you are an admin.", 'error');
                return;
            }
            // Check if post creation (and thus deletion) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post deletion is currently disabled by administrators.", 'warning');
                return;
            }

            // Show confirmation modal before proceeding.
            const confirmed = await showConfirmationModal(
                "Delete Post",
                "Are you sure you want to delete this post? This action cannot be undone."
            );
            if (!confirmed) {
                return;
            }

            showMessageBox("Deleting post...", 'loading', true);

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);

            try {
                await runTransaction(db, async (transaction) => {
                    transaction.delete(postRef); // Delete the post document.
                });

                // Create a pending reward for post deletion (negative XP/JCoins).
                await createPendingActivityReward(
                    postAuthorId, // The user who originally posted.
                    currentUserProfileData.username, // Using current user's username for logging purposes.
                    'post_deletion',
                    -20, // Suggested XP deduction for deleting a post.
                    -5,  // Suggested JCoin deduction for deleting a post.
                    null,
                    postId
                );

                showMessageBox("Post deleted successfully!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting post:", error);
                showMessageBox(`Failed to delete post: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }
        /**
         * Renders a single post HTML element.
         * @param {object} post - The post data object from Firestore.
         * @param {string} postId - The ID of the post.
         * @returns {HTMLElement} The created post HTML element.
         */
        function renderPost(post, postId) {
            const isAuthor = currentUser && currentUser.uid === post.authorId;
            const authorInitial = (post.username || 'J').charAt(0).toUpperCase();

            const postElement = document.createElement('div');
            postElement.classList.add('post-card');
            postElement.setAttribute('data-post-id', postId);

            // Construct the inner HTML for the post card.
            postElement.innerHTML = `
                <div class="post-header">
                    <a href="/profile.html?userId=${post.authorId}" aria-label="View ${post.username || 'Anonymous'}'s Profile">
                        <div class="author-pic-wrapper">
                            ${post.profilePhoto ?
                                `<img src="${getCloudinaryImageUrl(post.profilePhoto, 'w_80,h_80,c_fill,g_face,r_max')}" alt="Author Pic" class="author-pic" onerror="this.onerror=null; this.src='https://placehold.co/80x80/CCCCCC/000000?text=${authorInitial}';">` :
                                `<i class="fas fa-user-circle author-pic-placeholder" role="img" aria-label="Author Avatar"></i>`
                            }
                        </div>
                    </a>
                    <div class="author-info">
                        <a href="/profile.html?userId=${post.authorId}" class="author-name">${post.username || 'Anonymous'}</a>
                        <p class="post-timestamp">${post.timestamp ? new Date(post.timestamp.toDate()).toLocaleString() : 'N/A'} ${post.isEdited ? '(Edited)' : ''}</p>
                    </div>
                    ${isAuthor || (currentUser && currentUser.uid === ADMIN_UID) ? `
                    <button class="post-options-button" data-post-id="${postId}" data-author-id="${post.authorId}" data-timestamp="${post.timestamp ? post.timestamp.toDate().getTime() : 0}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Post Options">
                        <i class="fas fa-ellipsis-h"></i>
                    </button>
                    <div class="post-options-dropdown" id="dropdown-${postId}">
                        <button class="edit-post-button" data-post-id="${postId}" data-content="${post.content}" data-media-url="${post.mediaUrl || ''}" data-media-type="${post.mediaType || 'text'}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) || (!isAuthor && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Edit Post">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="delete-post-button" data-post-id="${postId}" data-author-id="${post.authorId}" style="display:none;" aria-label="Delete Post">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                        <button class="share-post-button" data-post-id="${postId}" data-content="${post.content}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Share Post">
                            <i class="fas fa-share"></i> Share
                        </button>
                    </div>
                    ` : ''}
                </div>
                <div class="post-content-text">
                    <p>${post.content}</p>
                </div>
                ${post.poll && post.poll.options ? `
                <div class="post-poll" data-post-id="${postId}">
                    ${post.poll.options.map((opt, i)=>`<button class=\"poll-vote-button\" data-post-id=\"${postId}\" data-index=\"${i}\">${opt.text} — <span class=\"poll-votes\">${opt.votes||0}</span></button>`).join('')}
                </div>` : ''}
                ${post.mediaUrl ? `
                <div class="post-media">
                    ${post.mediaType === 'image' ?
                        `<img src="${post.mediaUrl}" alt="Post Media" onerror="this.style.display='none';">` :
                        `<video src="${post.mediaUrl}" controls onerror="this.style.display='none';"></video>`
                    }
                </div>` : ''}
                <div class="post-reactions-summary">
                    <span>
                        <i class="fas fa-thumbs-up" style="color:var(--blue);"></i> <span class="like-count">${post.reactions?.like || 0}</span>
                        <i class="fas fa-heart" style="color:var(--pink);"></i> <span class="love-count">${post.reactions?.love || 0}</span>
                        <i class="fas fa-face-laugh" style="color:#ffd700;"></i> <span class="haha-count">${post.reactions?.haha || 0}</span>
                    </span>
                    <span><span class="comments-count">${post.commentsCount || 0}</span> Comments</span>
                </div>
                <div class="post-actions-row">
                    <button class="post-action-button save-post-button" data-post-id="${postId}" aria-label="Save Post">
                        <i class="fas fa-bookmark"></i> Save
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="like" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Like Post">
                        <i class="fas fa-thumbs-up"></i> Like
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="love" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Love Post">
                        <i class="fas fa-heart"></i> Love
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="haha" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Haha Post">
                        <i class="fas fa-face-laugh"></i> Haha
                    </button>
                    <button class="post-action-button comment-toggle-button" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Toggle Comments">
                        <i class="fas fa-comment"></i> Comment
                    </button>
                </div>
                <div class="comments-section" style="display:none;">
                    <div class="comments-list" id="comments-list-${postId}">
                        <p style="font-size:0.85rem; color:var(--text-light); text-align:left; margin-left:10px;" class="no-comments-message">No comments yet.</p>
                    </div>
                    <div class="comment-input-area">
                        <textarea placeholder="Write a comment..." class="comment-input" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Write a comment"></textarea>
                        <button class="submit-comment-button" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Post Comment">Post</button>
                    </div>
                </div>
            `;
            return postElement;
        }
        /**
         * Renders a single comment HTML element.
         * @param {object} comment - The comment data object from Firestore.
         * @param {string} commentId - The ID of the comment.
         * @param {string} postId - The ID of the post the comment belongs to.
         * @returns {HTMLElement} The created comment HTML element.
         */
        function renderComment(comment, commentId, postId) {
            const commentAuthorInitial = (comment.username || 'J').charAt(0).toUpperCase();
            const isCommentOwner = currentUser && currentUser.uid === comment.userId;

            const commentElement = document.createElement('div');
            commentElement.classList.add('comment-item');
            commentElement.setAttribute('data-comment-id', commentId);
            commentElement.innerHTML = `
                <a href="./Profile.html?userId=${comment.userId}" aria-label="View ${comment.username || 'Anonymous'}'s Profile">
                    <div class="author-pic-wrapper" style="width:30px; height:30px; border-width:1px;">
                        ${comment.profilePhoto ?
                            `<img src="${getCloudinaryImageUrl(comment.profilePhoto, 'w_60,h_60,c_fill,g_face,r_max')}" alt="Author Pic" class="comment-author-pic" onerror="this.onerror=null; this.src='https://placehold.co/60x60/CCCCCC/000000?text=${commentAuthorInitial}';">` :
                            `<i class="fas fa-user-circle comment-author-pic-placeholder" style="font-size:30px;" role="img" aria-label="Comment Author Avatar"></i>`
                        }
                    </div>
                </a>
                <div class="comment-content-wrapper">
                    <a href="./Profile.html?userId=${comment.userId}" class="comment-author-name">${comment.username || 'Anonymous'}</a>
                    <span class="comment-text">${comment.content}</span>
                    <span class="comment-timestamp">${comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleString() : 'N/A'}</span>
                    ${isCommentOwner || (currentUser && currentUser.uid === ADMIN_UID) ? `<button class="delete-comment-button" data-post-id="${postId}" data-comment-id="${commentId}" data-comment-author-id="${comment.userId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) || (!isCommentOwner && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Delete Comment"><i class="fas fa-trash-alt"></i></button>` : ''}
                </div>
            `;
            return commentElement;
        }
        /**
         * Fetches and displays posts in real-time using Firestore onSnapshot.
         * Manages post and comment listeners, and updates the UI dynamically.
         */
        async function fetchAndDisplayPosts() {
            console.log("JCHAT_DEBUG: fetchAndDisplayPosts called. isAuthReady:", isAuthReady);
            if (loadingPostsMessage) loadingPostsMessage.style.display = 'block'; // Show loading message.

            // Detach previous listeners to prevent memory leaks and duplicate updates.
            unsubscribeListeners.forEach(unsubscribe => {
                if (typeof unsubscribe === 'function') {
                    unsubscribe();
                }
            });
            unsubscribeListeners = []; // Clear the array of unsubscribe functions.
            if (postsFeed) postsFeed.innerHTML = ''; // Clear existing posts from the DOM.

            if (!postsFeed) {
                console.error("JCHAT_CRITICAL_ERROR: 'postsFeed' element not found in the DOM. Cannot display posts.");
                const mainContent = document.querySelector('main .content-wrapper');
                if (mainContent) {
                    mainContent.innerHTML = '<p style="text-align: center; color: var(--text-light); font-size: 1.1rem;">An error occurred loading content. Please refresh the page.</p>';
                }
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                return;
            }

            try {
                const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
                const q = query(postsCollectionRef, orderBy("timestamp", "desc")); // Order posts by timestamp descending.

                // Set up real-time listener for posts.
                const unsubscribePosts = onSnapshot(q, (querySnapshot) => {
                    console.log("JCHAT_DEBUG: onSnapshot for posts triggered. Number of posts:", querySnapshot.size);
                    const currentPostElements = new Map(); // Map to store current DOM elements by postId for efficient updates.
                    postsFeed.querySelectorAll('.post-card').forEach(card => {
                        currentPostElements.set(card.dataset.postId, card);
                    });

                    // Read filters
                    const typeFilter = postTypeFilter?.value || 'all';
                    const textSearch = (postSearchInput?.value || '').toLowerCase();
                    const fromDate = postDateFromInput?.value ? new Date(postDateFromInput.value + 'T00:00:00') : null;
                    const toDate = postDateToInput?.value ? new Date(postDateToInput.value + 'T23:59:59.999') : null;
                    const savedOnly = !!(showSavedOnlyCheckbox && showSavedOnlyCheckbox.checked);

                    const newOrderedPostIds = []; // To maintain the correct order of posts in the DOM.

                    querySnapshot.forEach(docSnapshot => {
                        const post = docSnapshot.data();
                        const postId = docSnapshot.id;

                        // Client-side filter
                        if (typeFilter !== 'all') {
                            const pType = post.mediaType ? post.mediaType : 'text';
                            if (pType !== typeFilter) return;
                        }
                        if (textSearch && !(post.content || '').toLowerCase().includes(textSearch)) return;
                        const ts = post.timestamp ? post.timestamp.toDate() : null;
                        if (fromDate && (!ts || ts < fromDate)) return;
                        if (toDate && (!ts || ts > toDate)) return;
                        if (savedOnly) {
                            const savedState = localStorage.getItem(`saved-post-${postId}`) === '1';
                            if (!savedState) return;
                        }

                        newOrderedPostIds.push(postId);

                        if (!postId) {
                            console.error("JCHAT_DEBUG: postId is undefined for a document snapshot. Skipping post.", docSnapshot.id);
                            return;
                        }

                        let postElement = currentPostElements.get(postId);

                        if (postElement) {
                            // If post already exists in DOM, update its content.
                            const contentP = postElement.querySelector('.post-content-text p');
                            if (contentP) contentP.textContent = post.content;

                            let postMediaDiv = postElement.querySelector('.post-media');
                            if (post.mediaUrl) {
                                if (!postMediaDiv) {
                                    postMediaDiv = document.createElement('div');
                                    postMediaDiv.classList.add('post-media');
                                    postElement.insertBefore(postMediaDiv, postElement.querySelector('.post-reactions-summary'));
                                }
                                postMediaDiv.innerHTML = post.mediaType === 'image' ?
                                    `<img src="${post.mediaUrl}" alt="Post Media" onerror="this.style.display='none';">` :
                                    `<video src="${post.mediaUrl}" controls onerror="this.style.display='none';"></video>`;
                                postMediaDiv.style.display = 'block';
                            } else if (postMediaDiv) {
                                postMediaDiv.remove(); // Remove media div if media was removed from post.
                            }

                            const timestampElement = postElement.querySelector('.post-timestamp');
                            if (timestampElement) {
                                timestampElement.textContent = `${post.timestamp ? new Date(post.timestamp.toDate()).toLocaleString() : 'N/A'} ${post.isEdited ? '(Edited)' : ''}`;
                            }

                            // Update reactions summary counts.
                            const summaryLikeCountElement = postElement.querySelector('.post-reactions-summary .like-count');
                            const summaryLoveCountElement = postElement.querySelector('.post-reactions-summary .love-count');
                            const summaryHahaCountElement = postElement.querySelector('.post-reactions-summary .haha-count');
                            if (summaryLikeCountElement) summaryLikeCountElement.textContent = post.reactions?.like || 0;
                            if (summaryLoveCountElement) summaryLoveCountElement.textContent = post.reactions?.love || 0;
                            if (summaryHahaCountElement) summaryHahaCountElement.textContent = post.reactions?.haha || 0;

                            // Update comments count.
                            const commentsCountElement = postElement.querySelector('.post-reactions-summary .comments-count');
                            if (commentsCountElement) commentsCountElement.textContent = post.commentsCount || 0;

                        } else {
                            // If post is new, create and append a new element.
                            postElement = renderPost(post, postId);
                            postsFeed.appendChild(postElement); // Add to DOM.
                        }

                        // Always ensure comment inputs and buttons are enabled/disabled based on current auth state and system settings.
                        const commentInput = postElement.querySelector('.comment-input');
                        const submitCommentButton = postElement.querySelector('.submit-comment-button');
                        if (commentInput) commentInput.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID);
                        if (submitCommentButton) submitCommentButton.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID);


                        // Setup onSnapshot for comments for this specific post.
                        const commentsListElement = document.getElementById(`comments-list-${postId}`);
                        if (commentsListElement && !commentsListElement.dataset.listenerAttached) { // Prevent attaching multiple listeners.
                            const commentsQuery = query(
                                collection(db, "artifacts", appId, "public", "data", "posts", postId, "comments"),
                                orderBy("timestamp", "asc")
                            );
                            const unsubscribeComments = onSnapshot(commentsQuery, (commentsSnapshot) => {
                                if (!commentsListElement) {
                                    console.error("JCHAT_ERROR: Comments list element not found for postId:", postId);
                                    return;
                                }
                                commentsListElement.innerHTML = ''; // Clear existing comments.

                                if (commentsSnapshot.empty) {
                                    commentsListElement.innerHTML = '<p style="font-size:0.85rem; color:var(--text-light); text-align:left; margin-left:10px;" class="no-comments-message">No comments yet.</p>';
                                } else {
                                    commentsSnapshot.forEach(commentDoc => {
                                        const comment = commentDoc.data();
                                        const commentId = commentDoc.id;
                                        commentsListElement.appendChild(renderComment(comment, commentId, postId));
                                    });
                                }
                                // Re-apply disabled state to delete comment buttons after rendering.
                                commentsListElement.querySelectorAll('.delete-comment-button').forEach(button => {
                                    const commentAuthorId = button.dataset.commentAuthorId;
                                    const isCommentOwner = currentUser && currentUser.uid === commentAuthorId;
                                    button.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) || (!isCommentOwner && currentUser.uid !== ADMIN_UID);
                                });
                            });
                            unsubscribeListeners.push(unsubscribeComments); // Add comment listener to the unsubscribe list.
                            commentsListElement.dataset.listenerAttached = 'true'; // Mark listener as attached.
                        }

                        // Setup onSnapshot for current user's reaction to this post (for newly added posts and updates).
                        if (currentUser) {
                            const userReactionRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "userReactions", currentUser.uid);
                            // Only attach if not already attached for this post and user.
                            if (!postElement.dataset.userReactionListenerAttached) {
                                const unsubscribeUserReaction = onSnapshot(userReactionRef, (reactionSnap) => {
                                    const currentPostCard = postsFeed.querySelector(`.post-card[data-post-id="${postId}"]`);
                                    if (currentPostCard) {
                                        const likeBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="like"]`);
                                        const loveBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="love"]`);
                                        const hahaBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="haha"]`);

                                        // Ensure buttons exist before manipulating classes.
                                        if (likeBtn) likeBtn.classList.remove('reacted-like');
                                        if (loveBtn) loveBtn.classList.remove('reacted-love');
                                        if (hahaBtn) hahaBtn.classList.remove('reacted-haha');

                                        if (reactionSnap.exists()) {
                                            const reactionData = reactionSnap.data();
                                            const activeReactionButton = currentPostCard.querySelector(`.react-button[data-reaction-type="${reactionData.type}"]`);
                                            if (activeReactionButton) {
                                                activeReactionButton.classList.add(`reacted-${reactionData.type}`);
                                            }
                                        }
                                    }
                                });
                                unsubscribeListeners.push(unsubscribeUserReaction); // Add user reaction listener to unsubscribe list.
                                postElement.dataset.userReactionListenerAttached = 'true'; // Mark listener as attached.
                            }
                        }
                    });

                    // Reorder posts in the DOM if necessary (important for orderBy).
                    const orderedElements = newOrderedPostIds.map(id => postsFeed.querySelector(`.post-card[data-post-id="${id}"]`));
                    orderedElements.forEach((element, index) => {
                        if (element && postsFeed.children[index] !== element) {
                            postsFeed.insertBefore(element, postsFeed.children[index]);
                        }
                    });

                    // Remove posts that no longer exist in the query snapshot (after reordering, to avoid re-inserting removed elements).
                    currentPostElements.forEach((element, id) => {
                        if (!newOrderedPostIds.includes(id)) {
                            element.remove();
                        }
                    });

                    // Display "No posts yet" message if the feed is empty.
                    if (querySnapshot.empty) {
                        if (!document.getElementById('noPostsMessage')) {
                            postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);" id="noPostsMessage">No posts yet. Be the first to post!</p>';
                        }
                    } else {
                        const noPostsMessage = document.getElementById('noPostsMessage');
                        if (noPostsMessage) noPostsMessage.remove();
                    }

                    if (loadingPostsMessage) loadingPostsMessage.style.display = 'none'; // Hide loading message.
                    // After posts are rendered/updated, apply system settings to their interactive elements.
                    applySystemSettings(currentSystemSettings);

                });
                unsubscribeListeners.push(unsubscribePosts); // Add the main posts listener to the unsubscribe list.

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching posts:", error);
                showMessageBox(`Error loading posts: ${error.message}`, 'error');
                if (postsFeed) postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);">Failed to load posts. Please try again later.</p>';
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
            }
        }


        // --- Event Delegation for Dynamic Elements ---
        // Attaches a single click listener to the document and delegates events to dynamically created elements.
        document.addEventListener('click', (event) => {
            // Handle React Buttons
            if (event.target.closest('.react-button')) {
                const button = event.target.closest('.react-button');
                if (!isAuthReady) { showMessageBox("Please log in to react.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Reactions are currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const reactionType = button.dataset.reactionType;
                handleReaction(postId, reactionType);
            }
            // Handle Poll Vote
            else if (event.target.closest('.poll-vote-button')) {
                const btn = event.target.closest('.poll-vote-button');
                const postId = btn.dataset.postId;
                const index = parseInt(btn.dataset.index, 10);
                votePoll(postId, index);
            }
            // Handle Comment Toggle Buttons
            else if (event.target.closest('.comment-toggle-button')) {
                const button = event.target.closest('.comment-toggle-button');
                const commentsSection = button.closest('.post-card').querySelector('.comments-section');
                if (commentsSection) {
                    commentsSection.style.display = commentsSection.style.display === 'none' ? 'block' : 'none';
                }
            }
            // Handle Submit Comment Buttons
            else if (event.target.closest('.submit-comment-button')) {
                const button = event.target.closest('.submit-comment-button');
                if (!isAuthReady) { showMessageBox("Please log in to comment.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Commenting is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const commentInput = button.closest('.comment-input-area').querySelector('.comment-input');
                addComment(postId, commentInput.value);
                commentInput.value = ''; // Clear comment input after submission.
            }
            // Handle Post Options Buttons (ellipsis menu)
            else if (event.target.closest('.post-options-button')) {
                const button = event.target.closest('.post-options-button');
                if (!isAuthReady) { showMessageBox("Please log in to manage posts.", 'error'); return; }
                // Admin can always manage posts, regular users only if feature is enabled.
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post management is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const dropdown = document.getElementById(`dropdown-${postId}`);
                // Close any other open dropdowns.
                document.querySelectorAll('.post-options-dropdown.active').forEach(openDropdown => {
                    if (openDropdown.id !== `dropdown-${postId}`) {
                        openDropdown.classList.remove('active');
                    }
                });
                if (dropdown) dropdown.classList.toggle('active'); // Toggle visibility of the clicked dropdown.
                // Show delete if author and post older than 5 minutes
                const postCard = button.closest('.post-card');
                const createdText = postCard?.querySelector('.post-timestamp')?.textContent || '';
                // We rely on dataset we set later; fallback: always show for author to avoid parsing date strings
                const delBtn = dropdown?.querySelector('.delete-post-button');
                const isOwner = (currentUser && button.dataset.authorId === currentUser.uid);
                if (delBtn && isOwner) delBtn.style.display = '';
                event.stopPropagation(); // Prevent document click from closing it immediately.
            }
            // Handle Edit Post Button
            else if (event.target.closest('.delete-post-button')) {
                const btn = event.target.closest('.delete-post-button');
                const postId = btn.dataset.postId;
                const authorId = btn.dataset.authorId;
                if (!currentUser || currentUser.uid !== authorId) { showMessageBox('You can only delete your own post.', 'warning'); return; }
                // Check age
                const triggerBtn = document.querySelector(`.post-options-button[data-post-id="${postId}"]`);
                const ts = parseInt(triggerBtn?.dataset.timestamp || '0', 10);
                if (Date.now() - ts < 5*60*1000) { showMessageBox('Delete becomes available 5 minutes after posting.', 'info'); return; }
                (async ()=>{
                    try {
                        await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'posts', postId));
                        showMessageBox('Post deleted.', 'success');
                    } catch(e) { console.error(e); showMessageBox('Failed to delete post.', 'error'); }
                })();
            }
            else if (event.target.closest('.edit-post-button')) {
                const button = event.target.closest('.edit-post-button');
                if (!isAuthReady) { showMessageBox("Please log in to edit posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post editing is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const content = button.dataset.content;
                const mediaUrl = button.dataset.mediaUrl;
                const mediaType = button.dataset.mediaType;
                openEditPostModal(postId, content, mediaUrl, mediaType);
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting edit.
            }
            // Handle Delete Post Button (This button is now removed from renderPost function, but keeping the handler for robustness)
            else if (event.target.closest('.delete-post-button')) {
                const button = event.target.closest('.delete-post-button');
                // This block should ideally not be reached if the button is not rendered.
                // However, for safety, if it somehow appears, it will be handled.
                if (!isAuthReady) { showMessageBox("Please log in to delete posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post deletion is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const authorId = button.dataset.authorId;
                deletePost(postId, authorId);
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting delete.
            }
            // Handle Share Post Button
            else if (event.target.closest('.share-post-button')) {
                const button = event.target.closest('.share-post-button');
                if (!isAuthReady) { showMessageBox("Please log in to share posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post sharing is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const content = button.dataset.content;
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting share.
                openShareInspirationModal();
            }
            // Handle Delete Comment Button
            else if (event.target.closest('.delete-comment-button')) {
                const button = event.target.closest('.delete-comment-button');
                if (!isAuthReady) { showMessageBox("Please log in to delete comments.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Comment deletion is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const commentId = button.dataset.commentId;
                const commentAuthorId = button.dataset.commentAuthorId;
                deleteComment(postId, commentId, commentAuthorId);
            }
            // Close dropdowns if clicking anywhere else on the document (outside of a dropdown).
            else if (!event.target.closest('.post-options-dropdown')) {
                document.querySelectorAll('.post-options-dropdown.active').forEach(openDropdown => {
                    openDropdown.classList.remove('active');
                });
            }
        });

        // NEW: System Settings Logic
        // Document reference for global system settings in Firestore.
        const SYSTEM_SETTINGS_DOC_REF = doc(db, "artifacts", appId, "public", "data", "settings", "system_settings");

        /**
         * Fetches global system settings from Firestore.
         * If settings document doesn't exist, it creates it with default values.
         */
        async function fetchSystemSettings() {
            console.log("JCHAT_DEBUG: Fetching system settings...");
            try {
                const docSnap = await getDoc(SYSTEM_SETTINGS_DOC_REF);
                if (docSnap.exists()) {
                    currentSystemSettings = docSnap.data();
                    console.log("JCHAT_DEBUG: System settings fetched:", currentSystemSettings);
                } else {
                    console.warn("JCHAT_WARNING: System settings document not found. Initializing with default values.");
                    // Define default system settings.
                    currentSystemSettings = {
                        jcoinNairaRate: 7.5,
                        gasJcoinRate: 0.1,
                        dailyBonusAmount: 50,
                        defaultInspirationType: "motivational",
                        profanityFilterSensitivity: 5,
                        enableUserRegistration: true,
                        enableFriendRequests: true,
                        enablePublicChat: true,
                        enablePostCreation: true,
                        enableEmailNotifications: true,
                        maintenanceMode: false,
                        globalAnnouncement: "",
                        enableCalls: true, // NEW: Default to true for calls.
                    };
                    await setDoc(SYSTEM_SETTINGS_DOC_REF, currentSystemSettings); // Create the document.
                    console.log("JCHAT_DEBUG: Default system settings created.");
                }
                applySystemSettings(currentSystemSettings); // Apply settings immediately after fetching/initializing.
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching system settings:", error);
                showMessageBox(`Failed to load system settings: ${error.message}`, 'error', true);
            }
        }

        /**
         * Applies the fetched system settings to various UI elements and features.
         * Controls visibility and interactivity based on admin toggles and maintenance mode.
         * @param {object} settings - The system settings object.
         */
        function applySystemSettings(settings) {
            console.log("JCHAT_DEBUG: Applying system settings to UI:", settings);

            const isCurrentUserAdmin = currentUser && currentUser.uid === ADMIN_UID;

            // First, handle the global maintenance mode.
            if (settings.maintenanceMode) {
                if (isCurrentUserAdmin) {
                    // Admin bypasses maintenance overlay and global disabling.
                    if (maintenanceOverlay) maintenanceOverlay.classList.remove('active');
                    document.body.style.overflow = 'auto';
                    showMessageBox("JCHAT is in Maintenance Mode, but you (Admin) have full access.", 'info', true);
                    toggleInteractiveElements(true, true); // Enable everything for admin, pass isAdmin true.
                } else {
                    // Regular user sees maintenance overlay and all interactions are disabled.
                    if (maintenanceOverlay) {
                        maintenanceOverlay.classList.add('active');
                        if (maintenanceAnnouncementText) {
                            maintenanceAnnouncementText.textContent = settings.globalAnnouncement || "JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!";
                        }
                    }
                    toggleInteractiveElements(false, false); // Disable all interactions for regular users, pass isAdmin false.
                    document.body.style.overflow = 'hidden';
                    return; // IMPORTANT: Stop further processing of individual toggles for regular users in maintenance.
                }
            } else {
                // Maintenance mode is OFF for everyone.
                if (maintenanceOverlay) maintenanceOverlay.classList.remove('active');
                document.body.style.overflow = 'auto';
                toggleInteractiveElements(true, isCurrentUserAdmin); // Enable all interactions initially, pass isAdmin.
            }

            // Now, apply individual feature toggles.
            // These will refine the state set by the maintenance mode logic above.
            // For admins, these will apply normally. For regular users, if maintenance was ON,
            // this part is skipped. If maintenance was OFF, these apply normally.

            // Post Creation Section visibility and input states.
            if (postCreationSection) {
                if (settings.enablePostCreation || isCurrentUserAdmin) { // Admin can always see/use.
                    postCreationSection.style.display = 'flex';
                    if (postContentInput) postContentInput.disabled = false;
                    if (postMediaUpload) postMediaUpload.disabled = false;
                    if (createPostButton) createPostButton.disabled = false;
                } else {
                    postCreationSection.style.display = 'none';
                    if (postContentInput) postContentInput.disabled = true;
                    if (postMediaUpload) postMediaUpload.disabled = true;
                    if (createPostButton) createPostButton.disabled = true;
                }
            }

            // Sidebar links (only if they correspond to features that can be toggled).
            // These need to reflect the feature toggle, but also respect the overall `toggleInteractiveElements` state
            // which is set by maintenance mode. The `pointer-events` and `opacity` are good for this.
            if (chatLink) {
                if (settings.enablePublicChat || isCurrentUserAdmin) {
                    chatLink.style.pointerEvents = 'auto';
                    chatLink.style.opacity = '1';
                } else {
                    chatLink.style.pointerEvents = 'none';
                    chatLink.style.opacity = '0.5';
                }
            }
            if (findFriendsLink) {
                if (settings.enableFriendRequests || isCurrentUserAdmin) {
                    findFriendsLink.style.pointerEvents = 'auto';
                    findFriendsLink.style.opacity = '1';
                } else {
                    findFriendsLink.style.pointerEvents = 'none';
                    findFriendsLink.style.opacity = '0.5';
                }
            }
            if (friendsLink) {
                if (settings.enableFriendRequests || isCurrentUserAdmin) {
                    friendsLink.style.pointerEvents = 'auto';
                    friendsLink.style.opacity = '1';
                } else {
                    friendsLink.style.pointerEvents = 'none';
                    friendsLink.style.opacity = '0.5';
                }
            }
            if (groupsLink) { // Assuming a toggle for groups.
                // For now, groups are not explicitly tied to a system setting.
                // If a 'settings.enableGroups' existed, it would be used here.
                // Otherwise, its state is controlled by the global `toggleInteractiveElements`.
                groupsLink.style.pointerEvents = 'auto';
                groupsLink.style.opacity = '1';
            }
            if (jcoinShopLink) { // Assuming a toggle for shop.
                // For now, shop is not explicitly tied to a system setting.
                // If a 'settings.enableJCoinShop' existed, it would be used here.
                // Otherwise, its state is controlled by the global `toggleInteractiveElements`.
                jcoinShopLink.style.pointerEvents = 'auto';
                jcoinShopLink.style.opacity = '1';
            }

            // Re-apply disabled states to dynamically rendered post/comment elements.
            // This is crucial because these elements are rendered *before* settings are applied.
            document.querySelectorAll('.post-card').forEach(postCard => {
                const postId = postCard.dataset.postId;
                const postAuthorId = postCard.querySelector('.post-options-button')?.dataset.authorId || null; // Get authorId if options button exists.

                // Post actions (reactions, comments, options menu).
                postCard.querySelectorAll('.react-button, .comment-toggle-button').forEach(button => {
                    button.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);
                });

                // Comment input and submit button.
                const commentInput = postCard.querySelector('.comment-input');
                const submitCommentButton = postCard.querySelector('.submit-comment-button');
                if (commentInput) commentInput.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);
                if (submitCommentButton) submitCommentButton.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);

                // Delete comment buttons (more complex logic: can delete own if enabled, admin can delete any).
                postCard.querySelectorAll('.delete-comment-button').forEach(button => {
                    const commentAuthorId = button.dataset.commentAuthorId;
                    const isCommentOwner = currentUser && currentUser.uid === commentAuthorId;
                    button.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && !isCurrentUserAdmin) || (!isCommentOwner && !isCurrentUserAdmin);
                });

                // Post options (edit, share).
                postCard.querySelectorAll('.post-options-button, .edit-post-button, .share-post-button').forEach(button => {
                    // Only enable if current user is the author OR if current user is admin AND the feature is enabled.
                    // The isAuthor check is handled in renderPost, here we just control the disabled state based on settings and admin.
                    const isButtonAuthor = currentUser && currentUser.uid === postAuthorId;
                    button.disabled = !isAuthReady || ((!settings.enablePostCreation && !isCurrentUserAdmin) || (!isButtonAuthor && !isCurrentUserAdmin));
                });
            });

            // Re-evaluate daily bonus button state.
            checkAndStartDailyBonusTimer();
        }

        // WebRTC STUN/TURN servers (NEW)
        // Configuration for ICE servers, essential for WebRTC connection establishment.
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
            ]
        };

        /**
         * Initializes a new RTCPeerConnection.
         * Sets up onicecandidate and ontrack event handlers.
         * @returns {RTCPeerConnection} The initialized peer connection.
         */
        function createPeerConnection() {
            const pc = new RTCPeerConnection(iceServers);

            // Event handler for ICE candidates (network information).
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send ICE candidate to the other peer via Firestore.
                    if (callRef) {
                        const candidateData = JSON.parse(JSON.stringify(event.candidate)); // Deep copy to avoid Firestore issues.
                        if (isIncomingCall) { // If this peer is the receiver.
                            updateDoc(callRef, {
                                receiverCandidates: arrayUnion(candidateData)
                            }).catch(e => console.error("Error adding receiver candidate:", e));
                        } else { // If this peer is the caller.
                            updateDoc(callRef, {
                                callerCandidates: arrayUnion(candidateData)
                            }).catch(e => console.error("Error adding caller candidate:", e));
                        }
                    }
                }
            };

            // Event handler for remote media tracks.
            pc.ontrack = (event) => {
                // Attach remote stream to remoteVideo element.
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block';
                    remoteStream = event.streams[0];
                } else {
                    // Fallback for older browsers or individual tracks.
                    if (!remoteStream) {
                        remoteStream = new MediaStream();
                        remoteVideo.srcObject = remoteStream;
                        remoteVideo.style.display = 'block';
                    }
                    remoteStream.addTrack(event.track);
                }
            };

            return pc;
        }

        /**
         * Listens for incoming calls to the current user in real-time.
         */
        let unsubscribeCallListener = null; // Declare here so it can be cleared on unload.

        function listenForIncomingCalls() {
            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Unsubscribe from previous listener to prevent duplicates.
            }
            if (!currentUser) return;

            const callsCollectionRef = collection(db, "artifacts", appId, "public", "data", "calls");
            // Query for calls where current user is the receiver and status is 'ringing'.
            const q = query(callsCollectionRef, where("receiverId", "==", currentUser.uid), where("status", "==", "ringing"));

            unsubscribeCallListener = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    // No incoming calls.
                    stopRingingSound();
                    if (callState === 'ringing') { // If we were ringing and call disappeared (e.g., caller ended).
                        showMessageBox("Incoming call ended.", "info");
                        playNotificationSound('info');
                        endCall(false);
                    }
                    return;
                }

                const incomingCallDoc = snapshot.docs[0]; // Take the first incoming call.
                const callData = incomingCallDoc.data();

                // Check if calls are enabled by system settings (unless current user is admin).
                if (!currentSystemSettings.enableCalls && currentUser.uid !== ADMIN_UID) {
                    console.log("JCHAT_DEBUG: Calls disabled by admin. Declining incoming call.");
                    await updateDoc(incomingCallDoc.ref, { status: 'declined_by_system' });
                    showMessageBox("Incoming call declined: Calls are currently disabled by administrators.", "warning", true, 5000);
                    playNotificationSound('error');
                    return;
                }

                if (callState !== 'idle') {
                    // Already in a call or busy, decline new incoming call.
                    await updateDoc(incomingCallDoc.ref, { status: 'busy' });
                    showMessageBox(`Another call from ${callData.callerId === recipientUserProfileData?.userId ? recipientUserProfileData?.username : 'someone'} is incoming, but you are busy.`, "warning");
                    playNotificationSound('info');
                    return;
                }

                // New incoming call detected.
                callRef = incomingCallDoc.ref; // Store reference to the call document.
                isIncomingCall = true;
                callState = 'ringing';
                currentCallType = callData.callType;

                // Fetch caller's profile for display in the UI.
                const callerProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", callData.callerId);
                const callerProfileSnap = await getDoc(callerProfileDocRef);
                const callerUsername = callerProfileSnap.exists() ? callerProfileSnap.data().username : 'Unknown User';
                recipientUserProfileData = callerProfileSnap.exists() ? callerProfileSnap.data() : null; // Set recipient for UI.

                // Update call overlay UI.
                callOverlay.classList.add('active');
                callOverlay.classList.remove('voice-call', 'video-call'); // Clear previous call type classes.
                callOverlay.classList.add(currentCallType === 'voice' ? 'voice-call' : 'video-call');

                callStatusIcon.className = `fas fa-${currentCallType === 'voice' ? 'phone' : 'video'} call-status-icon`;
                callStatusText.textContent = `Incoming ${currentCallType} call from ${callerUsername}...`;
                callTimerDisplay.style.display = 'none'; // Hide timer initially.
                callActions.style.display = 'flex'; // Show call action buttons.
                acceptCallBtn.style.display = 'block';
                declineCallBtn.style.display = 'block';
                toggleMuteBtn.style.display = 'none';
                toggleVideoBtn.style.display = 'none';
                endCallBtn.style.display = 'none'; // Only accept/decline for incoming.
                callStatusIcon.style.animation = 'pulse-color 2s infinite alternate'; // Start icon animation.

                startRingingSound(); // Play ringing sound.

                // Set a timeout for no answer (20 seconds).
                callTimeoutId = setTimeout(async () => {
                    if (callState === 'ringing') {
                        stopRingingSound();
                        await updateDoc(callRef, { status: 'no-answer' });
                        showMessageBox("Incoming call unanswered.", "info");
                        playNotificationSound('info');
                        endCall(true); // End call and update Firestore.
                    }
                }, 20000);
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening for incoming calls:", error);
            });
        }
        /**
         * Handles accepting an incoming call.
         * Initializes WebRTC peer connection, gets local media, sets remote description,
         * creates and sets local answer, and updates Firestore.
         */
        async function acceptCall() {
            if (callState !== 'ringing' || !callRef || !currentUser) {
                showMessageBox("Cannot accept call in current state.", "warning");
                playNotificationSound('info');
                return;
            }

            stopRingingSound(); // Stop ringing sound.
            clearTimeout(callTimeoutId); // Clear no-answer timeout.

            callState = 'connected'; // Update call state.
            callStatusText.textContent = `Call with ${recipientUserProfileData?.username || 'user'}`;
            callTimerDisplay.style.display = 'block'; // Show call timer.
            callActions.style.display = 'flex'; // Show call action buttons.
            acceptCallBtn.style.display = 'none';
            declineCallBtn.style.display = 'none';
            endCallBtn.style.display = 'block';
            toggleMuteBtn.style.display = 'block';
            toggleVideoBtn.style.display = currentCallType === 'video' ? 'block' : 'none';
            callStatusIcon.style.animation = 'none'; // Stop icon animation.

            clearInterval(callDurationInterval); // Clear any old timer.
            callDurationInterval = setInterval(updateCallTimer, 1000); // Start new timer.

            showMessageBox("Call connected!", "success");
            playNotificationSound('success');

            try {
                // Get local media stream (audio and optionally video).
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: currentCallType === 'video'
                });
                localVideo.srcObject = localStream;
                if (currentCallType === 'video') {
                    localVideo.style.display = 'block'; // Show local video if it's a video call.
                }

                // Update current user's inCall status in public profile.
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: true });

                // Create Peer Connection.
                peerConnection = createPeerConnection();

                // Add local tracks to peer connection.
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // Get the offer from Firestore.
                const callDocSnap = await getDoc(callRef);
                const callData = callDocSnap.data();
                const remoteOffer = new RTCSessionDescription(callData.offer);
                await peerConnection.setRemoteDescription(remoteOffer);

                // Create and set local answer.
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Update Firestore with answer and status.
                await updateDoc(callRef, {
                    status: 'accepted',
                    answer: {
                        type: answer.type,
                        sdp: answer.sdp
                    },
                    lastActivity: serverTimestamp()
                });

                // Add any initial candidates from caller that might have arrived before answer.
                if (callData.callerCandidates && callData.callerCandidates.length > 0) {
                    for (const candidate of callData.callerCandidates) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        } catch (e) {
                            console.error("Error adding initial caller ICE candidate:", e);
                        }
                    }
                    await updateDoc(callRef, { callerCandidates: [] }); // Clear them after adding.
                }

                // Listen for caller candidates (new ones) after call is accepted.
                // This listener needs to be distinct from the one in listenForIncomingCalls
                // to avoid issues when the status changes from ringing to accepted.
                // Re-assigning unsubscribeCallListener here will replace the previous one.
                unsubscribeCallListener = onSnapshot(callRef, async (docSnap) => {
                    if (!docSnap.exists()) {
                        console.log("JCHAT_DEBUG: Call document disappeared. Ending call.");
                        endCall(false); // End call locally if document is gone.
                        return;
                    }
                    const data = docSnap.data();
                    if (data.callerCandidates && data.callerCandidates.length > 0) {
                        for (const candidate of data.callerCandidates) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.error("Error adding caller ICE candidate:", e);
                            }
                        }
                        await updateDoc(callRef, { callerCandidates: [] }); // Clear candidates after adding.
                    }
                    // If the other party ends the call, update local state.
                    if (data.status === 'ended' && callState !== 'idle') {
                        showMessageBox("Call ended by other party.", "info");
                        playNotificationSound('info');
                        endCall(false);
                    }
                });

            } catch (error) {
                console.error("JCHAT_ERROR: Error accepting call:", error);
                // Provide user-friendly error messages for common media issues.
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showMessageBox(`Failed to accept call: Microphone/Camera access denied. Please allow permissions in your browser settings.`, "error", true, 5000);
                } else if (error.name === 'NotFoundError') {
                    showMessageBox(`Failed to accept call: No microphone or camera found. Please ensure one is connected.`, "error", true, 5000);
                } else {
                    showMessageBox(`Failed to accept call: ${error.message}`, "error", true, 5000);
                }
                playNotificationSound('error');
                endCall(true); // Ensure cleanup even if acceptance fails.
            }
        }

        /**
         * Handles declining an incoming call.
         * Updates Firestore status and cleans up.
         */
        async function declineCall() {
            if (callState !== 'ringing' || !callRef) {
                showMessageBox("Cannot decline call in current state.", "warning");
                playNotificationSound('info');
                return;
            }

            stopRingingSound(); // Stop ringing.
            clearTimeout(callTimeoutId); // Clear no-answer timeout.
            showMessageBox("Call declined.", "info");
            playNotificationSound('info');

            try {
                await updateDoc(callRef, { status: 'declined', lastActivity: serverTimestamp() });
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating call status to declined:", error);
            } finally {
                endCall(false); // End call locally, Firestore already updated.
            }
        }

        /**
         * Toggles microphone mute/unmute during a call.
         */
        function toggleMute() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state.
                    isMuted = !track.enabled; // Update mute state.
                    toggleMuteBtn.classList.toggle('active', isMuted); // Toggle active class for styling.
                    toggleMuteBtn.querySelector('i').className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone'; // Change icon.
                });
            }
        }

        /**
         * Toggles video on/off during a call.
         */
        function toggleVideo() {
            if (localStream) {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state.
                    isVideoOff = !track.enabled; // Update video off state.
                    toggleVideoBtn.classList.toggle('active', isVideoOff); // Toggle active class for styling.
                    toggleVideoBtn.querySelector('i').className = isVideoOff ? 'fas fa-video-slash' : 'fas fa-video'; // Change icon.
                    localVideo.style.display = track.enabled ? 'block' : 'none'; // Hide/show local video element.
                });
            }
        }

        /**
         * Updates the call timer display every second.
         */
        function updateCallTimer() {
            callDuration++;
            const minutes = Math.floor(callDuration / 60);
            const seconds = callDuration % 60;
            callTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Ends the call and cleans up all WebRTC resources and UI.
         * @param {boolean} updateFirestore - Whether to update the Firestore call status to 'ended'.
         */
        async function endCall(updateFirestore = true) {
            stopRingingSound(); // Stop any ringing sound.
            clearInterval(callDurationInterval); // Stop call timer.
            clearTimeout(callTimeoutId); // Clear any no-answer timeout.

            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Unsubscribe from Firestore call listener.
                unsubscribeCallListener = null;
            }

            if (peerConnection) {
                peerConnection.close(); // Close the RTCPeerConnection.
                peerConnection = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop()); // Stop all local media tracks.
                localStream = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop()); // Stop all remote media tracks.
                remoteStream = null;
            }

            // Reset video element sources and display.
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            localVideo.style.display = 'none';
            remoteVideo.style.display = 'none';

            // Hide call overlay and reset call state.
            callOverlay.classList.remove('active', 'voice-call', 'video-call');
            callState = 'idle';
            isIncomingCall = false;
            callDuration = 0;
            callTimerDisplay.textContent = '00:00';

            // Reset call action button states and icons.
            toggleMuteBtn.classList.remove('active');
            toggleVideoBtn.classList.remove('active');
            toggleMuteBtn.querySelector('i').className = 'fas fa-microphone';
            toggleVideoBtn.querySelector('i').className = 'fas fa-video';
            toggleMuteBtn.style.display = 'none';
            toggleVideoBtn.style.display = 'none';
            acceptCallBtn.style.display = 'none';
            declineCallBtn.style.display = 'none';
            endCallBtn.style.display = 'none';
            callStatusIcon.style.animation = 'none';

            // Update user's inCall status in Firestore.
            if (currentUser && currentUser.uid) {
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on endCall:", e));
            }

            // Update Firestore call document status if explicitly requested.
            if (updateFirestore && callRef) {
                try {
                    await updateDoc(callRef, { status: 'ended', lastActivity: serverTimestamp() });
                } catch (error) {
                    console.error("JCHAT_ERROR: Error updating call status to ended in Firestore:", error);
                }
            }
            callRef = null; // Clear call reference.
        }


        // --- Authentication State Listener ---
        // This is the primary entry point after the DOM is loaded.
        onAuthStateChanged(auth, async (user) => {
            console.log("JCHAT_DEBUG: onAuthStateChanged triggered. User:", user ? user.uid : "null");
            if (user) {
                currentUser = user;
                isAuthReady = true; // Set to true early so profile fetching can proceed.
                await fetchAndDisplayHeaderProfile(user); // This sets currentUserProfileData and updates UI.
                console.log("JCHAT_DEBUG: Auth is ready. User ID:", currentUser.uid, "isAuthReady:", isAuthReady);

                // Start listening to system settings in real-time.
                const unsubscribeSettings = onSnapshot(SYSTEM_SETTINGS_DOC_REF, (docSnap) => {
                    if (docSnap.exists()) {
                        currentSystemSettings = docSnap.data();
                        console.log("JCHAT_DEBUG: Real-time system settings update:", currentSystemSettings);
                        applySystemSettings(currentSystemSettings); // Apply settings on every change.
                        // Start listening for calls only after settings are loaded and calls are enabled.
                        if (currentSystemSettings.enableCalls) {
                            listenForIncomingCalls();
                        } else {
                            if (unsubscribeCallListener) {
                                unsubscribeCallListener(); // Stop listening if calls are disabled.
                                unsubscribeCallListener = null;
                            }
                            if (callState !== 'idle') {
                                endCall(false); // End any active call if feature is disabled.
                                showMessageBox("Call ended: Calls are now disabled by administrators.", "warning", true, 5000);
                            }
                        }
                    } else {
                        console.warn("JCHAT_WARNING: System settings document not found during snapshot. Re-fetching.");
                        fetchSystemSettings(); // Re-fetch if document disappears.
                    }
                }, (error) => {
                    console.error("JCHAT_ERROR: Error listening to system settings:", error);
                    showMessageBox("Failed to get real-time settings updates.", 'error', true);
                });
                unsubscribeListeners.push(unsubscribeSettings); // Add to list to unsubscribe on unload.

                await fetchSystemSettings(); // Initial fetch of system settings.
                await fetchAndDisplayPosts(); // This will setup all real-time listeners for posts and comments.
                fetchNotificationCount(user.uid);


            } else {
                console.log("JCHAT_DEBUG: No user signed in. Attempting anonymous sign-in or redirecting to login page.");
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("JCHAT_DEBUG: Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("JCHAT_DEBUG: Signed in anonymously.");
                    }
                } catch (error) {
                    console.error("JCHAT_ERROR: Error during anonymous sign-in or custom token sign-in:", error);
                    if (!auth.currentUser) {
                        window.location.href = '/login.html'; // Redirect to login if all sign-in attempts fail.
                        return; // Stop further execution.
                    }
                }
                // If we reach here, either anonymous sign-in succeeded or custom token worked.
                // Re-check currentUser after potential anonymous sign-in.
                currentUser = auth.currentUser;
                if (currentUser) {
                    isAuthReady = true;
                    await fetchAndDisplayHeaderProfile(currentUser);
                    await fetchNotificationCount(currentUser.uid);
                    console.log("JCHAT_DEBUG: Anonymous/Custom Token Auth successful. User ID:", currentUser.uid, "isAuthReady:", isAuthReady);

                    // Start listening to system settings for anonymous users too (e.g., for maintenance mode).
                    const unsubscribeSettings = onSnapshot(SYSTEM_SETTINGS_DOC_REF, (docSnap) => {
                        if (docSnap.exists()) {
                            currentSystemSettings = docSnap.data();
                            console.log("JCHAT_DEBUG: Real-time system settings update for anonymous user:", currentSystemSettings);
                            applySystemSettings(currentSystemSettings);
                            // Calls are disabled for anonymous users by default by applySystemSettings, so no need to start listener.
                        } else {
                            console.warn("JCHAT_WARNING: System settings document not found during snapshot for anonymous user. Re-fetching.");
                            fetchSystemSettings();
                        }
                    }, (error) => {
                        console.error("JCHAT_ERROR: Error listening to system settings for anonymous user:", error);
                        showMessageBox("Failed to get real-time settings updates.", 'error', true);
                    });
                    unsubscribeListeners.push(unsubscribeSettings);

                    await fetchSystemSettings(); // Initial fetch for anonymous.
                    await fetchAndDisplayPosts(); // Fetch posts for anonymous (they can view, but not interact).

                } else {
                    // This case should ideally not be reached if the above logic is correct,
                    // but as a fallback, ensure UI is for logged out state.
                    isAuthReady = false;
                    toggleInteractiveElements(false, false); // Disable all elements for unauthenticated non-admin.
                    if (headerDisplayName) headerDisplayName.textContent = "Guest";
                    if (headerProfilePic) headerProfilePic.style.display = 'none';
                    if (headerAvatarIcon) headerAvatarIcon.style.display = 'block';
                    if (adminIconLink) adminIconLink.style.display = 'none'; // Ensure admin icon is hidden for guests.

                    if (postsFeed) postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);">Please log in to see posts and interact.</p>';
                    if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                    // Show deterministic inspiration even for guests
                    displayInspiration();

                    // Ensure daily bonus button is disabled and countdown is cleared for logged out state.
                    if (claimDailyBonusButton) {
                        claimDailyBonusButton.disabled = true;
                        claimDailyBonusButton.querySelector('.button-text').textContent = "Login to Claim Bonus";
                    }
                    if (dailyBonusCountdownInterval) {
                        clearInterval(dailyBonusCountdownInterval);
                        dailyBonusCountdownInterval = null;
                    }
                    console.log("JCHAT_DEBUG: Auth is NOT ready (final fallback). isAuthReady:", isAuthReady);

                    // Set default system settings for unauthenticated view if not fetched.
                    currentSystemSettings = {
                        jcoinNairaRate: 7.5, gasJcoinRate: 0.1, dailyBonusAmount: 50,
                        defaultInspirationType: "motivational", profanityFilterSensitivity: 5,
                        enableUserRegistration: true, enableFriendRequests: true, enablePublicChat: true,
                        enablePostCreation: true, enableEmailNotifications: true, maintenanceMode: false,
                        enableCalls: true, // Default to true for calls even for anonymous users to see UI.
                        globalAnnouncement: "",
                    };
                    applySystemSettings(currentSystemSettings); // Apply default settings for unauthenticated state.
                }
            }
        });

        // Quick Actions Menu Functions
        function initializeQuickActions() {
            const toggleBtn = document.getElementById('quickActionsToggle');
            const dropdown = document.getElementById('quickActionsDropdown');
            
            if (!toggleBtn || !dropdown) {
                console.warn('Quick Actions elements not found');
                return;
            }

            // Toggle dropdown
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdown.classList.toggle('show');
                toggleBtn.classList.toggle('active');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!toggleBtn.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('show');
                    toggleBtn.classList.remove('active');
                }
            });

            // Handle quick action clicks
            dropdown.addEventListener('click', (e) => {
                const actionItem = e.target.closest('.quick-action-item');
                if (actionItem) {
                    const action = actionItem.dataset.action;
                    handleQuickAction(action);
                    dropdown.classList.remove('show');
                    toggleBtn.classList.remove('active');
                }
            });
        }

        function handleQuickAction(action) {
            // Add haptic feedback for mobile
            if ('vibrate' in navigator) {
                navigator.vibrate(50);
            }

            switch (action) {
                case 'create-post':
                    // Scroll to post creation section
                    const postSection = document.getElementById('postCreationSection');
                    if (postSection) {
                        postSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Focus on post content if user is authenticated
                        const postContent = document.getElementById('postContent');
                        if (postContent && !postContent.disabled) {
                            postContent.focus();
                        }
                    }
                    break;
                    
                case 'share-inspiration':
                    // Open share inspiration modal
                    if (typeof openShareInspirationModal === 'function') {
                        openShareInspirationModal();
                    }
                    break;
                    
                case 'daily-bonus':
                    // Scroll to daily bonus button
                    const bonusBtn = document.getElementById('claimDailyBonusButton');
                    if (bonusBtn) {
                        bonusBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Highlight the button briefly
                        bonusBtn.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            bonusBtn.style.transform = 'scale(1)';
                        }, 500);
                    }
                    break;
                    
                case 'communities':
                    // Toggle communities section
                    toggleFeatureSection('community');
                    break;
                    
                case 'ai-feed':
                    // Toggle AI smart feed section
                    toggleFeatureSection('smartFeed');
                    break;
                    
                case 'mobile-features':
                    // Toggle mobile features section
                    toggleFeatureSection('mobileFeatures');
                    break;
                    
                case 'profile':
                    // Navigate to profile page
                    window.location.href = './Profile.html';
                    break;
                    
                case 'wallet':
                    // Navigate to wallet page
                    window.location.href = './Wallet.html';
                    break;
                    
                case 'settings':
                    // Toggle sidebar (which contains settings)
                    if (typeof toggleSidebar === 'function') {
                        toggleSidebar();
                    }
                    break;
                    
                default:
                    console.log('Unknown quick action:', action);
            }
        }
        // Enhanced Mobile Experience Functions
        function initializeTouchGestures() {
            let startY = 0;
            let startTime = 0;
            let isScrolling = false;
            let lastTapTime = 0;
            let tapCount = 0;

            // Touch start
            document.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                startTime = Date.now();
                isScrolling = false;
            }, { passive: true });

            // Touch move
            document.addEventListener('touchmove', (e) => {
                if (Math.abs(e.touches[0].clientY - startY) > 10) {
                    isScrolling = true;
                }
            }, { passive: true });

            // Touch end
            document.addEventListener('touchend', (e) => {
                if (isScrolling) return;
                
                const endTime = Date.now();
                const duration = endTime - startTime;
                const deltaY = e.changedTouches[0].clientY - startY;
                
                // Quick swipe gestures
                if (duration < 300 && Math.abs(deltaY) > 50) {
                    if (deltaY < 0) {
                        // Swipe up - scroll to post creation
                        const postSection = document.getElementById('postCreationSection');
                        if (postSection) {
                            postSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    } else {
                        // Swipe down - toggle quick actions
                        const toggleBtn = document.getElementById('quickActionsToggle');
                        if (toggleBtn) {
                            toggleBtn.click();
                        }
                    }
                }

                // Double tap detection for quick actions
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                if (tapLength < 500 && tapLength > 0) {
                    tapCount++;
                    if (tapCount === 2) {
                        handleDoubleTap(e);
                        tapCount = 0;
                    }
                } else {
                    tapCount = 1;
                }
                lastTapTime = currentTime;
            }, { passive: true });

            // Add haptic feedback to buttons
            document.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    if ('vibrate' in navigator) {
                        navigator.vibrate(30);
                    }
                }
            });

            // Initialize mobile-specific features
            initializeMobileFeatures();
        }

        function handleDoubleTap(e) {
            // Double tap to show notifications
            const notificationsPanel = document.getElementById('notificationsPanel');
            if (notificationsPanel) {
                notificationsPanel.classList.add('show');
                
                // Add haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate(100);
                }
            }
        }

        function initializeMobileFeatures() {
            // Add mobile-specific CSS classes
            if (window.innerWidth <= 768) {
                document.body.classList.add('mobile-device');
            }

            // Handle orientation changes
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    updateMobileLayout();
                }, 100);
            });

            // Handle resize for mobile
            window.addEventListener('resize', () => {
                updateMobileLayout();
            });

            // Initialize mobile-specific optimizations
            optimizeForMobile();
        }

        function updateMobileLayout() {
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                document.body.classList.add('mobile-device');
            } else {
                document.body.classList.remove('mobile-device');
            }

            // Adjust quick actions position for mobile
            const quickActionsMenu = document.getElementById('quickActionsMenu');
            if (quickActionsMenu) {
                if (isMobile) {
                    quickActionsMenu.style.bottom = '20px';
                    quickActionsMenu.style.right = '20px';
                } else {
                    quickActionsMenu.style.bottom = '30px';
                    quickActionsMenu.style.right = '30px';
                }
            }
        }

        function optimizeForMobile() {
            // Add mobile-specific optimizations
            if (window.innerWidth <= 768) {
                // Reduce animations for better performance
                document.documentElement.style.setProperty('--transition', '0.2s ease');
                
                // Add mobile-specific touch improvements
                addMobileTouchImprovements();
            }
        }

        function addMobileTouchImprovements() {
            // Improve touch scrolling
            const scrollableElements = document.querySelectorAll('.notifications-list, .groups-grid, .posts-feed-section');
            scrollableElements.forEach(element => {
                element.style.webkitOverflowScrolling = 'touch';
                element.style.overscrollBehavior = 'contain';
            });

            // Add pull-to-refresh functionality
            initializePullToRefresh();
        }

        function initializePullToRefresh() {
            let startY = 0;
            let currentY = 0;
            let pullDistance = 0;
            const threshold = 80;

            document.addEventListener('touchstart', (e) => {
                if (window.scrollY === 0) {
                    startY = e.touches[0].clientY;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (window.scrollY === 0 && startY > 0) {
                    currentY = e.touches[0].clientY;
                    pullDistance = currentY - startY;
                    
                    if (pullDistance > 0) {
                        e.preventDefault();
                        showPullToRefreshIndicator(pullDistance);
                    }
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (pullDistance > threshold) {
                    triggerPullToRefresh();
                }
                hidePullToRefreshIndicator();
                startY = 0;
                pullDistance = 0;
            }, { passive: true });
        }

        function showPullToRefreshIndicator(distance) {
            // Create or update pull-to-refresh indicator
            let indicator = document.getElementById('pullToRefreshIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'pullToRefreshIndicator';
                indicator.className = 'pull-to-refresh-indicator';
                indicator.innerHTML = '<i class="fas fa-arrow-down"></i> Pull to refresh';
                document.body.appendChild(indicator);
            }
            
            indicator.style.transform = `translateY(${Math.min(distance, 100)}px)`;
            indicator.style.opacity = Math.min(distance / threshold, 1);
        }
        function hidePullToRefreshIndicator() {
            const indicator = document.getElementById('pullToRefreshIndicator');
            if (indicator) {
                indicator.style.transform = 'translateY(-100px)';
                indicator.style.opacity = '0';
            }
        }

        function triggerPullToRefresh() {
            // Trigger refresh of content
            if (window.smartFeedManager) {
                window.smartFeedManager.refreshFeed();
            }
            
            // Add haptic feedback
            if ('vibrate' in navigator) {
                navigator.vibrate(200);
            }
        }

        // Smart Notifications System
        class NotificationsManager {
            constructor() {
                this.notifications = [];
                this.notificationsPanel = document.getElementById('notificationsPanel');
                this.notificationsList = document.getElementById('notificationsList');
                this.notificationsCount = document.getElementById('notificationsCount');
                this.clearNotificationsBtn = document.getElementById('clearNotificationsBtn');
                
                this.initialize();
            }

            initialize() {
                this.loadNotifications();
                this.setupEventListeners();
                this.startAutoNotifications();
            }

            setupEventListeners() {
                if (this.clearNotificationsBtn) {
                    this.clearNotificationsBtn.addEventListener('click', () => {
                        this.clearAllNotifications();
                    });
                }
                const saveBtn = document.getElementById('saveNotificationsBtn');
                const downloadBtn = document.getElementById('downloadNotificationsBtn');
                const shareBtn = document.getElementById('shareNotificationsBtn');
                if (saveBtn) saveBtn.addEventListener('click', ()=> this.saveNotifications());
                if (downloadBtn) downloadBtn.addEventListener('click', ()=> this.downloadNotifications());
                if (shareBtn) shareBtn.addEventListener('click', ()=> this.shareNotifications());
            }

            addNotification(type, title, message, data = {}) {
                const notification = {
                    id: Date.now() + Math.random(),
                    type: type, // 'info', 'success', 'warning', 'error'
                    title: title,
                    message: message,
                    timestamp: new Date(),
                    data: data,
                    read: false
                };

                this.notifications.unshift(notification);
                this.saveNotifications();
                this.displayNotifications();
                this.showNotificationPanel();
                
                // Keep panel open until user closes it manually

                return notification.id;
            }

            removeNotification(id) {
                this.notifications = this.notifications.filter(n => n.id !== id);
                this.saveNotifications();
                this.displayNotifications();
            }

            clearAllNotifications() {
                this.notifications = [];
                this.saveNotifications();
                this.displayNotifications();
                this.hideNotificationPanel();
            }

            displayNotifications() {
                if (!this.notificationsList) return;

                if (this.notifications.length === 0) {
                    this.notificationsList.innerHTML = `
                        <div class="no-notifications">
                            <i class="fas fa-inbox"></i>
                            <p>No notifications yet</p>
                            <span>We'll notify you about important updates</span>
                        </div>
                    `;
                    this.updateCount(0);
                    return;
                }

                this.notificationsList.innerHTML = this.notifications
                    .map(notification => this.createNotificationElement(notification))
                    .join('');

                this.updateCount(this.notifications.length);
            }

            createNotificationElement(notification) {
                const timeAgo = this.getTimeAgo(notification.timestamp);
                const icon = this.getNotificationIcon(notification.type);
                
                return `
                    <div class="notification-item ${notification.type}" data-id="${notification.id}">
                        <div class="notification-icon">
                            <i class="${icon}"></i>
                        </div>
                        <div class="notification-content">
                            <div class="notification-title">${notification.title}</div>
                            <div class="notification-message">${notification.message}</div>
                            <div class="notification-time">${timeAgo}</div>
                        </div>
                        <button class="remove-notification-btn" onclick="notificationsManager.removeNotification(${notification.id})" aria-label="Remove notification">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
            }

            getNotificationIcon(type) {
                const icons = {
                    info: 'fas fa-info-circle',
                    success: 'fas fa-check-circle',
                    warning: 'fas fa-exclamation-triangle',
                    error: 'fas fa-times-circle'
                };
                return icons[type] || icons.info;
            }

            getTimeAgo(timestamp) {
                const now = new Date();
                const diff = now - timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (minutes < 1) return 'Just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                return `${days}d ago`;
            }

            updateCount(count) {
                if (this.notificationsCount) {
                    this.notificationsCount.textContent = count;
                    this.notificationsCount.style.display = count > 0 ? 'inline' : 'none';
                }
                
                // Also update header notification count
                const headerNotificationCount = document.getElementById('headerNotificationCount');
                if (headerNotificationCount) {
                    headerNotificationCount.textContent = count;
                    headerNotificationCount.style.display = count > 0 ? 'inline' : 'none';
                }
                
                // Update header notification wrapper class
                const notificationWrapper = document.querySelector('.notification-icon-wrapper');
                if (notificationWrapper) {
                    if (count > 0) {
                        notificationWrapper.classList.add('has-notifications');
                    } else {
                        notificationWrapper.classList.remove('has-notifications');
                    }
                }
            }

            showNotificationPanel() {
                if (this.notificationsPanel) {
                    this.notificationsPanel.style.display = 'block';
                    // Force reflow to ensure transition works
                    this.notificationsPanel.offsetHeight;
                    this.notificationsPanel.classList.add('show');
                }
            }

            hideNotificationPanel() {
                if (this.notificationsPanel) {
                    this.notificationsPanel.classList.remove('show');
                    // Wait for transition to complete before hiding
                    setTimeout(() => {
                        if (this.notificationsPanel && !this.notificationsPanel.classList.contains('show')) {
                            this.notificationsPanel.style.display = 'none';
                        }
                    }, 300); // Match the CSS transition duration
                }
            }

            saveNotifications() {
                try {
                    localStorage.setItem('jchat-notifications', JSON.stringify(this.notifications));
                    showMessageBox('Notifications saved.', 'success');
                } catch (error) {
                    console.warn('Failed to save notifications:', error);
                    showMessageBox('Failed to save notifications.', 'error');
                }
            }

            downloadNotifications() {
                try {
                    const rows = this.notifications.map(n => ({
                        id: n.id,
                        type: n.type,
                        title: n.title,
                        message: n.message,
                        timestamp: n.timestamp instanceof Date ? n.timestamp.toISOString() : n.timestamp
                    }));
                    const csvHeader = 'id,type,title,message,timestamp\n';
                    const csvBody = rows.map(r => [r.id, r.type, JSON.stringify(r.title), JSON.stringify(r.message), r.timestamp].join(',')).join('\n');
                    const blob = new Blob([csvHeader + csvBody], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-notifications-${Date.now()}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('Notifications downloaded.', 'success');
                } catch (e) {
                    console.warn('Download failed', e);
                    showMessageBox('Download failed.', 'error');
                }
            }

            shareNotifications() {
                try {
                    const text = this.notifications.slice(0, 10).map(n => `• [${n.type}] ${n.title}: ${n.message}`).join('\n');
                    if (navigator.share) {
                        navigator.share({ text }).catch(()=>{});
                    } else {
                        navigator.clipboard.writeText(text).then(()=> showMessageBox('Copied to clipboard.', 'success')).catch(()=> showMessageBox('Copy failed.', 'error'));
                    }
                } catch (e) {
                    console.warn('Share failed', e);
                    showMessageBox('Share failed.', 'error');
                }
            }

            loadNotifications() {
                try {
                    const saved = localStorage.getItem('jchat-notifications');
                    if (saved) {
                        this.notifications = JSON.parse(saved);
                        this.displayNotifications();
                    }
                } catch (error) {
                    console.warn('Failed to load notifications:', error);
                    this.notifications = [];
                }
            }

            startAutoNotifications() {
                // Add some sample notifications for demonstration
                setTimeout(() => {
                    this.addNotification('info', 'Welcome to JCHAT!', 'Start exploring and connecting with others.');
                }, 2000);

                setTimeout(() => {
                    this.addNotification('success', 'Daily Bonus Available', 'Claim your daily bonus to earn JCoins!');
                }, 5000);

                // Check for daily bonus eligibility
                setInterval(() => {
                    if (currentUser && isAuthReady) {
                        this.checkDailyBonusEligibility();
                    }
                }, 300000); // Check every 5 minutes
            }

            checkDailyBonusEligibility() {
                // This would integrate with your existing daily bonus system
                const lastClaimed = localStorage.getItem('jchat-last-daily-bonus');
                const now = new Date().toDateString();
                
                if (lastClaimed !== now) {
                    this.addNotification('success', 'Daily Bonus Ready!', 'You can claim your daily bonus now.');
                }
            }
        }

        // Feature Toggle Manager
        function toggleFeatureSection(featureType) {
            const featureToggleBtn = document.getElementById(`toggle${featureType.charAt(0).toUpperCase() + featureType.slice(1)}Btn`);
            if (featureToggleBtn) {
                featureToggleBtn.click();
            }
        }

        function setupFeatureToggles() {
            // Community toggle
            const toggleCommunityBtn = document.getElementById('toggleCommunityBtn');
            if (toggleCommunityBtn) {
                toggleCommunityBtn.addEventListener('click', () => {
                    const communitiesSection = document.getElementById('communityGroupsSection');
                    if (communitiesSection) {
                        communitiesSection.classList.toggle('hidden');
                        toggleCommunityBtn.classList.toggle('active');
                        updateToggleStatus(toggleCommunityBtn, communitiesSection.classList.contains('hidden'));
                    }
                });
            }

            // Smart Feed toggle
            const toggleSmartFeedBtn = document.getElementById('toggleSmartFeedBtn');
            if (toggleSmartFeedBtn) {
                toggleSmartFeedBtn.addEventListener('click', () => {
                    const smartFeedSection = document.getElementById('smartFeedSection');
                    if (smartFeedSection) {
                        smartFeedSection.classList.toggle('hidden');
                        toggleSmartFeedBtn.classList.toggle('active');
                        updateToggleStatus(toggleSmartFeedBtn, smartFeedSection.classList.contains('hidden'));
                    }
                });
            }

            // Mobile Features toggle
            const toggleMobileFeaturesBtn = document.getElementById('toggleMobileFeaturesBtn');
            if (toggleMobileFeaturesBtn) {
                toggleMobileFeaturesBtn.addEventListener('click', () => {
                    // For mobile features, we just show a notification since they're always active
                    if (window.notificationsManager) {
                        window.notificationsManager.addNotification(
                            'info',
                            'Mobile Features',
                            'Mobile features are always active! Try swiping, double-tapping, and pull-to-refresh.'
                        );
                    }
                    toggleMobileFeaturesBtn.classList.toggle('active');
                    updateToggleStatus(toggleMobileFeaturesBtn, !toggleMobileFeaturesBtn.classList.contains('active'));
                });
            }
        }

        function updateToggleStatus(button, isHidden) {
            const statusElement = button.querySelector('.toggle-status');
            if (statusElement) {
                if (isHidden) {
                    statusElement.textContent = 'OFF';
                    statusElement.style.background = 'var(--glass-blue)';
                    statusElement.style.color = 'var(--blue)';
                } else {
                    statusElement.textContent = 'ON';
                    statusElement.style.background = 'rgba(76, 175, 80, 0.2)';
                    statusElement.style.color = 'var(--status-online)';
                }
            }
            
            // Track feature usage
            const featureType = button.dataset.feature;
            trackFeatureUsage(featureType, !isHidden);
            
            // Update Quick Action status
            updateQuickActionStatus(featureType, !isHidden);
        }

        function updateQuickActionStatus(featureType, isActive) {
            const statusMap = {
                'community': 'quickCommunitiesStatus',
                'smartFeed': 'quickAiFeedStatus',
                'mobileFeatures': 'quickMobileStatus'
            };
            
            const statusElement = document.getElementById(statusMap[featureType]);
            if (statusElement) {
                if (isActive) {
                    statusElement.classList.add('active');
                } else {
                    statusElement.classList.remove('active');
                }
            }
        }

        function trackFeatureUsage(featureType, isEnabled) {
            try {
                const usageData = JSON.parse(localStorage.getItem('jchat-feature-usage') || '{}');
                if (!usageData[featureType]) {
                    usageData[featureType] = {
                        enabled: 0,
                        disabled: 0,
                        lastUsed: null
                    };
                }
                
                if (isEnabled) {
                    usageData[featureType].enabled++;
                    usageData[featureType].lastUsed = Date.now();
                } else {
                    usageData[featureType].disabled++;
                }
                
                localStorage.setItem('jchat-feature-usage', JSON.stringify(usageData));
                
                // Show usage notification for first-time users
                if (usageData[featureType].enabled === 1 && window.notificationsManager) {
                    window.notificationsManager.addNotification(
                        'success',
                        'Feature Activated!',
                        `You've enabled ${getFeatureDisplayName(featureType)}. Enjoy exploring!`
                    );
                }
            } catch (error) {
                console.warn('Failed to track feature usage:', error);
            }
        }

        function getFeatureDisplayName(featureType) {
            const names = {
                'community': 'Communities',
                'smartFeed': 'AI Smart Feed',
                'mobileFeatures': 'Mobile Features'
            };
            return names[featureType] || featureType;
        }
        function generateSmartRecommendations() {
            const recommendationItems = document.getElementById('recommendationItems');
            if (!recommendationItems) return;

            const recommendations = [];
            const usageData = JSON.parse(localStorage.getItem('jchat-feature-usage') || '{}');
            const currentTime = Date.now();

            // Check for new users (no features used yet)
            const totalUsage = Object.values(usageData).reduce((sum, data) => sum + data.enabled + data.disabled, 0);
            if (totalUsage === 0) {
                recommendations.push({
                    icon: 'fas fa-users',
                    text: 'Start with Communities to connect with like-minded people',
                    action: 'Try Now',
                    feature: 'community'
                });
                recommendations.push({
                    icon: 'fas fa-brain',
                    text: 'Enable AI Smart Feed for personalized content',
                    action: 'Enable',
                    feature: 'smartFeed'
                });
            } else {
                // Check for inactive features
                Object.entries(usageData).forEach(([feature, data]) => {
                    if (data.enabled === 0 && data.disabled === 0) {
                        recommendations.push({
                            icon: getFeatureIcon(feature),
                            text: `Try ${getFeatureDisplayName(feature)} to enhance your experience`,
                            action: 'Enable',
                            feature: feature
                        });
                    } else if (data.enabled > 0 && data.lastUsed) {
                        const daysSinceLastUse = (currentTime - data.lastUsed) / (1000 * 60 * 60 * 24);
                        if (daysSinceLastUse > 7) {
                            recommendations.push({
                                icon: getFeatureIcon(feature),
                                text: `You haven't used ${getFeatureDisplayName(feature)} in a while`,
                                action: 'Revisit',
                                feature: feature
                            });
                        }
                    }
                });

                // Add mobile-specific recommendations
                if (window.innerWidth <= 768) {
                    recommendations.push({
                        icon: 'fas fa-mobile-alt',
                        text: 'Mobile features are optimized for your device',
                        action: 'Learn More',
                        feature: 'mobileFeatures'
                    });
                }

                // Add community recommendations if user is active
                if (usageData.community && usageData.community.enabled > 0) {
                    recommendations.push({
                        icon: 'fas fa-plus',
                        text: 'Create your own community group',
                        action: 'Create',
                        feature: 'community'
                    });
                }
            }

            // Limit to 3 recommendations
            const limitedRecommendations = recommendations.slice(0, 3);
            
            if (limitedRecommendations.length === 0) {
                recommendationItems.innerHTML = '<p style="color: var(--text-light); font-style: italic; text-align: center;">All features are optimized for you!</p>';
                return;
            }

            recommendationItems.innerHTML = limitedRecommendations
                .map(rec => `
                    <div class="recommendation-item">
                        <i class="${rec.icon}"></i>
                        <div class="recommendation-text">${rec.text}</div>
                        <button class="recommendation-action" onclick="handleRecommendationAction('${rec.feature}')">
                            ${rec.action}
                        </button>
                    </div>
                `)
                .join('');
        }

        function getFeatureIcon(feature) {
            const icons = {
                'community': 'fas fa-users',
                'smartFeed': 'fas fa-brain',
                'mobileFeatures': 'fas fa-mobile-alt'
            };
            return icons[feature] || 'fas fa-star';
        }

        function handleRecommendationAction(feature) {
            // Enable the recommended feature
            const toggleBtn = document.getElementById(`toggle${feature.charAt(0).toUpperCase() + feature.slice(1)}Btn`);
            if (toggleBtn) {
                toggleBtn.click();
            }

            // Add haptic feedback
            if ('vibrate' in navigator) {
                navigator.vibrate(50);
            }

            // Show success notification
            if (window.notificationsManager) {
                window.notificationsManager.addNotification(
                    'success',
                    'Feature Enabled!',
                    `${getFeatureDisplayName(feature)} has been activated based on our recommendation.`
                );
            }
        }
        window.handleRecommendationAction = handleRecommendationAction;

        // Community Groups & Interest Hubs Manager
        class CommunityGroupsManager {
            constructor() {
                this.groups = [];
                this.userInterests = [];
                this.initialize();
            }

            initialize() {
                this.loadUserInterests();
                this.setupEventListeners();
                this.subscribeToGroups();
            }

            setupEventListeners() {
                // Create group button
                const createGroupBtn = document.getElementById('createGroupBtn');
                if (createGroupBtn) {
                    createGroupBtn.addEventListener('click', () => {
                        window.location.href = '/Groups.html#create';
                    });
                }

                // Join group buttons
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('join-group-btn')) {
                        const groupId = e.target.dataset.group;
                        this.joinGroup(groupId);
                    } else if (e.target.classList.contains('group-preview-btn')) {
                        const groupId = e.target.dataset.group;
                        this.previewGroup(groupId);
                    }
                });

                // Interest tags
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('interest-tag')) {
                        e.target.classList.toggle('active');
                        this.saveUserInterests();
                    }
                });

                // Add interest button
                const addInterestBtn = document.getElementById('addInterestBtn');
                if (addInterestBtn) {
                    addInterestBtn.addEventListener('click', () => {
                        this.showAddInterestModal();
                    });
                }
            }

            subscribeToGroups() {
                try {
                    const groupsRef = collection(db, 'artifacts', appId, 'public', 'data', 'groups');
                    const q = query(groupsRef, orderBy('lastActivity','desc'));
                    onSnapshot(q, (snap) => {
                        this.groups = snap.docs.map(d => ({ id: d.id, ...d.data(), memberCount: (d.data().members||[]).length }));
                        // Re-render basic discover list in Home widget if present
                        const grid = document.getElementById('groupsGrid');
                        if (grid) {
                            grid.innerHTML = '';
                            this.groups.slice(0, 6).forEach(g => this.addGroupToDOM({
                                id: g.id,
                                name: g.name || 'Group',
                                description: g.description || '',
                                memberCount: g.memberCount || 0,
                                status: g.isPublic === false ? 'private' : 'active',
                                icon: 'fas fa-users',
                                featured: false
                            }));
                        }
                    });
                } catch (e) {
                    console.warn('Failed to subscribe to groups on Home:', e);
                    this.groups = [];
                }
            }

            joinGroup(groupId) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return;

                // Add haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate(50);
                }

                // Update button state
                const joinBtn = document.querySelector(`[data-group="${groupId}"]`);
                if (joinBtn) {
                    joinBtn.textContent = 'Joined';
                    joinBtn.style.background = 'var(--status-online)';
                    joinBtn.disabled = true;
                }

                // Add notification
                if (window.notificationsManager) {
                    window.notificationsManager.addNotification(
                        'success',
                        'Group Joined!',
                        `Welcome to ${group.name}! Start connecting with other members.`
                    );
                }

                // Save to localStorage
                this.saveUserGroups(groupId);
            }

            previewGroup(groupId) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return;

                // Show group preview modal (simplified for now)
                const message = `
                    Group: ${group.name}
                    Members: ${group.memberCount.toLocaleString()}
                    Status: ${group.status}
                    Description: ${group.description}
                `;
                
                showMessageBox(message, 'info');
            }

            showCreateGroupModal() {
                // Simplified group creation - you can expand this later
                openCustomPrompt({
                    title: 'Create Group',
                    label: 'Enter group name',
                    placeholder: 'e.g., Crypto Enthusiasts',
                }).then(groupName => {
                if (groupName && groupName.trim()) {
                    const newGroup = {
                        id: Date.now().toString(),
                        name: groupName.trim(),
                        description: '',
                        memberCount: 1,
                        status: 'new',
                        icon: 'fas fa-users',
                        featured: false
                    };

                    this.groups.unshift(newGroup);
                    this.addGroupToDOM(newGroup);
                    
                    if (window.notificationsManager) {
                        window.notificationsManager.addNotification(
                            'success',
                            'Group Created!',
                            `${groupName} has been created successfully.`
                        );
                    }
                }
                });
            }

            addGroupToDOM(group) {
                const groupsGrid = document.getElementById('groupsGrid');
                if (!groupsGrid) return;

                const groupElement = document.createElement('div');
                groupElement.className = 'group-card';
                groupElement.innerHTML = `
                    <div class="group-header">
                        <div class="group-icon">
                            <i class="${group.icon}"></i>
                        </div>
                        <div class="group-info">
                            <h4>${group.name}</h4>
                            <p>${group.description}</p>
                            <span class="member-count">${group.memberCount} member${group.memberCount !== 1 ? 's' : ''}</span>
                        </div>
                        <div class="group-status">
                            <span class="status-badge ${group.status}">${group.status}</span>
                        </div>
                    </div>
                    <div class="group-actions">
                        <button class="join-group-btn" data-group="${group.id}">Join Group</button>
                        <button class="group-preview-btn" data-group="${group.id}">Preview</button>
                    </div>
                `;

                groupsGrid.insertBefore(groupElement, groupsGrid.firstChild);
            }

            showAddInterestModal() {
                openCustomPrompt({ title: 'Add Interest', label: 'Enter interest', placeholder: 'e.g., AI/ML' }).then(interest => {
                if (interest && interest.trim()) {
                    this.addUserInterest(interest.trim());
                }
                });
            }

            addUserInterest(interest) {
                if (this.userInterests.includes(interest)) return;

                this.userInterests.push(interest);
                this.saveUserInterests();
                this.displayUserInterests();
            }

            loadUserInterests() {
                try {
                    const saved = localStorage.getItem('jchat-user-interests');
                    if (saved) {
                        this.userInterests = JSON.parse(saved);
                    } else {
                        this.userInterests = [];
                    }
                    this.displayUserInterests();
                } catch (error) {
                    console.warn('Failed to load user interests:', error);
                    this.userInterests = [];
                }
            }

            saveUserInterests() {
                try {
                    localStorage.setItem('jchat-user-interests', JSON.stringify(this.userInterests));
                } catch (error) {
                    console.warn('Failed to save user interests:', error);
                }
            }

            displayUserInterests() {
                const tagsContainer = document.querySelector('.tags-container');
                if (!tagsContainer) return;

                // Remove existing tags (except add button)
                const existingTags = tagsContainer.querySelectorAll('.interest-tag');
                existingTags.forEach(tag => tag.remove());

                // Add user interests
                this.userInterests.forEach(interest => {
                    const tag = document.createElement('span');
                    tag.className = 'interest-tag active';
                    tag.textContent = interest;
                    tagsContainer.insertBefore(tag, tagsContainer.lastElementChild);
                });
            }

            saveUserGroups(groupId) {
                try {
                    const userGroups = JSON.parse(localStorage.getItem('jchat-user-groups') || '[]');
                    if (!userGroups.includes(groupId)) {
                        userGroups.push(groupId);
                        localStorage.setItem('jchat-user-groups', JSON.stringify(userGroups));
                    }
                } catch (error) {
                    console.warn('Failed to save user groups:', error);
                }
            }
        }
        // AI-Powered Smart Feed Manager
        class SmartFeedManager {
            constructor() {
                this.currentAlgorithm = 'smart';
                this.userPreferences = {};
                this.feedHistory = [];
                this.initialize();
            }

            initialize() {
                this.loadUserPreferences();
                this.setupEventListeners();
                this.startAILearning();
            }

            setupEventListeners() {
                // Feed algorithm selector
                const feedAlgorithm = document.getElementById('feedAlgorithm');
                if (feedAlgorithm) {
                    feedAlgorithm.addEventListener('change', (e) => {
                        this.currentAlgorithm = e.target.value;
                        this.updateFeedAlgorithm();
                    });
                }

                // Refresh feed button
                const refreshFeedBtn = document.getElementById('refreshFeedBtn');
                if (refreshFeedBtn) {
                    refreshFeedBtn.addEventListener('click', () => {
                        this.refreshFeed();
                    });
                }

                // Smart filters
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('filter-tag')) {
                        this.updateFilter(e.target.dataset.filter);
                    }
                });
            }

            loadUserPreferences() {
                try {
                    const saved = localStorage.getItem('jchat-feed-preferences');
                    if (saved) {
                        this.userPreferences = JSON.parse(saved);
                    } else {
                        // Default preferences
                        this.userPreferences = {
                            preferredContentTypes: [],
                            interests: [],
                            activityLevel: 'medium',
                            lastActive: Date.now()
                        };
                    }
                } catch (error) {
                                        console.warn('Failed to load feed preferences:', error);
                    this.userPreferences = {
                            preferredContentTypes: [],
                            interests: [],
                            activityLevel: 'medium',
                            lastActive: Date.now()
                        };
                }
            }

            saveUserPreferences() {
                try {
                    localStorage.setItem('jchat-feed-preferences', JSON.stringify(this.userPreferences));
                } catch (error) {
                    console.warn('Failed to save feed preferences:', error);
                }
            }

            updateFeedAlgorithm() {
                // Update AI status based on algorithm
                const aiStatus = document.querySelector('.ai-status');
                if (aiStatus) {
                    if (this.currentAlgorithm === 'smart') {
                        aiStatus.textContent = 'Learning...';
                        aiStatus.className = 'ai-status learning';
                    } else {
                        aiStatus.textContent = 'Ready';
                        aiStatus.className = 'ai-status ready';
                    }
                }

                // Add notification about algorithm change
                if (window.notificationsManager) {
                    window.notificationsManager.addNotification(
                        'info',
                        'Feed Algorithm Updated',
                        `Switched to ${this.currentAlgorithm} algorithm`
                    );
                }

                // Save preference
                this.userPreferences.lastAlgorithm = this.currentAlgorithm;
                this.saveUserPreferences();
            }

            updateFilter(filter) {
                // Update active filter tag
                const filterTags = document.querySelectorAll('.filter-tag');
                filterTags.forEach(tag => {
                    tag.classList.remove('active');
                    if (tag.dataset.filter === filter) {
                        tag.classList.add('active');
                    }
                });

                // Apply filter to posts (this would integrate with your existing post system)
                this.applyContentFilter(filter);

                // Add haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate(30);
                }
            }

            applyContentFilter(filter) {
                // This would integrate with your existing post filtering system
                console.log(`Applying content filter: ${filter}`);
                
                // For now, just show a notification
                if (window.notificationsManager) {
                    window.notificationsManager.addNotification(
                        'info',
                        'Filter Applied',
                        `Showing ${filter === 'all' ? 'all posts' : filter + ' posts'}`
                    );
                }
            }

            refreshFeed() {
                const refreshBtn = document.getElementById('refreshFeedBtn');
                if (refreshBtn) {
                    refreshBtn.classList.add('loading');
                    
                    // Simulate refresh delay
                    setTimeout(() => {
                        refreshBtn.classList.remove('loading');
                        
                        // Add notification
                        if (window.notificationsManager) {
                            window.notificationsManager.addNotification(
                                'success',
                                'Feed Refreshed',
                                'New content loaded based on your preferences'
                            );
                        }
                        
                        // Update AI recommendations
                        this.updateAIRecommendations();
                    }, 1500);
                }
            }

            startAILearning() {
                // Simulate AI learning process
                setTimeout(() => {
                    this.updateAIRecommendations();
                }, 3000);

                // Continue learning based on user activity
                setInterval(() => {
                    this.learnFromUserActivity();
                }, 60000); // Every minute
            }

            learnFromUserActivity() {
                // Simulate learning from user behavior
                const activities = ['post_creation', 'group_joining', 'content_interaction'];
                const randomActivity = activities[Math.floor(Math.random() * activities.length)];
                
                this.userPreferences.lastActive = Date.now();
                this.userPreferences.activityLevel = this.calculateActivityLevel();
                this.saveUserPreferences();
            }

            calculateActivityLevel() {
                const now = Date.now();
                const timeSinceLastActive = now - this.userPreferences.lastActive;
                const hoursSinceActive = timeSinceLastActive / (1000 * 60 * 60);
                
                if (hoursSinceActive < 1) return 'high';
                if (hoursSinceActive < 24) return 'medium';
                return 'low';
            }

            updateAIRecommendations() {
                const aiStatus = document.querySelector('.ai-status');
                if (aiStatus) {
                    aiStatus.textContent = 'Ready';
                    aiStatus.className = 'ai-status ready';
                }

                // Update recommendations based on user preferences
                this.updateRecommendationList();
            }

            updateRecommendationList() {
                const recommendationList = document.querySelector('.recommendation-list');
                if (!recommendationList) return;

                const recommendations = this.generateRecommendations();
                
                recommendationList.innerHTML = recommendations
                    .map(rec => `<li>${rec}</li>`)
                    .join('');
            }

            generateRecommendations() {
                const baseRecommendations = [
                    'Check out the Gaming Enthusiasts community',
                    'Share your daily inspiration',
                    'Connect with tech developers'
                ];

                // Add personalized recommendations based on user preferences
                if (this.userPreferences.interests.includes('gaming')) {
                    baseRecommendations.push('Join gaming tournaments and events');
                }

                if (this.userPreferences.interests.includes('technology')) {
                    baseRecommendations.push('Share your latest coding project');
                }

                if (this.userPreferences.activityLevel === 'high') {
                    baseRecommendations.push('You\'re very active! Consider creating a group');
                }

                return baseRecommendations.slice(0, 4); // Show max 4 recommendations
            }

            trackUserInteraction(contentType, contentId) {
                // Track user interactions for AI learning
                this.feedHistory.push({
                    type: contentType,
                    id: contentId,
                    timestamp: Date.now(),
                    algorithm: this.currentAlgorithm
                });

                // Keep only last 100 interactions
                if (this.feedHistory.length > 100) {
                    this.feedHistory = this.feedHistory.slice(-100);
                }

                // Update preferences based on interaction
                this.updatePreferencesFromInteraction(contentType);
            }

            updatePreferencesFromInteraction(contentType) {
                if (!this.userPreferences.contentTypePreferences) {
                    this.userPreferences.contentTypePreferences = {};
                }

                if (!this.userPreferences.contentTypePreferences[contentType]) {
                    this.userPreferences.contentTypePreferences[contentType] = 0;
                }

                this.userPreferences.contentTypePreferences[contentType]++;
                this.saveUserPreferences();
            }
        }
        // --- Event Listeners for static elements ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme switcher
            initializeThemeSwitcher();
            console.log("JCHAT_DEBUG: DOMContentLoaded fired.");
            
            // Initialize Quick Actions Menu
            initializeQuickActions();
            
            // Initialize Enhanced Mobile Experience
            initializeTouchGestures();
            
            // Initialize Smart Notifications System
            window.notificationsManager = new NotificationsManager();
            
            // Initialize Community Groups Manager
            window.communityGroupsManager = new CommunityGroupsManager();
            
            // Initialize AI Smart Feed Manager
            window.smartFeedManager = new SmartFeedManager();
            
            // Setup header notification button
            const headerNotificationsBtn = document.getElementById('headerNotificationsBtn');
            if (headerNotificationsBtn) {
                headerNotificationsBtn.addEventListener('click', () => {
                    const notificationsPanel = document.getElementById('notificationsPanel');
                    if (notificationsPanel) {
                        const willShow = !notificationsPanel.classList.contains('show');
                        if (willShow) {
                            notificationsPanel.style.display = 'block';
                            notificationsPanel.offsetHeight;
                            notificationsPanel.classList.add('show');
                            headerNotificationsBtn.classList.add('active');
                        } else {
                            notificationsPanel.classList.remove('show');
                            headerNotificationsBtn.classList.remove('active');
                            setTimeout(()=>{ if(!notificationsPanel.classList.contains('show')) notificationsPanel.style.display='none'; }, 300);
                        }
                    }
                });
            }
            
            // Setup feature toggle buttons
            setupFeatureToggles();
            
            // Generate initial smart recommendations
            generateSmartRecommendations();
            
            // Update recommendations periodically
            setInterval(generateSmartRecommendations, 300000); // Every 5 minutes
            
            // Initially disable interactive elements until authentication state is confirmed.
            toggleInteractiveElements(false, false);
            console.log(`JCHAT_DEBUG: Initial postContentInput disabled state: ${postContentInput ? postContentInput.disabled : 'N/A (element not found)'}`);

            // Set active class for current page in sidebar.
            const currentPagePath = window.location.pathname;
            const navItems = (sidebarNavItems && typeof sidebarNavItems.forEach === 'function')
                ? sidebarNavItems
                : document.querySelectorAll('.sidebar-nav-item');
            navItems.forEach(item => {
                if (item.getAttribute('href') === currentPagePath) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });

            // Call Overlay Button Listeners (NEW)
            if (acceptCallBtn) acceptCallBtn.addEventListener('click', acceptCall);
            if (declineCallBtn) declineCallBtn.addEventListener('click', declineCall);
            if (endCallBtn) endCallBtn.addEventListener('click', () => endCall(true)); // Pass true to update Firestore.
            if (toggleMuteBtn) toggleMuteBtn.addEventListener('click', toggleMute);
            if (toggleVideoBtn) toggleVideoBtn.addEventListener('click', toggleVideo);
        });

        // Listen for changes in local storage (e.g., theme changes from other tabs).
        window.addEventListener('storage', (event) => {
            if (event.key === 'jchat-theme') {
                const newTheme = event.newValue || 'theme-dark-mode';
                if (newTheme === 'theme-light-mode' || newTheme === 'theme-dark-mode') {
                    setTheme(newTheme);
                }
            }
        });

        // Cleanup resources before the page unloads.
        window.addEventListener('beforeunload', async () => {
            // Detach all Firestore listeners before the page unloads.
            unsubscribeListeners.forEach(unsubscribe => {
                if (typeof unsubscribe === 'function') {
                    unsubscribe();
                }
            });
            unsubscribeListeners = []; // Clear the array.
            console.log("JCHAT_DEBUG: All Firestore listeners detached.");
            if (inspirationIntervalId) {
                clearInterval(inspirationIntervalId);
                console.log("JCHAT_DEBUG: Inspiration interval cleared.");
            }
            if (dailyBonusCountdownInterval) {
                clearInterval(dailyBonusCountdownInterval);
                console.log("JCHAT_DEBUG: Daily bonus countdown interval cleared.");
            }

            // Ensure inCall status is turned off when leaving the page.
            if (currentUser && currentUser.uid) {
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on beforeunload:", e));
            }
            // End any active WebRTC call.
            if (callState !== 'idle') {
                await endCall(false); // End call without updating Firestore status to avoid conflicts during unload.
            }
        });

        // Event listeners for specific UI buttons.
        if (sharePostInspirationButton) {
            sharePostInspirationButton.addEventListener('click', () => {
                if (!isAuthReady) { showMessageBox("Please log in to share inspiration.", 'error'); return; }
                openShareInspirationModal();
            });
        }
        if (customizeInspirationButton) customizeInspirationButton.addEventListener('click', openCustomizeModal);
        if (cancelCustomizeButton) cancelCustomizeButton.addEventListener('click', closeCustomizeModal);
        if (saveCustomizeButton) saveCustomizeButton.addEventListener('click', saveInspirationType);
        if (claimDailyBonusButton) claimDailyBonusButton.addEventListener('click', handleClaimDailyBonusClick);

        // Close customization modal if clicking outside its content.
        if (customizeInspirationModal) {
            customizeInspirationModal.addEventListener('click', (event) => {
                if (event.target === customizeInspirationModal) {
                    closeCustomizeModal();
                }
            });
        }
        // Share modal handlers
        function openShareInspirationModal() {
            const modal = document.getElementById('shareInspirationModal');
            if (!modal) return;
            const q = inspirationQuoteElement ? inspirationQuoteElement.textContent : '';
            const a = inspirationAuthorElement ? inspirationAuthorElement.textContent : '';
            const prevQ = document.getElementById('sharePreviewQuote');
            const prevA = document.getElementById('sharePreviewAuthor');
            if (prevQ) prevQ.textContent = q;
            if (prevA) prevA.textContent = a;
            modal.style.display = 'flex';
            setTimeout(()=> modal.classList.add('active'), 0);
        }
        function closeShareInspirationModal() {
            const modal = document.getElementById('shareInspirationModal');
            if (!modal) return;
            modal.classList.remove('active');
            setTimeout(()=> modal.style.display = 'none', 200);
        }
        async function copyCurrentInspirationToClipboard() {
            const text = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
            try { await navigator.clipboard.writeText(text); showMessageBox('Copied to clipboard!', 'success'); }
            catch { showMessageBox('Copy failed. Select and copy manually.', 'warning'); }
        }
        function navigateToChatWithPrefill(partnerUid, messageText) {
            const url = new URL('/Chat.html', window.location.origin);
            url.searchParams.set('partner', partnerUid);
            url.searchParams.set('prefill', messageText);
            window.location.href = url.toString();
        }
        async function openFriendPickerAndSend() {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            const friendPicker = document.getElementById('friendPicker');
            if (!friendPicker) { showMessageBox('Friend picker UI not found.', 'error'); return; }
            friendPicker.innerHTML = '<div style="opacity:0.8;">Loading friends...</div>';
            friendPicker.style.display = 'block';
            try {
                const friendsCollectionRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                const friendsSnapshot = await getDocs(friendsCollectionRef);
                const rows = [];
                for (const d of friendsSnapshot.docs) {
                    const fid = d.id;
                    const pubRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', fid);
                    const pubSnap = await getDoc(pubRef);
                    const username = pubSnap.exists() ? (pubSnap.data().username || fid) : fid;
                    const profilePicId = pubSnap.exists() ? (pubSnap.data().profilePicId || null) : null;
                    const usernameInitial = (username || 'U').charAt(0).toUpperCase();
                    const imgUrl = profilePicId ? getCloudinaryImageUrl(profilePicId, 'w_60,h_60,c_fill,g_face,r_max') : '';
                    const avatarMarkup = profilePicId ? `<img src="${imgUrl}" alt="${username}" style="width:36px;height:36px;border-radius:50%;object-fit:cover;border:1px solid var(--border-light);">` : `<i class="fas fa-user-circle" style="font-size:36px;color:var(--text-light)"></i>`;
                    const row = document.createElement('div');
                    row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.05);margin-bottom:6px;gap:10px;';
                    row.innerHTML = `<div style=\"display:flex;align-items:center;gap:10px;\">${avatarMarkup}<span>${username}</span></div><button class=\"btn\" data-fid=\"${fid}\">Send</button>`;
                    row.querySelector('button').addEventListener('click', () => {
                        const msg = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
                        navigateToChatWithPrefill(fid, msg);
                    });
                    rows.push(row);
                }
                friendPicker.innerHTML = '';
                const search = document.createElement('input');
                search.type = 'text';
                search.placeholder = 'Search friends';
                search.style.cssText = 'width:100%;padding:8px 10px;border-radius:8px;border:1px solid var(--border-light);margin-bottom:6px;background:var(--input-background);color:var(--white)';
                friendPicker.appendChild(search);
                const listWrap = document.createElement('div');
                friendPicker.appendChild(listWrap);
                function renderList(filter='') {
                    listWrap.innerHTML = '';
                    rows.filter(row => row.innerText.toLowerCase().includes(filter.toLowerCase())).forEach(r => listWrap.appendChild(r));
                }
                renderList('');
                search.addEventListener('input', () => renderList(search.value));
            } catch (e) {
                friendPicker.innerHTML = '<div style="color:salmon;">Failed to load friends.</div>';
                console.error('Friend picker load failed', e);
            }
        }
        function openPostComposerWithPrefill() {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in to post.', 'warning'); return; }
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox('Post creation is disabled by administrators.', 'warning'); return; }
            if (postCreationSection && postContentInput) {
                const text = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
                postCreationSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                postContentInput.value = text;
                customConfirm('Add an image to this post?').then(addImg => {
                if (addImg && postMediaUpload) postMediaUpload.click();
                closeShareInspirationModal();
                showMessageBox('Composer prefilled. You can edit and post now.', 'info');
                });
            } else {
                showMessageBox('Post composer not available on this page.', 'warning');
            }
        }
        const copyInspirationBtn = document.getElementById('copyInspirationBtn');
        const sendToFriendBtn = document.getElementById('sendToFriendBtn');
        const postInspirationBtn = document.getElementById('postInspirationBtn');
        const saveInspirationBtn = document.getElementById('saveInspirationBtn');
        const closeShareModalBtn = document.getElementById('closeShareModalBtn');
        const shareModal = document.getElementById('shareInspirationModal');
        const friendPicker = document.getElementById('friendPicker');
        if (copyInspirationBtn) copyInspirationBtn.addEventListener('click', copyCurrentInspirationToClipboard);
        if (sendToFriendBtn) sendToFriendBtn.addEventListener('click', async () => {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            // Populate friend picker
            if (friendPicker) {
                friendPicker.innerHTML = '<div style="opacity:0.8;">Loading friends...</div>';
                friendPicker.style.display = 'block';
                try {
                    const friendsCollectionRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'friends');
                    const friendsSnapshot = await getDocs(friendsCollectionRef);
                    if (friendsSnapshot.empty) {
                        friendPicker.innerHTML = '<div style="opacity:0.8;">No friends yet.</div>';
                    } else {
                        friendPicker.innerHTML = '';
                        friendsSnapshot.forEach(d => {
                            const fid = d.id;
                            const row = document.createElement('div');
                            row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.05);margin-bottom:6px;';
                            row.innerHTML = `<span>${fid}</span><button class="btn" data-fid="${fid}">Send</button>`;
                            row.querySelector('button').addEventListener('click', () => {
                                const msg = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
                                navigateToChatWithPrefill(fid, msg);
                            });
                            friendPicker.appendChild(row);
                        });
                    }
                } catch (e) {
                    friendPicker.innerHTML = '<div style="color:salmon;">Failed to load friends.</div>';
                    console.error('Friend picker load failed', e);
                }
            }
        });
        if (postInspirationBtn) postInspirationBtn.addEventListener('click', openPostComposerWithPrefill);
        if (saveInspirationBtn) saveInspirationBtn.addEventListener('click', async () => {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            try {
                const text = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
                const savedRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saved_inspirations', `${Date.now()}`);
                await setDoc(savedRef, { text, createdAt: serverTimestamp() });
                showMessageBox('Inspiration saved.', 'success');
            } catch (e) {
                showMessageBox('Failed to save inspiration.', 'error');
            }
        });
        if (closeShareModalBtn) closeShareModalBtn.addEventListener('click', closeShareInspirationModal);
        if (shareModal) shareModal.addEventListener('click', (evt)=> { if (evt.target === shareModal) closeShareInspirationModal(); });

        if (createPostButton) createPostButton.addEventListener('click', createNewPost);

        if (cancelEditPostButton) cancelEditPostButton.addEventListener('click', closeEditPostModal);
        if (saveEditedPostButton) saveEditedPostButton.addEventListener('click', saveEditedPost);

        // Close edit post modal if clicking outside its content.
        if (editPostModal) {
            editPostModal.addEventListener('click', (event) => {
                if (event.target === editPostModal) {
                    closeEditPostModal();
                }
            });
        }

        // Sidebar toggle logic.
        function toggleSidebar() {
            sidebarNav.classList.toggle('sidebar-hidden');
            sidebarNav.classList.toggle('sidebar-visible');
        }

        // Sidebar event listeners moved inside DOMContentLoaded event

        // Export helpers (CSV/JSON) for posts
        function toCsv(rows) {
            if (!rows.length) return '';
            const headers = Object.keys(rows[0]);
            const escape = (v) => {
                if (v == null) return '';
                const s = String(v).replace(/"/g, '""');
                return /[",\n]/.test(s) ? `"${s}"` : s;
            };
            const lines = [headers.join(',')];
            for (const r of rows) lines.push(headers.map(h => escape(r[h])).join(','));
            return lines.join('\n');
        }

        async function fetchAllPostsForExport(filters) {
            const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
            const qAll = query(postsCollectionRef, orderBy("timestamp", "desc"));
            const snap = await getDocs(qAll);
            const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            return items.filter(p => {
                const pType = p.mediaType ? p.mediaType : 'text';
                if (filters.type && filters.type !== 'all' && pType !== filters.type) return false;
                if (filters.search && !(p.content || '').toLowerCase().includes(filters.search)) return false;
                if (filters.from || filters.to) {
                    const ts = p.timestamp ? p.timestamp.toDate() : null;
                    if (!ts) return false;
                    if (filters.from && ts < filters.from) return false;
                    if (filters.to && ts > filters.to) return false;
                }
                return true;
            });
        }

        function getPostFilterState() {
            const type = postTypeFilter?.value || 'all';
            const search = (postSearchInput?.value || '').toLowerCase();
            let from = null, to = null;
            if (postDateFromInput?.value) from = new Date(postDateFromInput.value + 'T00:00:00');
            if (postDateToInput?.value) to = new Date(postDateToInput.value + 'T23:59:59.999');
            return { type, search, from, to };
        }

        // Wire controls
        document.addEventListener('DOMContentLoaded', () => {
            if (postTypeFilter) postTypeFilter.addEventListener('change', fetchAndDisplayPosts);
            if (postSearchInput) postSearchInput.addEventListener('input', fetchAndDisplayPosts);
            if (postDateFromInput) postDateFromInput.addEventListener('change', fetchAndDisplayPosts);
            if (postDateToInput) postDateToInput.addEventListener('change', fetchAndDisplayPosts);
            if (exportPostsCsvButton) exportPostsCsvButton.addEventListener('click', async () => {
                if (!currentUser && !isAuthReady) return showMessageBox('Please log in.', 'warning');
                showMessageBox('Preparing CSV export...', 'loading', true);
                try {
                    const filters = getPostFilterState();
                    const items = await fetchAllPostsForExport(filters);
                    const rows = items.map(p => ({
                        id: p.id,
                        type: p.mediaType ? p.mediaType : 'text',
                        content: p.content || '',
                        authorId: p.authorId || '',
                        timestamp: p.timestamp ? p.timestamp.toDate().toISOString() : ''
                    }));
                    const csv = toCsv(rows);
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-posts-${Date.now()}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('CSV downloaded.', 'success');
                } catch (e) {
                    console.error(e);
                    showMessageBox('Failed to export CSV.', 'error');
                }
            });
            if (exportPostsJsonButton) exportPostsJsonButton.addEventListener('click', async () => {
                if (!currentUser && !isAuthReady) return showMessageBox('Please log in.', 'warning');
                showMessageBox('Preparing JSON export...', 'loading', true);
                try {
                    const filters = getPostFilterState();
                    const items = await fetchAllPostsForExport(filters);
                    const json = JSON.stringify(items.map(p => ({
                        id: p.id,
                        type: p.mediaType ? p.mediaType : 'text',
                        content: p.content || '',
                        authorId: p.authorId || '',
                        timestamp: p.timestamp ? p.timestamp.toDate().toISOString() : ''
                    })), null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-posts-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('JSON downloaded.', 'success');
                } catch (e) {
                    console.error(e);
                    showMessageBox('Failed to export JSON.', 'error');
                }
            });
        });

        // Save/Unsave post helper
        async function toggleSavePost(postId, shouldSave) {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            const savedRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saved_posts', postId);
            if (shouldSave) {
                await setDoc(savedRef, { savedAt: serverTimestamp() }).catch(e => console.error('Save failed', e));
                showMessageBox('Post saved.', 'success');
            } else {
                await deleteDoc(savedRef).catch(e => console.error('Unsave failed', e));
                showMessageBox('Removed from saved.', 'info');
            }
        }

        // Enhance post content: link hashtags
        function linkHashtags(text) {
            if (!text) return '';
            return text.replace(/(^|\s)#(\w{2,30})/g, (m, p1, tag) => `${p1}<a href="#" class="hashtag-link" data-tag="${tag}">#${tag}</a>`);
        }

        // Track hashtags for trending display
        function updateTrendingHashtags(allPosts) {
            const counts = new Map();
            allPosts.forEach(p => {
                const content = p.content || '';
                const matches = content.match(/#\w{2,30}/g) || [];
                matches.forEach(tag => {
                    counts.set(tag, (counts.get(tag) || 0) + 1);
                });
            });
            const top = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5);
            if (trendingHashtagsDiv) {
                if (top.length === 0) { trendingHashtagsDiv.textContent = ''; return; }
                trendingHashtagsDiv.innerHTML = 'Trending: ' + top.map(([tag]) => `<a href="#" class="hashtag-link" data-tag="${tag.substring(1)}">${tag}</a>`).join(' • ');
            }
        }

        // Extend renderPost to link hashtags
        const _origRenderPost = renderPost;
        renderPost = function(post, postId) {
            const el = _origRenderPost(post, postId);
            const textDiv = el.querySelector('.post-content-text p');
            if (textDiv) {
                textDiv.innerHTML = linkHashtags(post.content);
            }
            return el;
        }
        // Hook into document click for save and hashtag
        document.addEventListener('click', (ev) => {
            const saveBtn = ev.target.closest('.save-post-button');
            if (saveBtn) {
                const pid = saveBtn.dataset.postId;
                const saved = saveBtn.classList.toggle('saved');
                localStorage.setItem(`saved-post-${pid}`, saved ? '1' : '0');
                toggleSavePost(pid, saved);
            }
            const tagLink = ev.target.closest('.hashtag-link');
            if (tagLink) {
                const tag = tagLink.dataset.tag;
                if (postSearchInput) postSearchInput.value = `#${tag}`;
                fetchAndDisplayPosts();
            }
        });

        // Modify posts onSnapshot to compute trending + filter saved only
        const _origFetchAndDisplayPosts = fetchAndDisplayPosts;
        fetchAndDisplayPosts = async function() {
            await _origFetchAndDisplayPosts();
            // After initial render, we cannot easily intercept onSnapshot pipeline; recompute trending client-side from DOM
            const cards = [...(postsFeed?.querySelectorAll('.post-card') || [])];
            const posts = cards.map(c => ({
                id: c.dataset.postId,
                content: (c.querySelector('.post-content-text p')?.textContent) || ''
            }));
            updateTrendingHashtags(posts);
        }

        // Re-trigger fetch when toggling saved only
        document.addEventListener('DOMContentLoaded', () => {
            if (showSavedOnlyCheckbox) showSavedOnlyCheckbox.addEventListener('change', fetchAndDisplayPosts);
        });

        // Theme selector
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            const saved = localStorage.getItem('jchat-theme');
            if (saved && [...themeSelect.options].some(o => o.value === saved)) {
                themeSelect.value = saved;
            }
            themeSelect.addEventListener('change', () => applyTheme(themeSelect.value));
        }

        // Streaks & Quests basic implementation
        const streakInfo = document.getElementById('streakInfo');
        const questsList = document.getElementById('questsList');
        async function updateStreakAndQuestsUI() {
            if (!currentUser || !currentUserProfileData) { if (streakInfo) streakInfo.textContent = 'Login to start a streak.'; return; }
            try {
                const streakDocRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'streak');
                const streakSnap = await getDoc(streakDocRef);
                const today = new Date(); today.setHours(0,0,0,0);
                let streakCount = 0; let lastDate = null;
                if (streakSnap.exists()) {
                    const d = streakSnap.data();
                    streakCount = d.count || 0;
                    lastDate = d.lastDate ? d.lastDate.toDate() : null;
                }
                // Increment if lastDate is before today
                const needIncrement = !lastDate || (new Date(lastDate.setHours(0,0,0,0)) < today);
                if (needIncrement) {
                    await setDoc(streakDocRef, { count: streakCount + 1, lastDate: serverTimestamp() }, { merge: true });
                    streakCount += 1;
                }
                if (streakInfo) streakInfo.textContent = `Current streak: ${streakCount} day${streakCount===1?'':'s'}`;
            } catch (e) { console.error('Streak update failed', e); }

            // Quests (static weekly set)
            const weekQuests = [
                { id:'q1', title:'React 10 times', target:10 },
                { id:'q2', title:'Comment 5 times', target:5 },
                { id:'q3', title:'Create 2 posts', target:2 },
            ];
            if (questsList) {
                questsList.innerHTML = '';
                weekQuests.forEach(q => {
                    const progress = 0; // placeholder; wire to activity logs later
                    const pct = Math.min(100, Math.round((progress / q.target) * 100));
                    const row = document.createElement('div');
                    row.className = 'quest-item';
                    row.innerHTML = `<span>${q.title}</span><div class="quest-progress"><div style="width:${pct}%"></div></div><span>${progress}/${q.target}</span>`;
                    questsList.appendChild(row);
                });
            }
        }
        // Daily Spin
        const spinNowButton = document.getElementById('spinNowButton');
        const spinStatus = document.getElementById('spinStatus');
        if (spinNowButton) {
            spinNowButton.addEventListener('click', async () => {
                if (!currentUser) { showMessageBox('Login to spin.', 'warning'); return; }
                const spinRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'daily_spin');
                const snap = await getDoc(spinRef);
                const now = new Date();
                if (snap.exists()) {
                    const last = snap.data().lastSpinAt?.toDate();
                    if (last) {
                        const since = now - last;
                        if (since < 24*60*60*1000) {
                            const hrs = Math.ceil((24*60*60*1000 - since)/3600000);
                            if (spinStatus) spinStatus.textContent = `Come back in ~${hrs}h.`;
                            return;
                        }
                    }
                }
                // Weighted rewards
                const rewards = [ {j:5, w:40}, {j:10, w:30}, {j:20, w:20}, {j:50, w:8}, {j:100, w:2} ];
                const totalW = rewards.reduce((a,b)=>a+b.w,0);
                let r = Math.random()*totalW, pick = rewards[0];
                for (const it of rewards) { if (r < it.w) { pick = it; break; } r -= it.w; }
                // Credit user
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'profiles', 'user_profile');
                    await runTransaction(db, async (trx) => {
                        const ps = await trx.get(profileRef);
                        const cur = ps.exists()? (ps.data().jCoins||0):0;
                        trx.update(profileRef, { jCoins: cur + pick.j, updatedAt: serverTimestamp() });
                    });
                    await setDoc(spinRef, { lastSpinAt: serverTimestamp() }, { merge: true });
                    if (spinStatus) spinStatus.textContent = `You won ${pick.j} JCoins!`;
                } catch(e) { console.error(e); showMessageBox('Spin failed.', 'error'); }
            });
        }
        // Stories
        const addStoryButton = document.getElementById('addStoryButton');
        const storyUploadInput = document.getElementById('storyUploadInput');
        const storiesBar = document.getElementById('storiesBar');
        let currentStories = [];
        if (addStoryButton && storyUploadInput) {
            addStoryButton.addEventListener('click', ()=> storyUploadInput.click());
            storyUploadInput.addEventListener('change', async (e)=>{
                const file = e.target.files[0]; if (!file || !currentUser) return;
                showMessageBox('Uploading story...', 'loading', true);
                const url = await uploadMediaToCloudinary(file);
                if (!url) { showMessageBox('Story upload failed.', 'error'); return; }
                const storiesRef = collection(db, 'artifacts', appId, 'public', 'data', 'stories');
                await addDoc(storiesRef, { userId: currentUser.uid, username: currentUserProfileData?.username||'User', mediaUrl: url, mediaType: file.type.startsWith('image/')?'image':'video', viewCount: 0, createdAt: serverTimestamp() });
                showMessageBox('Story posted!', 'success');
                fetchStories();
            });
        }
        async function fetchStories() {
            if (!storiesBar) return;
            storiesBar.innerHTML = '';
            const storiesRef = collection(db, 'artifacts', appId, 'public', 'data', 'stories');
            const qStories = query(storiesRef, orderBy('createdAt','desc'));
            const snap = await getDocs(qStories);
            const now = Date.now();
            currentStories = snap.docs
                .map(d => ({ id: d.id, ...d.data() }))
                .filter(s => (now - (s.createdAt?.toDate()?.getTime() || 0)) <= 24*60*60*1000);
            currentStories.forEach((s, idx) => {
                const item = document.createElement('div');
                item.className = 'story-item';
                const avatar = document.createElement('div');
                avatar.className = 'story-avatar';
                if (s.mediaType==='image') {
                    avatar.innerHTML = `<img src="${s.mediaUrl}" alt="story">`;
                } else {
                    avatar.innerHTML = `<i class=\"fas fa-video\"></i>`;
                }
                const name = document.createElement('span');
                name.style.color='var(--text-light)'; name.style.fontSize='0.8rem';
                name.textContent = s.username?.split(' ')[0] || 'User';
                item.appendChild(avatar); item.appendChild(name);
                item.addEventListener('click', ()=> openStory(idx));
                storiesBar.appendChild(item);
            });
        }
        // Story viewer refs/state
        const storyViewer = document.getElementById('storyViewer');
        const storyImageEl = document.getElementById('storyImage');
        const storyVideoEl = document.getElementById('storyVideo');
        const storyViewerTitle = document.getElementById('storyViewerTitle');
        const closeStoryViewerBtn = document.getElementById('closeStoryViewer');
        const prevStoryBtn = document.getElementById('prevStoryBtn');
        const nextStoryBtn = document.getElementById('nextStoryBtn');
        let currentStoryIndex = 0;
        const viewedStoryIds = new Set();

        async function openStory(index) {
            if (!currentStories || !currentStories.length) return;
            currentStoryIndex = Math.max(0, Math.min(index, currentStories.length-1));
            const s = currentStories[currentStoryIndex];
            if (!s) return;
            if (storyViewerTitle) storyViewerTitle.textContent = `${s.username || 'Story'}`;
            if (s.mediaType === 'image') {
                if (storyVideoEl) { try { storyVideoEl.pause(); } catch{} storyVideoEl.style.display = 'none'; storyVideoEl.src=''; }
                if (storyImageEl) { storyImageEl.src = s.mediaUrl; storyImageEl.style.display = 'block'; }
            } else {
                if (storyImageEl) { storyImageEl.style.display = 'none'; storyImageEl.src=''; }
                if (storyVideoEl) { storyVideoEl.src = s.mediaUrl; storyVideoEl.style.display = 'block'; storyVideoEl.play().catch(()=>{}); }
            }
            if (storyViewer) storyViewer.classList.add('active');
            if (!viewedStoryIds.has(s.id)) {
                viewedStoryIds.add(s.id);
                try {
                    const storyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'stories', s.id);
                    await updateDoc(storyDocRef, { viewCount: (s.viewCount || 0) + 1 });
                    s.viewCount = (s.viewCount || 0) + 1;
                } catch (e) { console.error('Failed to update viewCount', e); }
            }
            if (prevStoryBtn) prevStoryBtn.disabled = currentStoryIndex <= 0;
            if (nextStoryBtn) nextStoryBtn.disabled = currentStoryIndex >= currentStories.length-1;
        }
        function closeStoryViewer() {
            if (storyViewer) storyViewer.classList.remove('active');
            if (storyImageEl) { storyImageEl.style.display = 'none'; storyImageEl.src=''; }
            if (storyVideoEl) { try { storyVideoEl.pause(); } catch{} storyVideoEl.style.display = 'none'; storyVideoEl.src=''; }
        }
        if (closeStoryViewerBtn) closeStoryViewerBtn.addEventListener('click', closeStoryViewer);
        if (prevStoryBtn) prevStoryBtn.addEventListener('click', ()=> openStory(currentStoryIndex-1));
        if (nextStoryBtn) nextStoryBtn.addEventListener('click', ()=> openStory(currentStoryIndex+1));

        function attachInspirationEventListeners() {
            if (sharePostInspirationButton && !sharePostInspirationButton.dataset.bound) {
                sharePostInspirationButton.addEventListener('click', () => {
                    if (!isAuthReady) { showMessageBox("Please log in to share inspiration.", 'error'); return; }
                    if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post creation is currently disabled by administrators, so sharing as a post is not possible.", 'warning'); return; }
                    const currentQuote = inspirationQuoteElement ? inspirationQuoteElement.textContent : '';
                    openShareInspirationModal();
                });
                sharePostInspirationButton.dataset.bound = '1';
            }
            if (customizeInspirationButton && !customizeInspirationButton.dataset.bound) {
                customizeInspirationButton.addEventListener('click', openCustomizeModal);
                customizeInspirationButton.dataset.bound = '1';
            }
            if (cancelCustomizeButton && !cancelCustomizeButton.dataset.bound) {
                cancelCustomizeButton.addEventListener('click', closeCustomizeModal);
                cancelCustomizeButton.dataset.bound = '1';
            }
            if (saveCustomizeButton && !saveCustomizeButton.dataset.bound) {
                saveCustomizeButton.addEventListener('click', saveInspirationType);
                saveCustomizeButton.dataset.bound = '1';
            }
            if (claimDailyBonusButton && !claimDailyBonusButton.dataset.bound) {
                claimDailyBonusButton.addEventListener('click', handleClaimDailyBonusClick);
                claimDailyBonusButton.dataset.bound = '1';
            }
            if (customizeInspirationModal && !customizeInspirationModal.dataset.boundOutsideClick) {
                customizeInspirationModal.addEventListener('click', (event) => {
                    if (event.target === customizeInspirationModal) closeCustomizeModal();
                });
                customizeInspirationModal.dataset.boundOutsideClick = '1';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize DOM elements first
            initializeDOMElements();

            // Ensure inspiration section listeners are attached after elements exist
            attachInspirationEventListeners();
            
            updateStreakAndQuestsUI();
            fetchStories();
            initializeNotificationSystem();
            
            // Profile link - let it use default href behavior for now
            // Custom handler removed to prevent errors
            
            // Initialize sidebar toggle functionality
            if (sidebarToggleFab) sidebarToggleFab.addEventListener('click', toggleSidebar);
            if (sidebarCloseBtn) sidebarCloseBtn.addEventListener('click', toggleSidebar);
            if (sidebarLogoutLink) sidebarLogoutLink.addEventListener('click', handleLogout);
        });

        // Initialize notification system
        function initializeNotificationSystem() {
            loadNotificationsFromStorage();
        }

        /**
         * Saves notifications to localStorage
         */
        function saveNotificationsToStorage() {
            try {
                localStorage.setItem('jchat_notifications', JSON.stringify(notifications));
                localStorage.setItem('jchat_unread_count', unreadNotificationCount.toString());
            } catch (error) {
                console.log('JCHAT_DEBUG: Could not save notifications to storage:', error);
            }
        }

        /**
         * Loads notifications from localStorage
         */
        function loadNotificationsFromStorage() {
            try {
                const savedNotifications = localStorage.getItem('jchat_notifications');
                const savedCount = localStorage.getItem('jchat_unread_count');
                
                if (savedNotifications) {
                    notifications = JSON.parse(savedNotifications);
                    notifications.forEach(n => n.timestamp = new Date(n.timestamp));
                }
                
                if (savedCount) {
                    unreadNotificationCount = parseInt(savedCount);
                }
                
                updateNotificationBadge(unreadNotificationCount);
            } catch (error) {
                console.log('JCHAT_DEBUG: Could not load notifications from storage:', error);
            }
        }

        // Smart Scroll logic
        const smartScrollBtn = document.getElementById('smartScrollBtn');
        let scrollTarget = 'bottom';
        function updateSmartScrollState() {
            const nearTop = window.scrollY < 50;
            const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 50);
            if (nearBottom) { scrollTarget = 'top'; if (smartScrollBtn) { smartScrollBtn.querySelector('i').className='fas fa-arrow-up'; smartScrollBtn.querySelector('.label').textContent='Top'; } }
            else { scrollTarget = 'bottom'; if (smartScrollBtn) { smartScrollBtn.querySelector('i').className='fas fa-arrow-down'; smartScrollBtn.querySelector('.label').textContent='Bottom'; } }
        }
        if (smartScrollBtn) {
            smartScrollBtn.addEventListener('click', ()=> {
                if (scrollTarget === 'bottom') {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                } else {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
            window.addEventListener('scroll', updateSmartScrollState, { passive: true });
            window.addEventListener('resize', updateSmartScrollState);
            document.addEventListener('DOMContentLoaded', updateSmartScrollState);
        }
        // Donation widget logic
        (function setupDonationWidget(){
            const btn = document.getElementById('headerSupportBtn');
            const modal = document.getElementById('donationModal');
            const closeBtn = document.getElementById('donationCloseBtn');
            const map = {
                donationBankName: currentUserProfileData?.bankDetails?.bankName || (typeof __donation_bank_name !== 'undefined' ? __donation_bank_name : ''),
                donationAccountName: currentUserProfileData?.bankDetails?.accountName || (typeof __donation_account_name !== 'undefined' ? __donation_account_name : ''),
                donationAccountNumber: currentUserProfileData?.bankDetails?.accountNumber || (typeof __donation_account_number !== 'undefined' ? __donation_account_number : ''),
                donationSwift: (typeof __donation_swift !== 'undefined' ? __donation_swift : ''),
                donationNote: (typeof __donation_note !== 'undefined' ? __donation_note : 'If you love JCHAT, consider a small donation to support continued development. Thank you!')
            };
            Object.entries(map).forEach(([id, val])=>{
                const el = document.getElementById(id);
                if (el) el.textContent = val || '';
            });
            document.addEventListener('click', (e)=>{
                const copyBtn = e.target.closest('.copy-btn');
                if (copyBtn) {
                    const targetId = copyBtn.getAttribute('data-copy');
                    const valueEl = document.getElementById(targetId);
                    const text = valueEl ? valueEl.textContent.trim() : '';
                    if (text) navigator.clipboard.writeText(text).then(()=> showMessageBox('Copied', 'success')).catch(()=> showMessageBox('Copy failed', 'error'));
                }
            });
            const dropdown = document.getElementById('donationDropdown');
            if (btn) btn.addEventListener('click', (e)=> { 
                e.stopPropagation();
                // Refresh details from profile
                const bd = currentUserProfileData?.bankDetails || {};
                const apply = (id,val)=>{ const el=document.getElementById(id); if(el) el.textContent = val || ''; };
                apply('donationBankName', bd.bankName || map.donationBankName);
                apply('donationAccountName', bd.accountName || map.donationAccountName);
                apply('donationAccountNumber', bd.accountNumber || map.donationAccountNumber);
                apply('donationSwift', map.donationSwift);
                apply('donationNote', map.donationNote);
                if (dropdown){ dropdown.style.display = (dropdown.style.display === 'none' || dropdown.style.display === '') ? 'block' : 'none'; }
            });
            document.addEventListener('click', (e)=>{
                if (dropdown && !dropdown.contains(e.target) && e.target !== btn) dropdown.style.display = 'none';
            });
        })();
        // Global UI helpers for consistent dialogs
        function customConfirm(message, title = 'Confirm Action') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmationModal');
                const titleEl = document.getElementById('confirmationTitle');
                const msgEl = document.getElementById('confirmationMessage');
                const cancelBtn = document.getElementById('confirmCancelButton');
                const proceedBtn = document.getElementById('confirmProceedButton');
                if (!modal || !titleEl || !msgEl || !cancelBtn || !proceedBtn) {
                    resolve(window.confirm(message));
                    return;
                }
                titleEl.textContent = title;
                msgEl.textContent = message;
                modal.style.display = 'block';
                modal.offsetHeight;
                modal.classList.add('show');
                const cleanup = () => {
                    modal.classList.remove('show');
                    modal.addEventListener('transitionend', function handler() {
                        modal.style.display = 'none';
                        modal.removeEventListener('transitionend', handler);
                    }, { once: true });
                    cancelBtn.removeEventListener('click', onCancel);
                    proceedBtn.removeEventListener('click', onProceed);
                };
                const onCancel = () => { cleanup(); resolve(false); };
                const onProceed = () => { cleanup(); resolve(true); };
                cancelBtn.addEventListener('click', onCancel);
                proceedBtn.addEventListener('click', onProceed);
            });
        }
        function openCustomPrompt({ title = 'Input Required', label = 'Enter value', placeholder = '' } = {}) {
            return new Promise((resolve) => {
                // Build ephemeral modal overlay
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay show';
                overlay.style.display = 'block';
                overlay.innerHTML = `
                    <div class="modal-content">
                        <h3>${title}</h3>
                        <label style="display:block;margin:8px 0;color:var(--text-light)">${label}</label>
                        <input id="customPromptInput" type="text" placeholder="${placeholder}" style="width:100%;padding:10px;border-radius:10px;border:1px solid var(--border-light);background:var(--input-background);color:var(--white)" />
                        <div class="button-group" style="margin-top:12px;display:flex;gap:10px;justify-content:flex-end;">
                            <button id="customPromptCancel" class="modal-button cancel-button">Cancel</button>
                            <button id="customPromptOk" class="modal-button save-button">OK</button>
                        </div>
                    </div>`;
                document.body.appendChild(overlay);
                const input = overlay.querySelector('#customPromptInput');
                const ok = overlay.querySelector('#customPromptOk');
                const cancel = overlay.querySelector('#customPromptCancel');
                const close = (val) => {
                    overlay.classList.remove('show');
                    overlay.addEventListener('transitionend', function handler() {
                        overlay.remove();
                        overlay.removeEventListener('transitionend', handler);
                    }, { once: true });
                    resolve(val);
                };
                ok.addEventListener('click', () => close((input.value || '').trim()));
                cancel.addEventListener('click', () => close(''));
                input.addEventListener('keydown', (e) => { if (e.key === 'Enter') ok.click(); });
                setTimeout(()=> input && input.focus(), 0);
            });
        }
        window.customConfirm = customConfirm;
        window.openCustomPrompt = openCustomPrompt;
    </script>
</body>
</html>