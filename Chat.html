<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JCHAT - Messages</title>
    <link rel="canonical" href="https://jchat.app/Chat.html">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1877F2">

    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">

    <!-- Preconnects -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>

    <style>
        :root {
            --brand-blue: #1877F2;
            --bg: #ffffff;
            --bg-muted: #f0f2f5;
            --text: #1c1e21;
            --text-muted: #65676b;
            --bubble-in: #e4e6eb; /* incoming */
            --bubble-out: #1877F2; /* outgoing */
            --border: #dadde1;
        }

        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body { margin: 0; font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: var(--text); background: var(--bg); }

        /* App header (Lite-style) */
        .appbar { position: fixed; top: 0; left: 0; right: 0; height: 56px; background: var(--brand-blue); color: #fff; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .appbar .content { width: 100%; max-width: 1200px; padding: 0 12px; display: flex; align-items: center; gap: 8px; }
        .appbar .title { font-weight: 700; font-size: 17px; }
        .appbar .spacer { flex: 1; }
        .appbar .icon-btn { width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center; color: #fff; opacity: 0.95; border-radius: 999px; }
        .appbar .icon-btn:hover { background: rgba(255,255,255,0.15); }
        .appbar .profile { display: inline-flex; align-items: center; gap: 8px; }
        .appbar .profile img { width: 28px; height: 28px; border-radius: 999px; object-fit: cover; border: 2px solid rgba(255,255,255,0.6); }

        /* Layout */
        main { position: absolute; top: 56px; left: 0; right: 0; bottom: 0; display: grid; grid-template-columns: 340px 1fr; background: var(--bg); }
        .panel { min-height: 0; display: flex; flex-direction: column; }

        /* Left: chat list */
        .list-header { padding: 10px 12px; border-right: 1px solid var(--border); }
        .search { display: flex; gap: 8px; }
        .search input { flex: 1; height: 36px; border-radius: 999px; border: 1px solid var(--border); background: var(--bg-muted); padding: 0 12px; outline: none; color: var(--text); }
        .threads { overflow-y: auto; border-right: 1px solid var(--border); }
        .thread-row { display: grid; grid-template-columns: 44px 1fr auto; gap: 10px; align-items: center; padding: 10px 12px; cursor: pointer; }
        .thread-row:hover { background: #f7f8fa; }
        .thread-row.active { background: #e7f0fe; }
        .avatar { width: 44px; height: 44px; border-radius: 999px; background: var(--bg-muted); display: grid; place-items: center; font-weight: 700; color: var(--text-muted); overflow: hidden; }
        .avatar img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .meta { min-width: 0; }
        .name { font-weight: 700; font-size: 15px; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .preview { font-size: 13px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .right { display: flex; flex-direction: column; align-items: flex-end; gap: 6px; }
        .time { font-size: 12px; color: var(--text-muted); }
        .badge { background: var(--brand-blue); color: #fff; font-weight: 800; font-size: 11px; border-radius: 999px; padding: 2px 6px; }

        /* Right: conversation */
        .conv-header { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-bottom: 1px solid var(--border); }
        .conv-partner { display: flex; align-items: center; gap: 10px; min-width: 0; }
        .conv-partner .avatar { width: 36px; height: 36px; }
        .conv-names { min-width: 0; }
        .conv-name { font-weight: 700; font-size: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .conv-status { font-size: 12px; color: var(--text-muted); }
        .conv-actions { margin-left: auto; display: flex; gap: 6px; }
        .conv-actions .icon-btn { width: 36px; height: 36px; border-radius: 999px; display: grid; place-items: center; color: var(--text); }
        .conv-actions .icon-btn:hover { background: var(--bg-muted); }

        .messages { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 6px; background: var(--bg); }
        .msg { max-width: 75%; padding: 8px 12px; border-radius: 18px; font-size: 14px; line-height: 1.35; word-break: break-word; }
        .msg.recv { background: var(--bubble-in); color: var(--text); border-top-left-radius: 6px; }
        .msg.sent { background: var(--bubble-out); color: #fff; margin-left: auto; border-top-right-radius: 6px; }
        .msg .time { margin-top: 3px; font-size: 11px; opacity: 0.8; }

        .typing { display: none; align-items: center; gap: 8px; margin: 2px 12px; }
        .dots { display: inline-flex; gap: 4px; }
        .dots span { width: 6px; height: 6px; background: var(--brand-blue); border-radius: 999px; animation: bounce 1.2s infinite ease-in-out; opacity: 0.85; }
        .dots span:nth-child(1) { animation-delay: -0.24s; }
        .dots span:nth-child(2) { animation-delay: -0.12s; }
        @keyframes bounce { 0%,80%,100% { transform: scale(0.85); opacity: 0.5; } 40% { transform: scale(1); opacity: 1; } }

        .composer { display: grid; grid-template-columns: 1fr 44px; gap: 8px; padding: 10px 12px; border-top: 1px solid var(--border); background: var(--bg); }
        .composer textarea { height: 40px; resize: none; padding: 10px 12px; border-radius: 20px; border: 1px solid var(--border); background: var(--bg-muted); outline: none; color: var(--text); }
        .composer button { width: 44px; height: 40px; border-radius: 999px; background: var(--brand-blue); color: #fff; border: none; display: grid; place-items: center; cursor: pointer; }
        .composer button:disabled { opacity: 0.6; cursor: not-allowed; }

        /* Mobile */
        @media (max-width: 900px) {
            main { grid-template-columns: 1fr; }
            .threads { border-right: none; }
            .conv { display: none; }
            .show-conv .list { display: none; }
            .show-conv .conv { display: flex; }
            .appbar .back { display: inline-flex; }
        }
        .appbar .back { display: none; }
    </style>
</head>
<body>
    <div class="appbar">
        <div class="content">
            <button id="backBtn" class="icon-btn back" aria-label="Back"><i class="fas fa-arrow-left"></i></button>
            <div class="title">Messages</div>
            <div class="spacer"></div>
            <div class="profile">
                <img id="profileAvatar" alt="Profile" src="https://placehold.co/64x64/1877F2/ffffff?text=J">
                <span id="profileName">User</span>
            </div>
        </div>
    </div>

    <main id="layout">
        <section class="panel list" aria-label="Chats">
            <div class="list-header">
                <div class="search">
                    <input id="chatSearch" placeholder="Search or start chat by user ID">
                </div>
            </div>
            <div id="chatList" class="threads"></div>
        </section>

        <section class="panel conv" aria-label="Conversation" style="display:flex">
            <div class="conv-header">
                <div class="conv-partner">
                    <div id="partnerAvatar" class="avatar">U</div>
                    <div class="conv-names">
                        <div id="partnerName" class="conv-name">Select a chat</div>
                        <div id="partnerStatus" class="conv-status">No chat selected</div>
                    </div>
                </div>
                <div class="conv-actions">
                    <button class="icon-btn" title="Call" disabled><i class="fas fa-phone"></i></button>
                    <button class="icon-btn" title="Video" disabled><i class="fas fa-video"></i></button>
                </div>
            </div>
            <div id="messages" class="messages"></div>
            <div id="typingIndicator" class="typing">
                <div class="dots"><span></span><span></span><span></span></div>
                <div class="conv-status">Typing‚Ä¶</div>
            </div>
            <div class="composer">
                <textarea id="messageInput" placeholder="Aa"></textarea>
                <button id="sendMessageBtn" aria-label="Send"><i class="fas fa-paper-plane"></i></button>
            </div>
        </section>
    </main>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, serverTimestamp, query, orderBy, limit, onSnapshot, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-firestore.js";

        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBsBinyrD9WZZXRaCvA4gxfX7BIimydDvo",
            authDomain: "jchat-1.firebaseapp.com",
            projectId: "jchat-1",
            storageBucket: "jchat-1.firebasestorage.app",
            messagingSenderId: "680440616768",
            appId: "1:680440616768:web:6b4f03f7fa1be4cb8e83e9"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const layoutEl = document.getElementById('layout');
        const backBtn = document.getElementById('backBtn');
        const chatListEl = document.getElementById('chatList');
        const chatSearchEl = document.getElementById('chatSearch');
        const messagesEl = document.getElementById('messages');
        const inputEl = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendMessageBtn');
        const partnerAvatarEl = document.getElementById('partnerAvatar');
        const partnerNameEl = document.getElementById('partnerName');
        const partnerStatusEl = document.getElementById('partnerStatus');
        const profileNameEl = document.getElementById('profileName');
        const profileAvatarEl = document.getElementById('profileAvatar');
        const typingIndicatorEl = document.getElementById('typingIndicator');

        let unsubscribe = null;
        let unsubscribeTyping = null;
        let unsubscribePresence = null;
        let currentUser = null;
        let activePartnerId = '';
        let sharedMediaCount = 0;
        const userProfilesCache = new Map();

        function getParam(name){ return new URLSearchParams(location.search).get(name) || ''; }
        function setParam(name, value){ const u=new URL(location.href); if(value){u.searchParams.set(name,value);} else {u.searchParams.delete(name);} history.pushState({},'',u); }
        function getChatRoomId(a,b){ if(!a||!b) return 'public_chat'; return [a,b].sort().join('_'); }
        function initials(id){ if(!id) return 'U'; return id.toString().slice(0,2).toUpperCase(); }
        function fmtTime(ts){ try{ return new Intl.DateTimeFormat(undefined,{hour:'2-digit',minute:'2-digit'}).format(ts);}catch{return '';} }

        function loadRecents(){ try{ return JSON.parse(localStorage.getItem('jchat_recents')||'[]'); }catch{return [];} }
        function saveRecents(items){ localStorage.setItem('jchat_recents', JSON.stringify(items.slice(0,50))); }

        function upsertRecent(partnerId, lastText, timeMs, unreadDelta){
            const items = loadRecents();
            const now = timeMs || Date.now();
            const idx = items.findIndex(r=>r.partnerId===partnerId);
            if(idx>=0){
                const it = items[idx];
                it.lastText = lastText ?? it.lastText ?? '';
                it.updatedAt = now;
                it.unread = Math.max(0, (it.unread||0) + (unreadDelta||0));
                items.splice(idx,1);
                items.unshift(it);
            } else {
                items.unshift({ partnerId, lastText: lastText||'', updatedAt: now, unread: Math.max(0, unreadDelta||0) });
            }
            saveRecents(items);
            renderChatList();
        }
        function markRecentRead(partnerId){
            const items = loadRecents();
            const idx = items.findIndex(r=>r.partnerId===partnerId);
            if(idx>=0){ items[idx].unread = 0; saveRecents(items); renderChatList(); }
        }

        function applyAvatar(el, url, fallbackText){
            if(url){ el.innerHTML = `<img alt="avatar">`; el.querySelector('img').src = url; }
            else { el.textContent = fallbackText; }
        }
        function ensureUserProfile(uid){
            if(!uid || userProfilesCache.has(uid)) return;
            const userRef = doc(db, 'users', uid);
            onSnapshot(userRef, (snap)=>{
                const data = snap.exists() ? snap.data() : {};
                userProfilesCache.set(uid, data || {});
                chatListEl.querySelectorAll(`[data-uid="${uid}"] .avatar`).forEach((av)=> applyAvatar(av, data.photoURL, initials(uid)));
                chatListEl.querySelectorAll(`[data-uid="${uid}"] .name`).forEach((nm)=>{ if(data.displayName) nm.textContent = data.displayName; });
                if(uid === activePartnerId){
                    applyAvatar(partnerAvatarEl, data.photoURL, initials(uid));
                    if(data.displayName) partnerNameEl.textContent = data.displayName;
                }
            });
        }

        function renderChatList(){
            const q = chatSearchEl.value.trim();
            const items = loadRecents().filter(it => !q || it.partnerId.toLowerCase().includes(q.toLowerCase()));
            chatListEl.innerHTML='';
            const pub = document.createElement('div');
            pub.className = 'thread-row' + (activePartnerId?'' : ' active');
            pub.innerHTML = `<div class=avatar>üåê</div><div class=meta><div class=name>Public Chat</div><div class=preview>Everyone can chat here</div></div><div class=right><span class=time></span></div>`;
            pub.onclick = ()=> selectPartner('');
            chatListEl.appendChild(pub);

            for(const it of items){
                const row = document.createElement('div');
                row.className = 'thread-row' + (activePartnerId===it.partnerId ? ' active' : '');
                row.dataset.uid = it.partnerId;
                row.innerHTML = `
                    <div class="avatar">${initials(it.partnerId)}</div>
                    <div class="meta">
                        <div class="name">${it.partnerId}</div>
                        <div class="preview">${(it.lastText||'').replace(/</g,'&lt;')}</div>
                    </div>
                    <div class="right">
                        <span class="time">${it.updatedAt ? new Intl.DateTimeFormat(undefined,{hour:'2-digit',minute:'2-digit'}).format(new Date(it.updatedAt)) : ''}</span>
                        ${it.unread ? `<span class="badge">${it.unread}</span>` : ''}
                    </div>`;
                row.onclick = ()=> selectPartner(it.partnerId);
                chatListEl.appendChild(row);
                ensureUserProfile(it.partnerId);
            }

            if(q && !items.some(i=>i.partnerId===q)){
                const quick = document.createElement('div');
                quick.className='thread-row'; quick.dataset.uid = q;
                quick.innerHTML = `<div class=avatar>${initials(q)}</div><div class=meta><div class=name>Start chat</div><div class=preview>${q}</div></div>`;
                quick.onclick = ()=> selectPartner(q);
                chatListEl.appendChild(quick);
                ensureUserProfile(q);
            }
        }

        function renderMessage(data, myUid){
            const wrap = document.createElement('div');
            wrap.className = 'msg ' + (data.senderId===myUid ? 'sent' : 'recv');
            const text = (data.text||'').toString();
            const time = data.createdAt?.toDate ? data.createdAt.toDate() : null;
            wrap.innerHTML = `${text.replace(/</g,'&lt;')}<div class="time">${time ? fmtTime(time) : ''}</div>`;
            if(/https?:\/\//i.test(text)) { sharedMediaCount++; }
            return wrap;
        }

        function setThreadHeader(pid){
            const isPublic = !pid;
            partnerStatusEl.textContent = isPublic ? 'Everyone can see messages here' : 'Private conversation';
            if(isPublic){ partnerAvatarEl.textContent = 'üåê'; partnerNameEl.textContent = 'Public Chat'; }
            else {
                const prof = userProfilesCache.get(pid) || {};
                applyAvatar(partnerAvatarEl, prof.photoURL, initials(pid));
                partnerNameEl.textContent = prof.displayName || pid;
            }
            markRecentRead(pid);
        }
        function scrollToBottom(){ messagesEl.scrollTop = messagesEl.scrollHeight; }

        // Presence
        async function setOnline(uid){ try{ await setDoc(doc(db,'presence',uid), { online:true, lastSeen: serverTimestamp() }, { merge:true }); }catch(e){} }
        async function setOffline(uid){ try{ await setDoc(doc(db,'presence',uid), { online:false, lastSeen: serverTimestamp() }, { merge:true }); }catch(e){} }
        function watchPartnerPresence(pid){
            if(unsubscribePresence){ unsubscribePresence(); unsubscribePresence=null; }
            if(!pid){ partnerStatusEl.textContent = 'Everyone can see messages here'; return; }
            unsubscribePresence = onSnapshot(doc(db,'presence',pid), (snap)=>{
                const data = snap.exists()?snap.data():{};
                if(data.online){ partnerStatusEl.textContent = 'Online'; }
                else if(data.lastSeen?.toDate){ partnerStatusEl.textContent = 'Last seen ' + data.lastSeen.toDate().toLocaleString(); }
                else { partnerStatusEl.textContent = 'Offline'; }
            });
        }

        // Typing
        let typingTimer = null;
        async function setTyping(chatRoomId, uid, typing){ try{ await setDoc(doc(db,'chats',chatRoomId,'typing',uid), { typing, updatedAt: serverTimestamp() }, { merge:true }); }catch(e){} }
        function watchPartnerTyping(chatRoomId, partnerId){
            if(unsubscribeTyping){ unsubscribeTyping(); unsubscribeTyping = null; }
            if(!partnerId){ typingIndicatorEl.style.display='none'; return; }
            const ref = doc(db,'chats',chatRoomId,'typing',partnerId);
            unsubscribeTyping = onSnapshot(ref, (snap)=>{
                const data = snap.exists()?snap.data():{};
                typingIndicatorEl.style.display = data.typing ? 'flex' : 'none';
            });
        }

        async function ensureUserDoc(user){
            try{
                const uref = doc(db,'users', user.uid);
                const snap = await getDoc(uref);
                if(!snap.exists()){
                    await setDoc(uref, { displayName: user.displayName||'User', photoURL: user.photoURL||'', createdAt: serverTimestamp() }, { merge:true });
                } else if((snap.data().photoURL||'')!== (user.photoURL||'')){
                    await updateDoc(uref, { photoURL: user.photoURL||'' });
                }
                userProfilesCache.set(user.uid, { displayName: user.displayName||'User', photoURL: user.photoURL||'' });
            }catch(e){}
        }

        async function ensureRoom(userUid, partnerId){
            const chatRoomId = getChatRoomId(userUid, partnerId);
            const roomRef = doc(db, 'chats', chatRoomId);
            const snap = await getDoc(roomRef);
            if(!snap.exists()) await setDoc(roomRef, { createdAt: serverTimestamp(), createdBy: userUid });
        }

        async function bindThread(user, partnerId){
            activePartnerId = partnerId || '';
            setParam('uid', activePartnerId || null);
            setThreadHeader(activePartnerId);
            messagesEl.innerHTML = '';
            typingIndicatorEl.style.display='none';
            if(unsubscribe){ unsubscribe(); unsubscribe=null; }
            if(unsubscribeTyping){ unsubscribeTyping(); unsubscribeTyping=null; }
            if(unsubscribePresence){ unsubscribePresence(); unsubscribePresence=null; }

            await ensureRoom(user.uid, activePartnerId);
            const chatRoomId = getChatRoomId(user.uid, activePartnerId);
            const qy = query(collection(db, 'chats', chatRoomId, 'messages'), orderBy('createdAt','asc'), limit(500));
            unsubscribe = onSnapshot(qy, (snap)=>{
                messagesEl.innerHTML='';
                snap.forEach(d=> messagesEl.appendChild(renderMessage(d.data(), user.uid)) );
                scrollToBottom();
            });

            watchPartnerPresence(activePartnerId);
            if(activePartnerId){ watchPartnerTyping(chatRoomId, activePartnerId); ensureUserProfile(activePartnerId); }

            const onTypingActivity = ()=>{
                if(!activePartnerId) return;
                setTyping(chatRoomId, user.uid, true);
                clearTimeout(typingTimer);
                typingTimer = setTimeout(()=> setTyping(chatRoomId, user.uid, false), 1500);
            };
            inputEl.addEventListener('input', onTypingActivity);
            inputEl.addEventListener('blur', ()=>{ if(activePartnerId) setTyping(chatRoomId, user.uid, false); });

            // Mobile: show conv view
            if(matchMedia('(max-width: 900px)').matches){ document.body.querySelector('#layout')?.classList.add('show-conv'); }
        }

        async function selectPartner(pid){ if(!currentUser) return; await bindThread(currentUser, pid); }

        function updateProfileHeader(user){
            profileNameEl.textContent = user.displayName || (user.isAnonymous ? 'Guest' : 'User');
            if(user.photoURL) profileAvatarEl.src = user.photoURL;
        }

        // Events
        backBtn.addEventListener('click', ()=>{ document.getElementById('layout').classList.remove('show-conv'); });
        chatSearchEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ const v = chatSearchEl.value.trim(); if(v) selectPartner(v); } });
        chatSearchEl.addEventListener('input', renderChatList);
        sendBtn.addEventListener('click', async ()=>{
            if(!currentUser) return; const text = inputEl.value.trim(); if(!text) return; inputEl.value='';
            const chatRoomId = getChatRoomId(currentUser.uid, activePartnerId);
            try{ await addDoc(collection(db, 'chats', chatRoomId, 'messages'), { text, senderId: currentUser.uid, createdAt: serverTimestamp() }); upsertRecent(activePartnerId || '', text, Date.now(), 0); setTyping(chatRoomId, currentUser.uid, false); }catch(err){ console.error('send failed', err); }
        });
        inputEl.addEventListener('keydown', (e)=>{ if((e.key==='Enter'||e.keyCode===13) && !e.shiftKey){ e.preventDefault(); sendBtn.click(); } });

        // Auth
        onAuthStateChanged(auth, async (user)=>{
            try {
                if(!user){ await signInAnonymously(auth); return; }
                currentUser = user; updateProfileHeader(user); await ensureUserDoc(user); renderChatList();
                const initialPartner = getParam('uid') || ''; await bindThread(user, initialPartner);
                await setOnline(user.uid);
                window.addEventListener('beforeunload', ()=> setOffline(user.uid));
                document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden'){ setOffline(user.uid); } else { setOnline(user.uid); } });
            } catch(err){ console.error('init error', err); }
        });
    </script>
</body>
</html>